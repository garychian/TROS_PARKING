// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_loc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_loc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_loc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_loc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_loc_2eproto;
namespace loc {
class App2emap_DR;
struct App2emap_DRDefaultTypeInternal;
extern App2emap_DRDefaultTypeInternal _App2emap_DR_default_instance_;
class LocStatus;
struct LocStatusDefaultTypeInternal;
extern LocStatusDefaultTypeInternal _LocStatus_default_instance_;
class MapInfo;
struct MapInfoDefaultTypeInternal;
extern MapInfoDefaultTypeInternal _MapInfo_default_instance_;
class Point3D;
struct Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class VehiclePos;
struct VehiclePosDefaultTypeInternal;
extern VehiclePosDefaultTypeInternal _VehiclePos_default_instance_;
class arrows;
struct arrowsDefaultTypeInternal;
extern arrowsDefaultTypeInternal _arrows_default_instance_;
class bumps;
struct bumpsDefaultTypeInternal;
extern bumpsDefaultTypeInternal _bumps_default_instance_;
class crossWalks;
struct crossWalksDefaultTypeInternal;
extern crossWalksDefaultTypeInternal _crossWalks_default_instance_;
class laneLines;
struct laneLinesDefaultTypeInternal;
extern laneLinesDefaultTypeInternal _laneLines_default_instance_;
class padPoint;
struct padPointDefaultTypeInternal;
extern padPointDefaultTypeInternal _padPoint_default_instance_;
class padRealTimeLocation;
struct padRealTimeLocationDefaultTypeInternal;
extern padRealTimeLocationDefaultTypeInternal _padRealTimeLocation_default_instance_;
class padVehiclePose;
struct padVehiclePoseDefaultTypeInternal;
extern padVehiclePoseDefaultTypeInternal _padVehiclePose_default_instance_;
class parkingSlots;
struct parkingSlotsDefaultTypeInternal;
extern parkingSlotsDefaultTypeInternal _parkingSlots_default_instance_;
class stopLines;
struct stopLinesDefaultTypeInternal;
extern stopLinesDefaultTypeInternal _stopLines_default_instance_;
}  // namespace loc
PROTOBUF_NAMESPACE_OPEN
template<> ::loc::App2emap_DR* Arena::CreateMaybeMessage<::loc::App2emap_DR>(Arena*);
template<> ::loc::LocStatus* Arena::CreateMaybeMessage<::loc::LocStatus>(Arena*);
template<> ::loc::MapInfo* Arena::CreateMaybeMessage<::loc::MapInfo>(Arena*);
template<> ::loc::Point3D* Arena::CreateMaybeMessage<::loc::Point3D>(Arena*);
template<> ::loc::VehiclePos* Arena::CreateMaybeMessage<::loc::VehiclePos>(Arena*);
template<> ::loc::arrows* Arena::CreateMaybeMessage<::loc::arrows>(Arena*);
template<> ::loc::bumps* Arena::CreateMaybeMessage<::loc::bumps>(Arena*);
template<> ::loc::crossWalks* Arena::CreateMaybeMessage<::loc::crossWalks>(Arena*);
template<> ::loc::laneLines* Arena::CreateMaybeMessage<::loc::laneLines>(Arena*);
template<> ::loc::padPoint* Arena::CreateMaybeMessage<::loc::padPoint>(Arena*);
template<> ::loc::padRealTimeLocation* Arena::CreateMaybeMessage<::loc::padRealTimeLocation>(Arena*);
template<> ::loc::padVehiclePose* Arena::CreateMaybeMessage<::loc::padVehiclePose>(Arena*);
template<> ::loc::parkingSlots* Arena::CreateMaybeMessage<::loc::parkingSlots>(Arena*);
template<> ::loc::stopLines* Arena::CreateMaybeMessage<::loc::stopLines>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace loc {

enum LocStatusType : int {
  LOCSTS_NULL = 0,
  LOCSTS_SEARCHING = 1,
  LOCSTS_PARKING = 2,
  LOCSTS_STANDBY = 3,
  LocStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LocStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LocStatusType_IsValid(int value);
constexpr LocStatusType LocStatusType_MIN = LOCSTS_NULL;
constexpr LocStatusType LocStatusType_MAX = LOCSTS_STANDBY;
constexpr int LocStatusType_ARRAYSIZE = LocStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocStatusType_descriptor();
template<typename T>
inline const std::string& LocStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocStatusType_descriptor(), enum_t_value);
}
inline bool LocStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocStatusType>(
    LocStatusType_descriptor(), name, value);
}
// ===================================================================

class Point3D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.Point3D) */ {
 public:
  inline Point3D() : Point3D(nullptr) {}
  ~Point3D() override;
  explicit constexpr Point3D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point3D(const Point3D& from);
  Point3D(Point3D&& from) noexcept
    : Point3D() {
    *this = ::std::move(from);
  }

  inline Point3D& operator=(const Point3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point3D& operator=(Point3D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point3D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point3D* internal_default_instance() {
    return reinterpret_cast<const Point3D*>(
               &_Point3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point3D& a, Point3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Point3D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point3D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point3D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point3D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point3D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Point3D& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point3D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.Point3D";
  }
  protected:
  explicit Point3D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:loc.Point3D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class padPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.padPoint) */ {
 public:
  inline padPoint() : padPoint(nullptr) {}
  ~padPoint() override;
  explicit constexpr padPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  padPoint(const padPoint& from);
  padPoint(padPoint&& from) noexcept
    : padPoint() {
    *this = ::std::move(from);
  }

  inline padPoint& operator=(const padPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline padPoint& operator=(padPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const padPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const padPoint* internal_default_instance() {
    return reinterpret_cast<const padPoint*>(
               &_padPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(padPoint& a, padPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(padPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(padPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  padPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<padPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const padPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const padPoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(padPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.padPoint";
  }
  protected:
  explicit padPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:loc.padPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t x_;
  int32_t y_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class padVehiclePose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.padVehiclePose) */ {
 public:
  inline padVehiclePose() : padVehiclePose(nullptr) {}
  ~padVehiclePose() override;
  explicit constexpr padVehiclePose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  padVehiclePose(const padVehiclePose& from);
  padVehiclePose(padVehiclePose&& from) noexcept
    : padVehiclePose() {
    *this = ::std::move(from);
  }

  inline padVehiclePose& operator=(const padVehiclePose& from) {
    CopyFrom(from);
    return *this;
  }
  inline padVehiclePose& operator=(padVehiclePose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const padVehiclePose& default_instance() {
    return *internal_default_instance();
  }
  static inline const padVehiclePose* internal_default_instance() {
    return reinterpret_cast<const padVehiclePose*>(
               &_padVehiclePose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(padVehiclePose& a, padVehiclePose& b) {
    a.Swap(&b);
  }
  inline void Swap(padVehiclePose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(padVehiclePose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  padVehiclePose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<padVehiclePose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const padVehiclePose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const padVehiclePose& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(padVehiclePose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.padVehiclePose";
  }
  protected:
  explicit padVehiclePose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordFieldNumber = 1,
    kYawFieldNumber = 2,
    kStatusFieldNumber = 3,
    kTimeStampFieldNumber = 4,
  };
  // optional .loc.padPoint coord = 1;
  bool has_coord() const;
  private:
  bool _internal_has_coord() const;
  public:
  void clear_coord();
  const ::loc::padPoint& coord() const;
  PROTOBUF_NODISCARD ::loc::padPoint* release_coord();
  ::loc::padPoint* mutable_coord();
  void set_allocated_coord(::loc::padPoint* coord);
  private:
  const ::loc::padPoint& _internal_coord() const;
  ::loc::padPoint* _internal_mutable_coord();
  public:
  void unsafe_arena_set_allocated_coord(
      ::loc::padPoint* coord);
  ::loc::padPoint* unsafe_arena_release_coord();

  // optional float yaw = 2;
  bool has_yaw() const;
  private:
  bool _internal_has_yaw() const;
  public:
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // optional uint32 status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // optional uint64 timeStamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loc.padVehiclePose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::loc::padPoint* coord_;
  float yaw_;
  uint32_t status_;
  uint64_t timestamp_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class VehiclePos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.VehiclePos) */ {
 public:
  inline VehiclePos() : VehiclePos(nullptr) {}
  ~VehiclePos() override;
  explicit constexpr VehiclePos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VehiclePos(const VehiclePos& from);
  VehiclePos(VehiclePos&& from) noexcept
    : VehiclePos() {
    *this = ::std::move(from);
  }

  inline VehiclePos& operator=(const VehiclePos& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehiclePos& operator=(VehiclePos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehiclePos& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehiclePos* internal_default_instance() {
    return reinterpret_cast<const VehiclePos*>(
               &_VehiclePos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VehiclePos& a, VehiclePos& b) {
    a.Swap(&b);
  }
  inline void Swap(VehiclePos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehiclePos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehiclePos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VehiclePos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VehiclePos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VehiclePos& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehiclePos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.VehiclePos";
  }
  protected:
  explicit VehiclePos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float yaw = 3;
  bool has_yaw() const;
  private:
  bool _internal_has_yaw() const;
  public:
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:loc.VehiclePos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float yaw_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class App2emap_DR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.App2emap_DR) */ {
 public:
  inline App2emap_DR() : App2emap_DR(nullptr) {}
  ~App2emap_DR() override;
  explicit constexpr App2emap_DR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  App2emap_DR(const App2emap_DR& from);
  App2emap_DR(App2emap_DR&& from) noexcept
    : App2emap_DR() {
    *this = ::std::move(from);
  }

  inline App2emap_DR& operator=(const App2emap_DR& from) {
    CopyFrom(from);
    return *this;
  }
  inline App2emap_DR& operator=(App2emap_DR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const App2emap_DR& default_instance() {
    return *internal_default_instance();
  }
  static inline const App2emap_DR* internal_default_instance() {
    return reinterpret_cast<const App2emap_DR*>(
               &_App2emap_DR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(App2emap_DR& a, App2emap_DR& b) {
    a.Swap(&b);
  }
  inline void Swap(App2emap_DR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(App2emap_DR* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  App2emap_DR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<App2emap_DR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const App2emap_DR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const App2emap_DR& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(App2emap_DR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.App2emap_DR";
  }
  protected:
  explicit App2emap_DR(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kCanAngFieldNumber = 3,
    kDRStatusFieldNumber = 4,
    kTimeStampFieldNumber = 5,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float canAng = 3;
  bool has_canang() const;
  private:
  bool _internal_has_canang() const;
  public:
  void clear_canang();
  float canang() const;
  void set_canang(float value);
  private:
  float _internal_canang() const;
  void _internal_set_canang(float value);
  public:

  // optional uint32 DRStatus = 4;
  bool has_drstatus() const;
  private:
  bool _internal_has_drstatus() const;
  public:
  void clear_drstatus();
  uint32_t drstatus() const;
  void set_drstatus(uint32_t value);
  private:
  uint32_t _internal_drstatus() const;
  void _internal_set_drstatus(uint32_t value);
  public:

  // optional uint64 timeStamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loc.App2emap_DR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float canang_;
  uint32_t drstatus_;
  uint64_t timestamp_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class parkingSlots final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.parkingSlots) */ {
 public:
  inline parkingSlots() : parkingSlots(nullptr) {}
  ~parkingSlots() override;
  explicit constexpr parkingSlots(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  parkingSlots(const parkingSlots& from);
  parkingSlots(parkingSlots&& from) noexcept
    : parkingSlots() {
    *this = ::std::move(from);
  }

  inline parkingSlots& operator=(const parkingSlots& from) {
    CopyFrom(from);
    return *this;
  }
  inline parkingSlots& operator=(parkingSlots&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const parkingSlots& default_instance() {
    return *internal_default_instance();
  }
  static inline const parkingSlots* internal_default_instance() {
    return reinterpret_cast<const parkingSlots*>(
               &_parkingSlots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(parkingSlots& a, parkingSlots& b) {
    a.Swap(&b);
  }
  inline void Swap(parkingSlots* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(parkingSlots* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  parkingSlots* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<parkingSlots>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const parkingSlots& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const parkingSlots& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(parkingSlots* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.parkingSlots";
  }
  protected:
  explicit parkingSlots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 5,
    kWideDirectionFieldNumber = 6,
    kLongDirectionFieldNumber = 7,
    kIdFieldNumber = 1,
    kWidthFieldNumber = 3,
    kLengthFieldNumber = 4,
    kPsTypeFieldNumber = 2,
    kIsOccupancyFieldNumber = 8,
  };
  // optional .loc.Point3D center = 5;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::loc::Point3D& center() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_center();
  ::loc::Point3D* mutable_center();
  void set_allocated_center(::loc::Point3D* center);
  private:
  const ::loc::Point3D& _internal_center() const;
  ::loc::Point3D* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::loc::Point3D* center);
  ::loc::Point3D* unsafe_arena_release_center();

  // optional .loc.Point3D wideDirection = 6;
  bool has_widedirection() const;
  private:
  bool _internal_has_widedirection() const;
  public:
  void clear_widedirection();
  const ::loc::Point3D& widedirection() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_widedirection();
  ::loc::Point3D* mutable_widedirection();
  void set_allocated_widedirection(::loc::Point3D* widedirection);
  private:
  const ::loc::Point3D& _internal_widedirection() const;
  ::loc::Point3D* _internal_mutable_widedirection();
  public:
  void unsafe_arena_set_allocated_widedirection(
      ::loc::Point3D* widedirection);
  ::loc::Point3D* unsafe_arena_release_widedirection();

  // optional .loc.Point3D longDirection = 7;
  bool has_longdirection() const;
  private:
  bool _internal_has_longdirection() const;
  public:
  void clear_longdirection();
  const ::loc::Point3D& longdirection() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_longdirection();
  ::loc::Point3D* mutable_longdirection();
  void set_allocated_longdirection(::loc::Point3D* longdirection);
  private:
  const ::loc::Point3D& _internal_longdirection() const;
  ::loc::Point3D* _internal_mutable_longdirection();
  public:
  void unsafe_arena_set_allocated_longdirection(
      ::loc::Point3D* longdirection);
  ::loc::Point3D* unsafe_arena_release_longdirection();

  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional double width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // optional double length = 4;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // optional uint32 psType = 2;
  bool has_pstype() const;
  private:
  bool _internal_has_pstype() const;
  public:
  void clear_pstype();
  uint32_t pstype() const;
  void set_pstype(uint32_t value);
  private:
  uint32_t _internal_pstype() const;
  void _internal_set_pstype(uint32_t value);
  public:

  // optional bool isOccupancy = 8;
  bool has_isoccupancy() const;
  private:
  bool _internal_has_isoccupancy() const;
  public:
  void clear_isoccupancy();
  bool isoccupancy() const;
  void set_isoccupancy(bool value);
  private:
  bool _internal_isoccupancy() const;
  void _internal_set_isoccupancy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:loc.parkingSlots)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::loc::Point3D* center_;
  ::loc::Point3D* widedirection_;
  ::loc::Point3D* longdirection_;
  uint64_t id_;
  double width_;
  double length_;
  uint32_t pstype_;
  bool isoccupancy_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class laneLines final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.laneLines) */ {
 public:
  inline laneLines() : laneLines(nullptr) {}
  ~laneLines() override;
  explicit constexpr laneLines(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  laneLines(const laneLines& from);
  laneLines(laneLines&& from) noexcept
    : laneLines() {
    *this = ::std::move(from);
  }

  inline laneLines& operator=(const laneLines& from) {
    CopyFrom(from);
    return *this;
  }
  inline laneLines& operator=(laneLines&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const laneLines& default_instance() {
    return *internal_default_instance();
  }
  static inline const laneLines* internal_default_instance() {
    return reinterpret_cast<const laneLines*>(
               &_laneLines_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(laneLines& a, laneLines& b) {
    a.Swap(&b);
  }
  inline void Swap(laneLines* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(laneLines* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  laneLines* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<laneLines>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const laneLines& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const laneLines& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(laneLines* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.laneLines";
  }
  protected:
  explicit laneLines(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kLineTypeFieldNumber = 1,
  };
  // repeated .loc.Point3D points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::loc::Point3D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D >*
      mutable_points();
  private:
  const ::loc::Point3D& _internal_points(int index) const;
  ::loc::Point3D* _internal_add_points();
  public:
  const ::loc::Point3D& points(int index) const;
  ::loc::Point3D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D >&
      points() const;

  // optional uint32 lineType = 1;
  bool has_linetype() const;
  private:
  bool _internal_has_linetype() const;
  public:
  void clear_linetype();
  uint32_t linetype() const;
  void set_linetype(uint32_t value);
  private:
  uint32_t _internal_linetype() const;
  void _internal_set_linetype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:loc.laneLines)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D > points_;
  uint32_t linetype_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class stopLines final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.stopLines) */ {
 public:
  inline stopLines() : stopLines(nullptr) {}
  ~stopLines() override;
  explicit constexpr stopLines(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  stopLines(const stopLines& from);
  stopLines(stopLines&& from) noexcept
    : stopLines() {
    *this = ::std::move(from);
  }

  inline stopLines& operator=(const stopLines& from) {
    CopyFrom(from);
    return *this;
  }
  inline stopLines& operator=(stopLines&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const stopLines& default_instance() {
    return *internal_default_instance();
  }
  static inline const stopLines* internal_default_instance() {
    return reinterpret_cast<const stopLines*>(
               &_stopLines_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(stopLines& a, stopLines& b) {
    a.Swap(&b);
  }
  inline void Swap(stopLines* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(stopLines* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  stopLines* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<stopLines>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const stopLines& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const stopLines& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stopLines* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.stopLines";
  }
  protected:
  explicit stopLines(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartPtFieldNumber = 2,
    kEndPtFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // optional .loc.Point3D startPt = 2;
  bool has_startpt() const;
  private:
  bool _internal_has_startpt() const;
  public:
  void clear_startpt();
  const ::loc::Point3D& startpt() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_startpt();
  ::loc::Point3D* mutable_startpt();
  void set_allocated_startpt(::loc::Point3D* startpt);
  private:
  const ::loc::Point3D& _internal_startpt() const;
  ::loc::Point3D* _internal_mutable_startpt();
  public:
  void unsafe_arena_set_allocated_startpt(
      ::loc::Point3D* startpt);
  ::loc::Point3D* unsafe_arena_release_startpt();

  // optional .loc.Point3D endPt = 3;
  bool has_endpt() const;
  private:
  bool _internal_has_endpt() const;
  public:
  void clear_endpt();
  const ::loc::Point3D& endpt() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_endpt();
  ::loc::Point3D* mutable_endpt();
  void set_allocated_endpt(::loc::Point3D* endpt);
  private:
  const ::loc::Point3D& _internal_endpt() const;
  ::loc::Point3D* _internal_mutable_endpt();
  public:
  void unsafe_arena_set_allocated_endpt(
      ::loc::Point3D* endpt);
  ::loc::Point3D* unsafe_arena_release_endpt();

  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loc.stopLines)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::loc::Point3D* startpt_;
  ::loc::Point3D* endpt_;
  uint64_t id_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class bumps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.bumps) */ {
 public:
  inline bumps() : bumps(nullptr) {}
  ~bumps() override;
  explicit constexpr bumps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  bumps(const bumps& from);
  bumps(bumps&& from) noexcept
    : bumps() {
    *this = ::std::move(from);
  }

  inline bumps& operator=(const bumps& from) {
    CopyFrom(from);
    return *this;
  }
  inline bumps& operator=(bumps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const bumps& default_instance() {
    return *internal_default_instance();
  }
  static inline const bumps* internal_default_instance() {
    return reinterpret_cast<const bumps*>(
               &_bumps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(bumps& a, bumps& b) {
    a.Swap(&b);
  }
  inline void Swap(bumps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(bumps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  bumps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<bumps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const bumps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const bumps& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bumps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.bumps";
  }
  protected:
  explicit bumps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndPtFieldNumber = 4,
    kWideDirectionFieldNumber = 5,
    kLongDirectionFieldNumber = 6,
    kIdFieldNumber = 1,
    kHalfWidthFieldNumber = 2,
    kLengthFieldNumber = 3,
  };
  // optional .loc.Point3D endPt = 4;
  bool has_endpt() const;
  private:
  bool _internal_has_endpt() const;
  public:
  void clear_endpt();
  const ::loc::Point3D& endpt() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_endpt();
  ::loc::Point3D* mutable_endpt();
  void set_allocated_endpt(::loc::Point3D* endpt);
  private:
  const ::loc::Point3D& _internal_endpt() const;
  ::loc::Point3D* _internal_mutable_endpt();
  public:
  void unsafe_arena_set_allocated_endpt(
      ::loc::Point3D* endpt);
  ::loc::Point3D* unsafe_arena_release_endpt();

  // optional .loc.Point3D wideDirection = 5;
  bool has_widedirection() const;
  private:
  bool _internal_has_widedirection() const;
  public:
  void clear_widedirection();
  const ::loc::Point3D& widedirection() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_widedirection();
  ::loc::Point3D* mutable_widedirection();
  void set_allocated_widedirection(::loc::Point3D* widedirection);
  private:
  const ::loc::Point3D& _internal_widedirection() const;
  ::loc::Point3D* _internal_mutable_widedirection();
  public:
  void unsafe_arena_set_allocated_widedirection(
      ::loc::Point3D* widedirection);
  ::loc::Point3D* unsafe_arena_release_widedirection();

  // optional .loc.Point3D longDirection = 6;
  bool has_longdirection() const;
  private:
  bool _internal_has_longdirection() const;
  public:
  void clear_longdirection();
  const ::loc::Point3D& longdirection() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_longdirection();
  ::loc::Point3D* mutable_longdirection();
  void set_allocated_longdirection(::loc::Point3D* longdirection);
  private:
  const ::loc::Point3D& _internal_longdirection() const;
  ::loc::Point3D* _internal_mutable_longdirection();
  public:
  void unsafe_arena_set_allocated_longdirection(
      ::loc::Point3D* longdirection);
  ::loc::Point3D* unsafe_arena_release_longdirection();

  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional double halfWidth = 2;
  bool has_halfwidth() const;
  private:
  bool _internal_has_halfwidth() const;
  public:
  void clear_halfwidth();
  double halfwidth() const;
  void set_halfwidth(double value);
  private:
  double _internal_halfwidth() const;
  void _internal_set_halfwidth(double value);
  public:

  // optional double length = 3;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // @@protoc_insertion_point(class_scope:loc.bumps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::loc::Point3D* endpt_;
  ::loc::Point3D* widedirection_;
  ::loc::Point3D* longdirection_;
  uint64_t id_;
  double halfwidth_;
  double length_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class arrows final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.arrows) */ {
 public:
  inline arrows() : arrows(nullptr) {}
  ~arrows() override;
  explicit constexpr arrows(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  arrows(const arrows& from);
  arrows(arrows&& from) noexcept
    : arrows() {
    *this = ::std::move(from);
  }

  inline arrows& operator=(const arrows& from) {
    CopyFrom(from);
    return *this;
  }
  inline arrows& operator=(arrows&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const arrows& default_instance() {
    return *internal_default_instance();
  }
  static inline const arrows* internal_default_instance() {
    return reinterpret_cast<const arrows*>(
               &_arrows_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(arrows& a, arrows& b) {
    a.Swap(&b);
  }
  inline void Swap(arrows* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(arrows* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  arrows* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<arrows>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const arrows& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const arrows& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(arrows* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.arrows";
  }
  protected:
  explicit arrows(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrowTypeFieldNumber = 2,
    kPointsFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated uint32 arrowType = 2;
  int arrowtype_size() const;
  private:
  int _internal_arrowtype_size() const;
  public:
  void clear_arrowtype();
  private:
  uint32_t _internal_arrowtype(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_arrowtype() const;
  void _internal_add_arrowtype(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_arrowtype();
  public:
  uint32_t arrowtype(int index) const;
  void set_arrowtype(int index, uint32_t value);
  void add_arrowtype(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      arrowtype() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_arrowtype();

  // repeated .loc.Point3D points = 3;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::loc::Point3D* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D >*
      mutable_points();
  private:
  const ::loc::Point3D& _internal_points(int index) const;
  ::loc::Point3D* _internal_add_points();
  public:
  const ::loc::Point3D& points(int index) const;
  ::loc::Point3D* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D >&
      points() const;

  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loc.arrows)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > arrowtype_;
  mutable std::atomic<int> _arrowtype_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D > points_;
  uint64_t id_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class crossWalks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.crossWalks) */ {
 public:
  inline crossWalks() : crossWalks(nullptr) {}
  ~crossWalks() override;
  explicit constexpr crossWalks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  crossWalks(const crossWalks& from);
  crossWalks(crossWalks&& from) noexcept
    : crossWalks() {
    *this = ::std::move(from);
  }

  inline crossWalks& operator=(const crossWalks& from) {
    CopyFrom(from);
    return *this;
  }
  inline crossWalks& operator=(crossWalks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const crossWalks& default_instance() {
    return *internal_default_instance();
  }
  static inline const crossWalks* internal_default_instance() {
    return reinterpret_cast<const crossWalks*>(
               &_crossWalks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(crossWalks& a, crossWalks& b) {
    a.Swap(&b);
  }
  inline void Swap(crossWalks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(crossWalks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  crossWalks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<crossWalks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const crossWalks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const crossWalks& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crossWalks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.crossWalks";
  }
  protected:
  explicit crossWalks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndPtFieldNumber = 4,
    kWideDirectionFieldNumber = 5,
    kLongDirectionFieldNumber = 6,
    kIdFieldNumber = 1,
    kHalfWidthFieldNumber = 2,
    kLengthFieldNumber = 3,
  };
  // optional .loc.Point3D endPt = 4;
  bool has_endpt() const;
  private:
  bool _internal_has_endpt() const;
  public:
  void clear_endpt();
  const ::loc::Point3D& endpt() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_endpt();
  ::loc::Point3D* mutable_endpt();
  void set_allocated_endpt(::loc::Point3D* endpt);
  private:
  const ::loc::Point3D& _internal_endpt() const;
  ::loc::Point3D* _internal_mutable_endpt();
  public:
  void unsafe_arena_set_allocated_endpt(
      ::loc::Point3D* endpt);
  ::loc::Point3D* unsafe_arena_release_endpt();

  // optional .loc.Point3D wideDirection = 5;
  bool has_widedirection() const;
  private:
  bool _internal_has_widedirection() const;
  public:
  void clear_widedirection();
  const ::loc::Point3D& widedirection() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_widedirection();
  ::loc::Point3D* mutable_widedirection();
  void set_allocated_widedirection(::loc::Point3D* widedirection);
  private:
  const ::loc::Point3D& _internal_widedirection() const;
  ::loc::Point3D* _internal_mutable_widedirection();
  public:
  void unsafe_arena_set_allocated_widedirection(
      ::loc::Point3D* widedirection);
  ::loc::Point3D* unsafe_arena_release_widedirection();

  // optional .loc.Point3D longDirection = 6;
  bool has_longdirection() const;
  private:
  bool _internal_has_longdirection() const;
  public:
  void clear_longdirection();
  const ::loc::Point3D& longdirection() const;
  PROTOBUF_NODISCARD ::loc::Point3D* release_longdirection();
  ::loc::Point3D* mutable_longdirection();
  void set_allocated_longdirection(::loc::Point3D* longdirection);
  private:
  const ::loc::Point3D& _internal_longdirection() const;
  ::loc::Point3D* _internal_mutable_longdirection();
  public:
  void unsafe_arena_set_allocated_longdirection(
      ::loc::Point3D* longdirection);
  ::loc::Point3D* unsafe_arena_release_longdirection();

  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional float halfWidth = 2;
  bool has_halfwidth() const;
  private:
  bool _internal_has_halfwidth() const;
  public:
  void clear_halfwidth();
  float halfwidth() const;
  void set_halfwidth(float value);
  private:
  float _internal_halfwidth() const;
  void _internal_set_halfwidth(float value);
  public:

  // optional float length = 3;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // @@protoc_insertion_point(class_scope:loc.crossWalks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::loc::Point3D* endpt_;
  ::loc::Point3D* widedirection_;
  ::loc::Point3D* longdirection_;
  uint64_t id_;
  float halfwidth_;
  float length_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class MapInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.MapInfo) */ {
 public:
  inline MapInfo() : MapInfo(nullptr) {}
  ~MapInfo() override;
  explicit constexpr MapInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapInfo(const MapInfo& from);
  MapInfo(MapInfo&& from) noexcept
    : MapInfo() {
    *this = ::std::move(from);
  }

  inline MapInfo& operator=(const MapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapInfo& operator=(MapInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapInfo* internal_default_instance() {
    return reinterpret_cast<const MapInfo*>(
               &_MapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MapInfo& a, MapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MapInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MapInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.MapInfo";
  }
  protected:
  explicit MapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParkingSlotFieldNumber = 2,
    kLaneLineFieldNumber = 3,
    kStopLineFieldNumber = 4,
    kBumpFieldNumber = 5,
    kCrossWalkFieldNumber = 6,
    kArrowFieldNumber = 7,
    kParkingSlotsOptimizeFieldNumber = 8,
    kTimeStampFieldNumber = 1,
    kMapIdFieldNumber = 9,
  };
  // repeated .loc.parkingSlots ParkingSlot = 2;
  int parkingslot_size() const;
  private:
  int _internal_parkingslot_size() const;
  public:
  void clear_parkingslot();
  ::loc::parkingSlots* mutable_parkingslot(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots >*
      mutable_parkingslot();
  private:
  const ::loc::parkingSlots& _internal_parkingslot(int index) const;
  ::loc::parkingSlots* _internal_add_parkingslot();
  public:
  const ::loc::parkingSlots& parkingslot(int index) const;
  ::loc::parkingSlots* add_parkingslot();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots >&
      parkingslot() const;

  // repeated .loc.laneLines LaneLine = 3;
  int laneline_size() const;
  private:
  int _internal_laneline_size() const;
  public:
  void clear_laneline();
  ::loc::laneLines* mutable_laneline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::laneLines >*
      mutable_laneline();
  private:
  const ::loc::laneLines& _internal_laneline(int index) const;
  ::loc::laneLines* _internal_add_laneline();
  public:
  const ::loc::laneLines& laneline(int index) const;
  ::loc::laneLines* add_laneline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::laneLines >&
      laneline() const;

  // repeated .loc.stopLines StopLine = 4;
  int stopline_size() const;
  private:
  int _internal_stopline_size() const;
  public:
  void clear_stopline();
  ::loc::stopLines* mutable_stopline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::stopLines >*
      mutable_stopline();
  private:
  const ::loc::stopLines& _internal_stopline(int index) const;
  ::loc::stopLines* _internal_add_stopline();
  public:
  const ::loc::stopLines& stopline(int index) const;
  ::loc::stopLines* add_stopline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::stopLines >&
      stopline() const;

  // repeated .loc.bumps Bump = 5;
  int bump_size() const;
  private:
  int _internal_bump_size() const;
  public:
  void clear_bump();
  ::loc::bumps* mutable_bump(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::bumps >*
      mutable_bump();
  private:
  const ::loc::bumps& _internal_bump(int index) const;
  ::loc::bumps* _internal_add_bump();
  public:
  const ::loc::bumps& bump(int index) const;
  ::loc::bumps* add_bump();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::bumps >&
      bump() const;

  // repeated .loc.crossWalks CrossWalk = 6;
  int crosswalk_size() const;
  private:
  int _internal_crosswalk_size() const;
  public:
  void clear_crosswalk();
  ::loc::crossWalks* mutable_crosswalk(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::crossWalks >*
      mutable_crosswalk();
  private:
  const ::loc::crossWalks& _internal_crosswalk(int index) const;
  ::loc::crossWalks* _internal_add_crosswalk();
  public:
  const ::loc::crossWalks& crosswalk(int index) const;
  ::loc::crossWalks* add_crosswalk();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::crossWalks >&
      crosswalk() const;

  // repeated .loc.arrows Arrow = 7;
  int arrow_size() const;
  private:
  int _internal_arrow_size() const;
  public:
  void clear_arrow();
  ::loc::arrows* mutable_arrow(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::arrows >*
      mutable_arrow();
  private:
  const ::loc::arrows& _internal_arrow(int index) const;
  ::loc::arrows* _internal_add_arrow();
  public:
  const ::loc::arrows& arrow(int index) const;
  ::loc::arrows* add_arrow();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::arrows >&
      arrow() const;

  // repeated .loc.parkingSlots parkingSlotsOptimize = 8;
  int parkingslotsoptimize_size() const;
  private:
  int _internal_parkingslotsoptimize_size() const;
  public:
  void clear_parkingslotsoptimize();
  ::loc::parkingSlots* mutable_parkingslotsoptimize(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots >*
      mutable_parkingslotsoptimize();
  private:
  const ::loc::parkingSlots& _internal_parkingslotsoptimize(int index) const;
  ::loc::parkingSlots* _internal_add_parkingslotsoptimize();
  public:
  const ::loc::parkingSlots& parkingslotsoptimize(int index) const;
  ::loc::parkingSlots* add_parkingslotsoptimize();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots >&
      parkingslotsoptimize() const;

  // optional uint64 timeStamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // optional uint64 mapId = 9;
  bool has_mapid() const;
  private:
  bool _internal_has_mapid() const;
  public:
  void clear_mapid();
  uint64_t mapid() const;
  void set_mapid(uint64_t value);
  private:
  uint64_t _internal_mapid() const;
  void _internal_set_mapid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loc.MapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots > parkingslot_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::laneLines > laneline_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::stopLines > stopline_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::bumps > bump_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::crossWalks > crosswalk_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::arrows > arrow_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots > parkingslotsoptimize_;
  uint64_t timestamp_;
  uint64_t mapid_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class LocStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.LocStatus) */ {
 public:
  inline LocStatus() : LocStatus(nullptr) {}
  ~LocStatus() override;
  explicit constexpr LocStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocStatus(const LocStatus& from);
  LocStatus(LocStatus&& from) noexcept
    : LocStatus() {
    *this = ::std::move(from);
  }

  inline LocStatus& operator=(const LocStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocStatus& operator=(LocStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocStatus* internal_default_instance() {
    return reinterpret_cast<const LocStatus*>(
               &_LocStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LocStatus& a, LocStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LocStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.LocStatus";
  }
  protected:
  explicit LocStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocstatusFieldNumber = 1,
  };
  // optional .loc.LocStatusType locstatus = 1;
  bool has_locstatus() const;
  private:
  bool _internal_has_locstatus() const;
  public:
  void clear_locstatus();
  ::loc::LocStatusType locstatus() const;
  void set_locstatus(::loc::LocStatusType value);
  private:
  ::loc::LocStatusType _internal_locstatus() const;
  void _internal_set_locstatus(::loc::LocStatusType value);
  public:

  // @@protoc_insertion_point(class_scope:loc.LocStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int locstatus_;
  friend struct ::TableStruct_loc_2eproto;
};
// -------------------------------------------------------------------

class padRealTimeLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:loc.padRealTimeLocation) */ {
 public:
  inline padRealTimeLocation() : padRealTimeLocation(nullptr) {}
  ~padRealTimeLocation() override;
  explicit constexpr padRealTimeLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  padRealTimeLocation(const padRealTimeLocation& from);
  padRealTimeLocation(padRealTimeLocation&& from) noexcept
    : padRealTimeLocation() {
    *this = ::std::move(from);
  }

  inline padRealTimeLocation& operator=(const padRealTimeLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline padRealTimeLocation& operator=(padRealTimeLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const padRealTimeLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const padRealTimeLocation* internal_default_instance() {
    return reinterpret_cast<const padRealTimeLocation*>(
               &_padRealTimeLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(padRealTimeLocation& a, padRealTimeLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(padRealTimeLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(padRealTimeLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  padRealTimeLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<padRealTimeLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const padRealTimeLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const padRealTimeLocation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(padRealTimeLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "loc.padRealTimeLocation";
  }
  protected:
  explicit padRealTimeLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehLocationFieldNumber = 6,
    kLocCorrectionFieldNumber = 7,
    kLocWorkingStatusFieldNumber = 1,
    kFlagSlotWidthUpdateFieldNumber = 2,
    kUpdatedSlotWidthFieldNumber = 3,
    kFlagSlotDepthUpdateFieldNumber = 4,
    kUpdatedSlotDepthFieldNumber = 5,
    kReserveFieldNumber = 9,
    kTimeStampFieldNumber = 8,
  };
  // optional .loc.VehiclePos vehLocation = 6;
  bool has_vehlocation() const;
  private:
  bool _internal_has_vehlocation() const;
  public:
  void clear_vehlocation();
  const ::loc::VehiclePos& vehlocation() const;
  PROTOBUF_NODISCARD ::loc::VehiclePos* release_vehlocation();
  ::loc::VehiclePos* mutable_vehlocation();
  void set_allocated_vehlocation(::loc::VehiclePos* vehlocation);
  private:
  const ::loc::VehiclePos& _internal_vehlocation() const;
  ::loc::VehiclePos* _internal_mutable_vehlocation();
  public:
  void unsafe_arena_set_allocated_vehlocation(
      ::loc::VehiclePos* vehlocation);
  ::loc::VehiclePos* unsafe_arena_release_vehlocation();

  // optional .loc.VehiclePos locCorrection = 7;
  bool has_loccorrection() const;
  private:
  bool _internal_has_loccorrection() const;
  public:
  void clear_loccorrection();
  const ::loc::VehiclePos& loccorrection() const;
  PROTOBUF_NODISCARD ::loc::VehiclePos* release_loccorrection();
  ::loc::VehiclePos* mutable_loccorrection();
  void set_allocated_loccorrection(::loc::VehiclePos* loccorrection);
  private:
  const ::loc::VehiclePos& _internal_loccorrection() const;
  ::loc::VehiclePos* _internal_mutable_loccorrection();
  public:
  void unsafe_arena_set_allocated_loccorrection(
      ::loc::VehiclePos* loccorrection);
  ::loc::VehiclePos* unsafe_arena_release_loccorrection();

  // optional .loc.LocStatusType LocWorkingStatus = 1;
  bool has_locworkingstatus() const;
  private:
  bool _internal_has_locworkingstatus() const;
  public:
  void clear_locworkingstatus();
  ::loc::LocStatusType locworkingstatus() const;
  void set_locworkingstatus(::loc::LocStatusType value);
  private:
  ::loc::LocStatusType _internal_locworkingstatus() const;
  void _internal_set_locworkingstatus(::loc::LocStatusType value);
  public:

  // optional uint32 flag_SlotWidthUpdate = 2;
  bool has_flag_slotwidthupdate() const;
  private:
  bool _internal_has_flag_slotwidthupdate() const;
  public:
  void clear_flag_slotwidthupdate();
  uint32_t flag_slotwidthupdate() const;
  void set_flag_slotwidthupdate(uint32_t value);
  private:
  uint32_t _internal_flag_slotwidthupdate() const;
  void _internal_set_flag_slotwidthupdate(uint32_t value);
  public:

  // optional uint32 updatedSlotWidth = 3;
  bool has_updatedslotwidth() const;
  private:
  bool _internal_has_updatedslotwidth() const;
  public:
  void clear_updatedslotwidth();
  uint32_t updatedslotwidth() const;
  void set_updatedslotwidth(uint32_t value);
  private:
  uint32_t _internal_updatedslotwidth() const;
  void _internal_set_updatedslotwidth(uint32_t value);
  public:

  // optional uint32 flag_SlotDepthUpdate = 4;
  bool has_flag_slotdepthupdate() const;
  private:
  bool _internal_has_flag_slotdepthupdate() const;
  public:
  void clear_flag_slotdepthupdate();
  uint32_t flag_slotdepthupdate() const;
  void set_flag_slotdepthupdate(uint32_t value);
  private:
  uint32_t _internal_flag_slotdepthupdate() const;
  void _internal_set_flag_slotdepthupdate(uint32_t value);
  public:

  // optional uint32 updatedSlotDepth = 5;
  bool has_updatedslotdepth() const;
  private:
  bool _internal_has_updatedslotdepth() const;
  public:
  void clear_updatedslotdepth();
  uint32_t updatedslotdepth() const;
  void set_updatedslotdepth(uint32_t value);
  private:
  uint32_t _internal_updatedslotdepth() const;
  void _internal_set_updatedslotdepth(uint32_t value);
  public:

  // optional uint32 reserve = 9;
  bool has_reserve() const;
  private:
  bool _internal_has_reserve() const;
  public:
  void clear_reserve();
  uint32_t reserve() const;
  void set_reserve(uint32_t value);
  private:
  uint32_t _internal_reserve() const;
  void _internal_set_reserve(uint32_t value);
  public:

  // optional uint64 timeStamp = 8;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:loc.padRealTimeLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::loc::VehiclePos* vehlocation_;
  ::loc::VehiclePos* loccorrection_;
  int locworkingstatus_;
  uint32_t flag_slotwidthupdate_;
  uint32_t updatedslotwidth_;
  uint32_t flag_slotdepthupdate_;
  uint32_t updatedslotdepth_;
  uint32_t reserve_;
  uint64_t timestamp_;
  friend struct ::TableStruct_loc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point3D

// optional double x = 1;
inline bool Point3D::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Point3D::has_x() const {
  return _internal_has_x();
}
inline void Point3D::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Point3D::_internal_x() const {
  return x_;
}
inline double Point3D::x() const {
  // @@protoc_insertion_point(field_get:loc.Point3D.x)
  return _internal_x();
}
inline void Point3D::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Point3D::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:loc.Point3D.x)
}

// optional double y = 2;
inline bool Point3D::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Point3D::has_y() const {
  return _internal_has_y();
}
inline void Point3D::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Point3D::_internal_y() const {
  return y_;
}
inline double Point3D::y() const {
  // @@protoc_insertion_point(field_get:loc.Point3D.y)
  return _internal_y();
}
inline void Point3D::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Point3D::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:loc.Point3D.y)
}

// optional double z = 3;
inline bool Point3D::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Point3D::has_z() const {
  return _internal_has_z();
}
inline void Point3D::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Point3D::_internal_z() const {
  return z_;
}
inline double Point3D::z() const {
  // @@protoc_insertion_point(field_get:loc.Point3D.z)
  return _internal_z();
}
inline void Point3D::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void Point3D::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:loc.Point3D.z)
}

// -------------------------------------------------------------------

// padPoint

// optional int32 x = 1;
inline bool padPoint::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool padPoint::has_x() const {
  return _internal_has_x();
}
inline void padPoint::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t padPoint::_internal_x() const {
  return x_;
}
inline int32_t padPoint::x() const {
  // @@protoc_insertion_point(field_get:loc.padPoint.x)
  return _internal_x();
}
inline void padPoint::_internal_set_x(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void padPoint::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:loc.padPoint.x)
}

// optional int32 y = 2;
inline bool padPoint::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool padPoint::has_y() const {
  return _internal_has_y();
}
inline void padPoint::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t padPoint::_internal_y() const {
  return y_;
}
inline int32_t padPoint::y() const {
  // @@protoc_insertion_point(field_get:loc.padPoint.y)
  return _internal_y();
}
inline void padPoint::_internal_set_y(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void padPoint::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:loc.padPoint.y)
}

// -------------------------------------------------------------------

// padVehiclePose

// optional .loc.padPoint coord = 1;
inline bool padVehiclePose::_internal_has_coord() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || coord_ != nullptr);
  return value;
}
inline bool padVehiclePose::has_coord() const {
  return _internal_has_coord();
}
inline void padVehiclePose::clear_coord() {
  if (coord_ != nullptr) coord_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::loc::padPoint& padVehiclePose::_internal_coord() const {
  const ::loc::padPoint* p = coord_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::padPoint&>(
      ::loc::_padPoint_default_instance_);
}
inline const ::loc::padPoint& padVehiclePose::coord() const {
  // @@protoc_insertion_point(field_get:loc.padVehiclePose.coord)
  return _internal_coord();
}
inline void padVehiclePose::unsafe_arena_set_allocated_coord(
    ::loc::padPoint* coord) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coord_);
  }
  coord_ = coord;
  if (coord) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.padVehiclePose.coord)
}
inline ::loc::padPoint* padVehiclePose::release_coord() {
  _has_bits_[0] &= ~0x00000001u;
  ::loc::padPoint* temp = coord_;
  coord_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::padPoint* padVehiclePose::unsafe_arena_release_coord() {
  // @@protoc_insertion_point(field_release:loc.padVehiclePose.coord)
  _has_bits_[0] &= ~0x00000001u;
  ::loc::padPoint* temp = coord_;
  coord_ = nullptr;
  return temp;
}
inline ::loc::padPoint* padVehiclePose::_internal_mutable_coord() {
  _has_bits_[0] |= 0x00000001u;
  if (coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::padPoint>(GetArenaForAllocation());
    coord_ = p;
  }
  return coord_;
}
inline ::loc::padPoint* padVehiclePose::mutable_coord() {
  ::loc::padPoint* _msg = _internal_mutable_coord();
  // @@protoc_insertion_point(field_mutable:loc.padVehiclePose.coord)
  return _msg;
}
inline void padVehiclePose::set_allocated_coord(::loc::padPoint* coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete coord_;
  }
  if (coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::padPoint>::GetOwningArena(coord);
    if (message_arena != submessage_arena) {
      coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coord, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  coord_ = coord;
  // @@protoc_insertion_point(field_set_allocated:loc.padVehiclePose.coord)
}

// optional float yaw = 2;
inline bool padVehiclePose::_internal_has_yaw() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool padVehiclePose::has_yaw() const {
  return _internal_has_yaw();
}
inline void padVehiclePose::clear_yaw() {
  yaw_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float padVehiclePose::_internal_yaw() const {
  return yaw_;
}
inline float padVehiclePose::yaw() const {
  // @@protoc_insertion_point(field_get:loc.padVehiclePose.yaw)
  return _internal_yaw();
}
inline void padVehiclePose::_internal_set_yaw(float value) {
  _has_bits_[0] |= 0x00000002u;
  yaw_ = value;
}
inline void padVehiclePose::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:loc.padVehiclePose.yaw)
}

// optional uint32 status = 3;
inline bool padVehiclePose::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool padVehiclePose::has_status() const {
  return _internal_has_status();
}
inline void padVehiclePose::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t padVehiclePose::_internal_status() const {
  return status_;
}
inline uint32_t padVehiclePose::status() const {
  // @@protoc_insertion_point(field_get:loc.padVehiclePose.status)
  return _internal_status();
}
inline void padVehiclePose::_internal_set_status(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void padVehiclePose::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:loc.padVehiclePose.status)
}

// optional uint64 timeStamp = 4;
inline bool padVehiclePose::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool padVehiclePose::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void padVehiclePose::clear_timestamp() {
  timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t padVehiclePose::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t padVehiclePose::timestamp() const {
  // @@protoc_insertion_point(field_get:loc.padVehiclePose.timeStamp)
  return _internal_timestamp();
}
inline void padVehiclePose::_internal_set_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  timestamp_ = value;
}
inline void padVehiclePose::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:loc.padVehiclePose.timeStamp)
}

// -------------------------------------------------------------------

// VehiclePos

// optional float x = 1;
inline bool VehiclePos::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VehiclePos::has_x() const {
  return _internal_has_x();
}
inline void VehiclePos::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float VehiclePos::_internal_x() const {
  return x_;
}
inline float VehiclePos::x() const {
  // @@protoc_insertion_point(field_get:loc.VehiclePos.x)
  return _internal_x();
}
inline void VehiclePos::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void VehiclePos::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:loc.VehiclePos.x)
}

// optional float y = 2;
inline bool VehiclePos::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VehiclePos::has_y() const {
  return _internal_has_y();
}
inline void VehiclePos::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float VehiclePos::_internal_y() const {
  return y_;
}
inline float VehiclePos::y() const {
  // @@protoc_insertion_point(field_get:loc.VehiclePos.y)
  return _internal_y();
}
inline void VehiclePos::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void VehiclePos::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:loc.VehiclePos.y)
}

// optional float yaw = 3;
inline bool VehiclePos::_internal_has_yaw() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VehiclePos::has_yaw() const {
  return _internal_has_yaw();
}
inline void VehiclePos::clear_yaw() {
  yaw_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float VehiclePos::_internal_yaw() const {
  return yaw_;
}
inline float VehiclePos::yaw() const {
  // @@protoc_insertion_point(field_get:loc.VehiclePos.yaw)
  return _internal_yaw();
}
inline void VehiclePos::_internal_set_yaw(float value) {
  _has_bits_[0] |= 0x00000004u;
  yaw_ = value;
}
inline void VehiclePos::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:loc.VehiclePos.yaw)
}

// -------------------------------------------------------------------

// App2emap_DR

// optional float x = 1;
inline bool App2emap_DR::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool App2emap_DR::has_x() const {
  return _internal_has_x();
}
inline void App2emap_DR::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float App2emap_DR::_internal_x() const {
  return x_;
}
inline float App2emap_DR::x() const {
  // @@protoc_insertion_point(field_get:loc.App2emap_DR.x)
  return _internal_x();
}
inline void App2emap_DR::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void App2emap_DR::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:loc.App2emap_DR.x)
}

// optional float y = 2;
inline bool App2emap_DR::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool App2emap_DR::has_y() const {
  return _internal_has_y();
}
inline void App2emap_DR::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float App2emap_DR::_internal_y() const {
  return y_;
}
inline float App2emap_DR::y() const {
  // @@protoc_insertion_point(field_get:loc.App2emap_DR.y)
  return _internal_y();
}
inline void App2emap_DR::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void App2emap_DR::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:loc.App2emap_DR.y)
}

// optional float canAng = 3;
inline bool App2emap_DR::_internal_has_canang() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool App2emap_DR::has_canang() const {
  return _internal_has_canang();
}
inline void App2emap_DR::clear_canang() {
  canang_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float App2emap_DR::_internal_canang() const {
  return canang_;
}
inline float App2emap_DR::canang() const {
  // @@protoc_insertion_point(field_get:loc.App2emap_DR.canAng)
  return _internal_canang();
}
inline void App2emap_DR::_internal_set_canang(float value) {
  _has_bits_[0] |= 0x00000004u;
  canang_ = value;
}
inline void App2emap_DR::set_canang(float value) {
  _internal_set_canang(value);
  // @@protoc_insertion_point(field_set:loc.App2emap_DR.canAng)
}

// optional uint32 DRStatus = 4;
inline bool App2emap_DR::_internal_has_drstatus() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool App2emap_DR::has_drstatus() const {
  return _internal_has_drstatus();
}
inline void App2emap_DR::clear_drstatus() {
  drstatus_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t App2emap_DR::_internal_drstatus() const {
  return drstatus_;
}
inline uint32_t App2emap_DR::drstatus() const {
  // @@protoc_insertion_point(field_get:loc.App2emap_DR.DRStatus)
  return _internal_drstatus();
}
inline void App2emap_DR::_internal_set_drstatus(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  drstatus_ = value;
}
inline void App2emap_DR::set_drstatus(uint32_t value) {
  _internal_set_drstatus(value);
  // @@protoc_insertion_point(field_set:loc.App2emap_DR.DRStatus)
}

// optional uint64 timeStamp = 5;
inline bool App2emap_DR::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool App2emap_DR::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void App2emap_DR::clear_timestamp() {
  timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t App2emap_DR::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t App2emap_DR::timestamp() const {
  // @@protoc_insertion_point(field_get:loc.App2emap_DR.timeStamp)
  return _internal_timestamp();
}
inline void App2emap_DR::_internal_set_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  timestamp_ = value;
}
inline void App2emap_DR::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:loc.App2emap_DR.timeStamp)
}

// -------------------------------------------------------------------

// parkingSlots

// optional uint64 id = 1;
inline bool parkingSlots::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool parkingSlots::has_id() const {
  return _internal_has_id();
}
inline void parkingSlots::clear_id() {
  id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t parkingSlots::_internal_id() const {
  return id_;
}
inline uint64_t parkingSlots::id() const {
  // @@protoc_insertion_point(field_get:loc.parkingSlots.id)
  return _internal_id();
}
inline void parkingSlots::_internal_set_id(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  id_ = value;
}
inline void parkingSlots::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:loc.parkingSlots.id)
}

// optional uint32 psType = 2;
inline bool parkingSlots::_internal_has_pstype() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool parkingSlots::has_pstype() const {
  return _internal_has_pstype();
}
inline void parkingSlots::clear_pstype() {
  pstype_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t parkingSlots::_internal_pstype() const {
  return pstype_;
}
inline uint32_t parkingSlots::pstype() const {
  // @@protoc_insertion_point(field_get:loc.parkingSlots.psType)
  return _internal_pstype();
}
inline void parkingSlots::_internal_set_pstype(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  pstype_ = value;
}
inline void parkingSlots::set_pstype(uint32_t value) {
  _internal_set_pstype(value);
  // @@protoc_insertion_point(field_set:loc.parkingSlots.psType)
}

// optional double width = 3;
inline bool parkingSlots::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool parkingSlots::has_width() const {
  return _internal_has_width();
}
inline void parkingSlots::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double parkingSlots::_internal_width() const {
  return width_;
}
inline double parkingSlots::width() const {
  // @@protoc_insertion_point(field_get:loc.parkingSlots.width)
  return _internal_width();
}
inline void parkingSlots::_internal_set_width(double value) {
  _has_bits_[0] |= 0x00000010u;
  width_ = value;
}
inline void parkingSlots::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:loc.parkingSlots.width)
}

// optional double length = 4;
inline bool parkingSlots::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool parkingSlots::has_length() const {
  return _internal_has_length();
}
inline void parkingSlots::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double parkingSlots::_internal_length() const {
  return length_;
}
inline double parkingSlots::length() const {
  // @@protoc_insertion_point(field_get:loc.parkingSlots.length)
  return _internal_length();
}
inline void parkingSlots::_internal_set_length(double value) {
  _has_bits_[0] |= 0x00000020u;
  length_ = value;
}
inline void parkingSlots::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:loc.parkingSlots.length)
}

// optional .loc.Point3D center = 5;
inline bool parkingSlots::_internal_has_center() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || center_ != nullptr);
  return value;
}
inline bool parkingSlots::has_center() const {
  return _internal_has_center();
}
inline void parkingSlots::clear_center() {
  if (center_ != nullptr) center_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::loc::Point3D& parkingSlots::_internal_center() const {
  const ::loc::Point3D* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& parkingSlots::center() const {
  // @@protoc_insertion_point(field_get:loc.parkingSlots.center)
  return _internal_center();
}
inline void parkingSlots::unsafe_arena_set_allocated_center(
    ::loc::Point3D* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.parkingSlots.center)
}
inline ::loc::Point3D* parkingSlots::release_center() {
  _has_bits_[0] &= ~0x00000001u;
  ::loc::Point3D* temp = center_;
  center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* parkingSlots::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:loc.parkingSlots.center)
  _has_bits_[0] &= ~0x00000001u;
  ::loc::Point3D* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::loc::Point3D* parkingSlots::_internal_mutable_center() {
  _has_bits_[0] |= 0x00000001u;
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    center_ = p;
  }
  return center_;
}
inline ::loc::Point3D* parkingSlots::mutable_center() {
  ::loc::Point3D* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:loc.parkingSlots.center)
  return _msg;
}
inline void parkingSlots::set_allocated_center(::loc::Point3D* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:loc.parkingSlots.center)
}

// optional .loc.Point3D wideDirection = 6;
inline bool parkingSlots::_internal_has_widedirection() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || widedirection_ != nullptr);
  return value;
}
inline bool parkingSlots::has_widedirection() const {
  return _internal_has_widedirection();
}
inline void parkingSlots::clear_widedirection() {
  if (widedirection_ != nullptr) widedirection_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::loc::Point3D& parkingSlots::_internal_widedirection() const {
  const ::loc::Point3D* p = widedirection_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& parkingSlots::widedirection() const {
  // @@protoc_insertion_point(field_get:loc.parkingSlots.wideDirection)
  return _internal_widedirection();
}
inline void parkingSlots::unsafe_arena_set_allocated_widedirection(
    ::loc::Point3D* widedirection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(widedirection_);
  }
  widedirection_ = widedirection;
  if (widedirection) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.parkingSlots.wideDirection)
}
inline ::loc::Point3D* parkingSlots::release_widedirection() {
  _has_bits_[0] &= ~0x00000002u;
  ::loc::Point3D* temp = widedirection_;
  widedirection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* parkingSlots::unsafe_arena_release_widedirection() {
  // @@protoc_insertion_point(field_release:loc.parkingSlots.wideDirection)
  _has_bits_[0] &= ~0x00000002u;
  ::loc::Point3D* temp = widedirection_;
  widedirection_ = nullptr;
  return temp;
}
inline ::loc::Point3D* parkingSlots::_internal_mutable_widedirection() {
  _has_bits_[0] |= 0x00000002u;
  if (widedirection_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    widedirection_ = p;
  }
  return widedirection_;
}
inline ::loc::Point3D* parkingSlots::mutable_widedirection() {
  ::loc::Point3D* _msg = _internal_mutable_widedirection();
  // @@protoc_insertion_point(field_mutable:loc.parkingSlots.wideDirection)
  return _msg;
}
inline void parkingSlots::set_allocated_widedirection(::loc::Point3D* widedirection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete widedirection_;
  }
  if (widedirection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(widedirection);
    if (message_arena != submessage_arena) {
      widedirection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, widedirection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  widedirection_ = widedirection;
  // @@protoc_insertion_point(field_set_allocated:loc.parkingSlots.wideDirection)
}

// optional .loc.Point3D longDirection = 7;
inline bool parkingSlots::_internal_has_longdirection() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || longdirection_ != nullptr);
  return value;
}
inline bool parkingSlots::has_longdirection() const {
  return _internal_has_longdirection();
}
inline void parkingSlots::clear_longdirection() {
  if (longdirection_ != nullptr) longdirection_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::loc::Point3D& parkingSlots::_internal_longdirection() const {
  const ::loc::Point3D* p = longdirection_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& parkingSlots::longdirection() const {
  // @@protoc_insertion_point(field_get:loc.parkingSlots.longDirection)
  return _internal_longdirection();
}
inline void parkingSlots::unsafe_arena_set_allocated_longdirection(
    ::loc::Point3D* longdirection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(longdirection_);
  }
  longdirection_ = longdirection;
  if (longdirection) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.parkingSlots.longDirection)
}
inline ::loc::Point3D* parkingSlots::release_longdirection() {
  _has_bits_[0] &= ~0x00000004u;
  ::loc::Point3D* temp = longdirection_;
  longdirection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* parkingSlots::unsafe_arena_release_longdirection() {
  // @@protoc_insertion_point(field_release:loc.parkingSlots.longDirection)
  _has_bits_[0] &= ~0x00000004u;
  ::loc::Point3D* temp = longdirection_;
  longdirection_ = nullptr;
  return temp;
}
inline ::loc::Point3D* parkingSlots::_internal_mutable_longdirection() {
  _has_bits_[0] |= 0x00000004u;
  if (longdirection_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    longdirection_ = p;
  }
  return longdirection_;
}
inline ::loc::Point3D* parkingSlots::mutable_longdirection() {
  ::loc::Point3D* _msg = _internal_mutable_longdirection();
  // @@protoc_insertion_point(field_mutable:loc.parkingSlots.longDirection)
  return _msg;
}
inline void parkingSlots::set_allocated_longdirection(::loc::Point3D* longdirection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete longdirection_;
  }
  if (longdirection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(longdirection);
    if (message_arena != submessage_arena) {
      longdirection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longdirection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  longdirection_ = longdirection;
  // @@protoc_insertion_point(field_set_allocated:loc.parkingSlots.longDirection)
}

// optional bool isOccupancy = 8;
inline bool parkingSlots::_internal_has_isoccupancy() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool parkingSlots::has_isoccupancy() const {
  return _internal_has_isoccupancy();
}
inline void parkingSlots::clear_isoccupancy() {
  isoccupancy_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool parkingSlots::_internal_isoccupancy() const {
  return isoccupancy_;
}
inline bool parkingSlots::isoccupancy() const {
  // @@protoc_insertion_point(field_get:loc.parkingSlots.isOccupancy)
  return _internal_isoccupancy();
}
inline void parkingSlots::_internal_set_isoccupancy(bool value) {
  _has_bits_[0] |= 0x00000080u;
  isoccupancy_ = value;
}
inline void parkingSlots::set_isoccupancy(bool value) {
  _internal_set_isoccupancy(value);
  // @@protoc_insertion_point(field_set:loc.parkingSlots.isOccupancy)
}

// -------------------------------------------------------------------

// laneLines

// optional uint32 lineType = 1;
inline bool laneLines::_internal_has_linetype() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool laneLines::has_linetype() const {
  return _internal_has_linetype();
}
inline void laneLines::clear_linetype() {
  linetype_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t laneLines::_internal_linetype() const {
  return linetype_;
}
inline uint32_t laneLines::linetype() const {
  // @@protoc_insertion_point(field_get:loc.laneLines.lineType)
  return _internal_linetype();
}
inline void laneLines::_internal_set_linetype(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  linetype_ = value;
}
inline void laneLines::set_linetype(uint32_t value) {
  _internal_set_linetype(value);
  // @@protoc_insertion_point(field_set:loc.laneLines.lineType)
}

// repeated .loc.Point3D points = 2;
inline int laneLines::_internal_points_size() const {
  return points_.size();
}
inline int laneLines::points_size() const {
  return _internal_points_size();
}
inline void laneLines::clear_points() {
  points_.Clear();
}
inline ::loc::Point3D* laneLines::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:loc.laneLines.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D >*
laneLines::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:loc.laneLines.points)
  return &points_;
}
inline const ::loc::Point3D& laneLines::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::loc::Point3D& laneLines::points(int index) const {
  // @@protoc_insertion_point(field_get:loc.laneLines.points)
  return _internal_points(index);
}
inline ::loc::Point3D* laneLines::_internal_add_points() {
  return points_.Add();
}
inline ::loc::Point3D* laneLines::add_points() {
  ::loc::Point3D* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:loc.laneLines.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D >&
laneLines::points() const {
  // @@protoc_insertion_point(field_list:loc.laneLines.points)
  return points_;
}

// -------------------------------------------------------------------

// stopLines

// optional uint64 id = 1;
inline bool stopLines::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool stopLines::has_id() const {
  return _internal_has_id();
}
inline void stopLines::clear_id() {
  id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t stopLines::_internal_id() const {
  return id_;
}
inline uint64_t stopLines::id() const {
  // @@protoc_insertion_point(field_get:loc.stopLines.id)
  return _internal_id();
}
inline void stopLines::_internal_set_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
}
inline void stopLines::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:loc.stopLines.id)
}

// optional .loc.Point3D startPt = 2;
inline bool stopLines::_internal_has_startpt() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || startpt_ != nullptr);
  return value;
}
inline bool stopLines::has_startpt() const {
  return _internal_has_startpt();
}
inline void stopLines::clear_startpt() {
  if (startpt_ != nullptr) startpt_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::loc::Point3D& stopLines::_internal_startpt() const {
  const ::loc::Point3D* p = startpt_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& stopLines::startpt() const {
  // @@protoc_insertion_point(field_get:loc.stopLines.startPt)
  return _internal_startpt();
}
inline void stopLines::unsafe_arena_set_allocated_startpt(
    ::loc::Point3D* startpt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(startpt_);
  }
  startpt_ = startpt;
  if (startpt) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.stopLines.startPt)
}
inline ::loc::Point3D* stopLines::release_startpt() {
  _has_bits_[0] &= ~0x00000001u;
  ::loc::Point3D* temp = startpt_;
  startpt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* stopLines::unsafe_arena_release_startpt() {
  // @@protoc_insertion_point(field_release:loc.stopLines.startPt)
  _has_bits_[0] &= ~0x00000001u;
  ::loc::Point3D* temp = startpt_;
  startpt_ = nullptr;
  return temp;
}
inline ::loc::Point3D* stopLines::_internal_mutable_startpt() {
  _has_bits_[0] |= 0x00000001u;
  if (startpt_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    startpt_ = p;
  }
  return startpt_;
}
inline ::loc::Point3D* stopLines::mutable_startpt() {
  ::loc::Point3D* _msg = _internal_mutable_startpt();
  // @@protoc_insertion_point(field_mutable:loc.stopLines.startPt)
  return _msg;
}
inline void stopLines::set_allocated_startpt(::loc::Point3D* startpt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete startpt_;
  }
  if (startpt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(startpt);
    if (message_arena != submessage_arena) {
      startpt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startpt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  startpt_ = startpt;
  // @@protoc_insertion_point(field_set_allocated:loc.stopLines.startPt)
}

// optional .loc.Point3D endPt = 3;
inline bool stopLines::_internal_has_endpt() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || endpt_ != nullptr);
  return value;
}
inline bool stopLines::has_endpt() const {
  return _internal_has_endpt();
}
inline void stopLines::clear_endpt() {
  if (endpt_ != nullptr) endpt_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::loc::Point3D& stopLines::_internal_endpt() const {
  const ::loc::Point3D* p = endpt_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& stopLines::endpt() const {
  // @@protoc_insertion_point(field_get:loc.stopLines.endPt)
  return _internal_endpt();
}
inline void stopLines::unsafe_arena_set_allocated_endpt(
    ::loc::Point3D* endpt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpt_);
  }
  endpt_ = endpt;
  if (endpt) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.stopLines.endPt)
}
inline ::loc::Point3D* stopLines::release_endpt() {
  _has_bits_[0] &= ~0x00000002u;
  ::loc::Point3D* temp = endpt_;
  endpt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* stopLines::unsafe_arena_release_endpt() {
  // @@protoc_insertion_point(field_release:loc.stopLines.endPt)
  _has_bits_[0] &= ~0x00000002u;
  ::loc::Point3D* temp = endpt_;
  endpt_ = nullptr;
  return temp;
}
inline ::loc::Point3D* stopLines::_internal_mutable_endpt() {
  _has_bits_[0] |= 0x00000002u;
  if (endpt_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    endpt_ = p;
  }
  return endpt_;
}
inline ::loc::Point3D* stopLines::mutable_endpt() {
  ::loc::Point3D* _msg = _internal_mutable_endpt();
  // @@protoc_insertion_point(field_mutable:loc.stopLines.endPt)
  return _msg;
}
inline void stopLines::set_allocated_endpt(::loc::Point3D* endpt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endpt_;
  }
  if (endpt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(endpt);
    if (message_arena != submessage_arena) {
      endpt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  endpt_ = endpt;
  // @@protoc_insertion_point(field_set_allocated:loc.stopLines.endPt)
}

// -------------------------------------------------------------------

// bumps

// optional uint64 id = 1;
inline bool bumps::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool bumps::has_id() const {
  return _internal_has_id();
}
inline void bumps::clear_id() {
  id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t bumps::_internal_id() const {
  return id_;
}
inline uint64_t bumps::id() const {
  // @@protoc_insertion_point(field_get:loc.bumps.id)
  return _internal_id();
}
inline void bumps::_internal_set_id(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  id_ = value;
}
inline void bumps::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:loc.bumps.id)
}

// optional double halfWidth = 2;
inline bool bumps::_internal_has_halfwidth() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool bumps::has_halfwidth() const {
  return _internal_has_halfwidth();
}
inline void bumps::clear_halfwidth() {
  halfwidth_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double bumps::_internal_halfwidth() const {
  return halfwidth_;
}
inline double bumps::halfwidth() const {
  // @@protoc_insertion_point(field_get:loc.bumps.halfWidth)
  return _internal_halfwidth();
}
inline void bumps::_internal_set_halfwidth(double value) {
  _has_bits_[0] |= 0x00000010u;
  halfwidth_ = value;
}
inline void bumps::set_halfwidth(double value) {
  _internal_set_halfwidth(value);
  // @@protoc_insertion_point(field_set:loc.bumps.halfWidth)
}

// optional double length = 3;
inline bool bumps::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool bumps::has_length() const {
  return _internal_has_length();
}
inline void bumps::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double bumps::_internal_length() const {
  return length_;
}
inline double bumps::length() const {
  // @@protoc_insertion_point(field_get:loc.bumps.length)
  return _internal_length();
}
inline void bumps::_internal_set_length(double value) {
  _has_bits_[0] |= 0x00000020u;
  length_ = value;
}
inline void bumps::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:loc.bumps.length)
}

// optional .loc.Point3D endPt = 4;
inline bool bumps::_internal_has_endpt() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || endpt_ != nullptr);
  return value;
}
inline bool bumps::has_endpt() const {
  return _internal_has_endpt();
}
inline void bumps::clear_endpt() {
  if (endpt_ != nullptr) endpt_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::loc::Point3D& bumps::_internal_endpt() const {
  const ::loc::Point3D* p = endpt_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& bumps::endpt() const {
  // @@protoc_insertion_point(field_get:loc.bumps.endPt)
  return _internal_endpt();
}
inline void bumps::unsafe_arena_set_allocated_endpt(
    ::loc::Point3D* endpt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpt_);
  }
  endpt_ = endpt;
  if (endpt) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.bumps.endPt)
}
inline ::loc::Point3D* bumps::release_endpt() {
  _has_bits_[0] &= ~0x00000001u;
  ::loc::Point3D* temp = endpt_;
  endpt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* bumps::unsafe_arena_release_endpt() {
  // @@protoc_insertion_point(field_release:loc.bumps.endPt)
  _has_bits_[0] &= ~0x00000001u;
  ::loc::Point3D* temp = endpt_;
  endpt_ = nullptr;
  return temp;
}
inline ::loc::Point3D* bumps::_internal_mutable_endpt() {
  _has_bits_[0] |= 0x00000001u;
  if (endpt_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    endpt_ = p;
  }
  return endpt_;
}
inline ::loc::Point3D* bumps::mutable_endpt() {
  ::loc::Point3D* _msg = _internal_mutable_endpt();
  // @@protoc_insertion_point(field_mutable:loc.bumps.endPt)
  return _msg;
}
inline void bumps::set_allocated_endpt(::loc::Point3D* endpt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endpt_;
  }
  if (endpt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(endpt);
    if (message_arena != submessage_arena) {
      endpt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpt_ = endpt;
  // @@protoc_insertion_point(field_set_allocated:loc.bumps.endPt)
}

// optional .loc.Point3D wideDirection = 5;
inline bool bumps::_internal_has_widedirection() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || widedirection_ != nullptr);
  return value;
}
inline bool bumps::has_widedirection() const {
  return _internal_has_widedirection();
}
inline void bumps::clear_widedirection() {
  if (widedirection_ != nullptr) widedirection_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::loc::Point3D& bumps::_internal_widedirection() const {
  const ::loc::Point3D* p = widedirection_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& bumps::widedirection() const {
  // @@protoc_insertion_point(field_get:loc.bumps.wideDirection)
  return _internal_widedirection();
}
inline void bumps::unsafe_arena_set_allocated_widedirection(
    ::loc::Point3D* widedirection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(widedirection_);
  }
  widedirection_ = widedirection;
  if (widedirection) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.bumps.wideDirection)
}
inline ::loc::Point3D* bumps::release_widedirection() {
  _has_bits_[0] &= ~0x00000002u;
  ::loc::Point3D* temp = widedirection_;
  widedirection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* bumps::unsafe_arena_release_widedirection() {
  // @@protoc_insertion_point(field_release:loc.bumps.wideDirection)
  _has_bits_[0] &= ~0x00000002u;
  ::loc::Point3D* temp = widedirection_;
  widedirection_ = nullptr;
  return temp;
}
inline ::loc::Point3D* bumps::_internal_mutable_widedirection() {
  _has_bits_[0] |= 0x00000002u;
  if (widedirection_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    widedirection_ = p;
  }
  return widedirection_;
}
inline ::loc::Point3D* bumps::mutable_widedirection() {
  ::loc::Point3D* _msg = _internal_mutable_widedirection();
  // @@protoc_insertion_point(field_mutable:loc.bumps.wideDirection)
  return _msg;
}
inline void bumps::set_allocated_widedirection(::loc::Point3D* widedirection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete widedirection_;
  }
  if (widedirection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(widedirection);
    if (message_arena != submessage_arena) {
      widedirection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, widedirection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  widedirection_ = widedirection;
  // @@protoc_insertion_point(field_set_allocated:loc.bumps.wideDirection)
}

// optional .loc.Point3D longDirection = 6;
inline bool bumps::_internal_has_longdirection() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || longdirection_ != nullptr);
  return value;
}
inline bool bumps::has_longdirection() const {
  return _internal_has_longdirection();
}
inline void bumps::clear_longdirection() {
  if (longdirection_ != nullptr) longdirection_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::loc::Point3D& bumps::_internal_longdirection() const {
  const ::loc::Point3D* p = longdirection_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& bumps::longdirection() const {
  // @@protoc_insertion_point(field_get:loc.bumps.longDirection)
  return _internal_longdirection();
}
inline void bumps::unsafe_arena_set_allocated_longdirection(
    ::loc::Point3D* longdirection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(longdirection_);
  }
  longdirection_ = longdirection;
  if (longdirection) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.bumps.longDirection)
}
inline ::loc::Point3D* bumps::release_longdirection() {
  _has_bits_[0] &= ~0x00000004u;
  ::loc::Point3D* temp = longdirection_;
  longdirection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* bumps::unsafe_arena_release_longdirection() {
  // @@protoc_insertion_point(field_release:loc.bumps.longDirection)
  _has_bits_[0] &= ~0x00000004u;
  ::loc::Point3D* temp = longdirection_;
  longdirection_ = nullptr;
  return temp;
}
inline ::loc::Point3D* bumps::_internal_mutable_longdirection() {
  _has_bits_[0] |= 0x00000004u;
  if (longdirection_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    longdirection_ = p;
  }
  return longdirection_;
}
inline ::loc::Point3D* bumps::mutable_longdirection() {
  ::loc::Point3D* _msg = _internal_mutable_longdirection();
  // @@protoc_insertion_point(field_mutable:loc.bumps.longDirection)
  return _msg;
}
inline void bumps::set_allocated_longdirection(::loc::Point3D* longdirection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete longdirection_;
  }
  if (longdirection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(longdirection);
    if (message_arena != submessage_arena) {
      longdirection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longdirection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  longdirection_ = longdirection;
  // @@protoc_insertion_point(field_set_allocated:loc.bumps.longDirection)
}

// -------------------------------------------------------------------

// arrows

// optional uint64 id = 1;
inline bool arrows::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool arrows::has_id() const {
  return _internal_has_id();
}
inline void arrows::clear_id() {
  id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t arrows::_internal_id() const {
  return id_;
}
inline uint64_t arrows::id() const {
  // @@protoc_insertion_point(field_get:loc.arrows.id)
  return _internal_id();
}
inline void arrows::_internal_set_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void arrows::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:loc.arrows.id)
}

// repeated uint32 arrowType = 2;
inline int arrows::_internal_arrowtype_size() const {
  return arrowtype_.size();
}
inline int arrows::arrowtype_size() const {
  return _internal_arrowtype_size();
}
inline void arrows::clear_arrowtype() {
  arrowtype_.Clear();
}
inline uint32_t arrows::_internal_arrowtype(int index) const {
  return arrowtype_.Get(index);
}
inline uint32_t arrows::arrowtype(int index) const {
  // @@protoc_insertion_point(field_get:loc.arrows.arrowType)
  return _internal_arrowtype(index);
}
inline void arrows::set_arrowtype(int index, uint32_t value) {
  arrowtype_.Set(index, value);
  // @@protoc_insertion_point(field_set:loc.arrows.arrowType)
}
inline void arrows::_internal_add_arrowtype(uint32_t value) {
  arrowtype_.Add(value);
}
inline void arrows::add_arrowtype(uint32_t value) {
  _internal_add_arrowtype(value);
  // @@protoc_insertion_point(field_add:loc.arrows.arrowType)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
arrows::_internal_arrowtype() const {
  return arrowtype_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
arrows::arrowtype() const {
  // @@protoc_insertion_point(field_list:loc.arrows.arrowType)
  return _internal_arrowtype();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
arrows::_internal_mutable_arrowtype() {
  return &arrowtype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
arrows::mutable_arrowtype() {
  // @@protoc_insertion_point(field_mutable_list:loc.arrows.arrowType)
  return _internal_mutable_arrowtype();
}

// repeated .loc.Point3D points = 3;
inline int arrows::_internal_points_size() const {
  return points_.size();
}
inline int arrows::points_size() const {
  return _internal_points_size();
}
inline void arrows::clear_points() {
  points_.Clear();
}
inline ::loc::Point3D* arrows::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:loc.arrows.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D >*
arrows::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:loc.arrows.points)
  return &points_;
}
inline const ::loc::Point3D& arrows::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::loc::Point3D& arrows::points(int index) const {
  // @@protoc_insertion_point(field_get:loc.arrows.points)
  return _internal_points(index);
}
inline ::loc::Point3D* arrows::_internal_add_points() {
  return points_.Add();
}
inline ::loc::Point3D* arrows::add_points() {
  ::loc::Point3D* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:loc.arrows.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::Point3D >&
arrows::points() const {
  // @@protoc_insertion_point(field_list:loc.arrows.points)
  return points_;
}

// -------------------------------------------------------------------

// crossWalks

// optional uint64 id = 1;
inline bool crossWalks::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool crossWalks::has_id() const {
  return _internal_has_id();
}
inline void crossWalks::clear_id() {
  id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t crossWalks::_internal_id() const {
  return id_;
}
inline uint64_t crossWalks::id() const {
  // @@protoc_insertion_point(field_get:loc.crossWalks.id)
  return _internal_id();
}
inline void crossWalks::_internal_set_id(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  id_ = value;
}
inline void crossWalks::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:loc.crossWalks.id)
}

// optional float halfWidth = 2;
inline bool crossWalks::_internal_has_halfwidth() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool crossWalks::has_halfwidth() const {
  return _internal_has_halfwidth();
}
inline void crossWalks::clear_halfwidth() {
  halfwidth_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float crossWalks::_internal_halfwidth() const {
  return halfwidth_;
}
inline float crossWalks::halfwidth() const {
  // @@protoc_insertion_point(field_get:loc.crossWalks.halfWidth)
  return _internal_halfwidth();
}
inline void crossWalks::_internal_set_halfwidth(float value) {
  _has_bits_[0] |= 0x00000010u;
  halfwidth_ = value;
}
inline void crossWalks::set_halfwidth(float value) {
  _internal_set_halfwidth(value);
  // @@protoc_insertion_point(field_set:loc.crossWalks.halfWidth)
}

// optional float length = 3;
inline bool crossWalks::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool crossWalks::has_length() const {
  return _internal_has_length();
}
inline void crossWalks::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float crossWalks::_internal_length() const {
  return length_;
}
inline float crossWalks::length() const {
  // @@protoc_insertion_point(field_get:loc.crossWalks.length)
  return _internal_length();
}
inline void crossWalks::_internal_set_length(float value) {
  _has_bits_[0] |= 0x00000020u;
  length_ = value;
}
inline void crossWalks::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:loc.crossWalks.length)
}

// optional .loc.Point3D endPt = 4;
inline bool crossWalks::_internal_has_endpt() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || endpt_ != nullptr);
  return value;
}
inline bool crossWalks::has_endpt() const {
  return _internal_has_endpt();
}
inline void crossWalks::clear_endpt() {
  if (endpt_ != nullptr) endpt_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::loc::Point3D& crossWalks::_internal_endpt() const {
  const ::loc::Point3D* p = endpt_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& crossWalks::endpt() const {
  // @@protoc_insertion_point(field_get:loc.crossWalks.endPt)
  return _internal_endpt();
}
inline void crossWalks::unsafe_arena_set_allocated_endpt(
    ::loc::Point3D* endpt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpt_);
  }
  endpt_ = endpt;
  if (endpt) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.crossWalks.endPt)
}
inline ::loc::Point3D* crossWalks::release_endpt() {
  _has_bits_[0] &= ~0x00000001u;
  ::loc::Point3D* temp = endpt_;
  endpt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* crossWalks::unsafe_arena_release_endpt() {
  // @@protoc_insertion_point(field_release:loc.crossWalks.endPt)
  _has_bits_[0] &= ~0x00000001u;
  ::loc::Point3D* temp = endpt_;
  endpt_ = nullptr;
  return temp;
}
inline ::loc::Point3D* crossWalks::_internal_mutable_endpt() {
  _has_bits_[0] |= 0x00000001u;
  if (endpt_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    endpt_ = p;
  }
  return endpt_;
}
inline ::loc::Point3D* crossWalks::mutable_endpt() {
  ::loc::Point3D* _msg = _internal_mutable_endpt();
  // @@protoc_insertion_point(field_mutable:loc.crossWalks.endPt)
  return _msg;
}
inline void crossWalks::set_allocated_endpt(::loc::Point3D* endpt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete endpt_;
  }
  if (endpt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(endpt);
    if (message_arena != submessage_arena) {
      endpt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpt_ = endpt;
  // @@protoc_insertion_point(field_set_allocated:loc.crossWalks.endPt)
}

// optional .loc.Point3D wideDirection = 5;
inline bool crossWalks::_internal_has_widedirection() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || widedirection_ != nullptr);
  return value;
}
inline bool crossWalks::has_widedirection() const {
  return _internal_has_widedirection();
}
inline void crossWalks::clear_widedirection() {
  if (widedirection_ != nullptr) widedirection_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::loc::Point3D& crossWalks::_internal_widedirection() const {
  const ::loc::Point3D* p = widedirection_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& crossWalks::widedirection() const {
  // @@protoc_insertion_point(field_get:loc.crossWalks.wideDirection)
  return _internal_widedirection();
}
inline void crossWalks::unsafe_arena_set_allocated_widedirection(
    ::loc::Point3D* widedirection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(widedirection_);
  }
  widedirection_ = widedirection;
  if (widedirection) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.crossWalks.wideDirection)
}
inline ::loc::Point3D* crossWalks::release_widedirection() {
  _has_bits_[0] &= ~0x00000002u;
  ::loc::Point3D* temp = widedirection_;
  widedirection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* crossWalks::unsafe_arena_release_widedirection() {
  // @@protoc_insertion_point(field_release:loc.crossWalks.wideDirection)
  _has_bits_[0] &= ~0x00000002u;
  ::loc::Point3D* temp = widedirection_;
  widedirection_ = nullptr;
  return temp;
}
inline ::loc::Point3D* crossWalks::_internal_mutable_widedirection() {
  _has_bits_[0] |= 0x00000002u;
  if (widedirection_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    widedirection_ = p;
  }
  return widedirection_;
}
inline ::loc::Point3D* crossWalks::mutable_widedirection() {
  ::loc::Point3D* _msg = _internal_mutable_widedirection();
  // @@protoc_insertion_point(field_mutable:loc.crossWalks.wideDirection)
  return _msg;
}
inline void crossWalks::set_allocated_widedirection(::loc::Point3D* widedirection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete widedirection_;
  }
  if (widedirection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(widedirection);
    if (message_arena != submessage_arena) {
      widedirection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, widedirection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  widedirection_ = widedirection;
  // @@protoc_insertion_point(field_set_allocated:loc.crossWalks.wideDirection)
}

// optional .loc.Point3D longDirection = 6;
inline bool crossWalks::_internal_has_longdirection() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || longdirection_ != nullptr);
  return value;
}
inline bool crossWalks::has_longdirection() const {
  return _internal_has_longdirection();
}
inline void crossWalks::clear_longdirection() {
  if (longdirection_ != nullptr) longdirection_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::loc::Point3D& crossWalks::_internal_longdirection() const {
  const ::loc::Point3D* p = longdirection_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::Point3D&>(
      ::loc::_Point3D_default_instance_);
}
inline const ::loc::Point3D& crossWalks::longdirection() const {
  // @@protoc_insertion_point(field_get:loc.crossWalks.longDirection)
  return _internal_longdirection();
}
inline void crossWalks::unsafe_arena_set_allocated_longdirection(
    ::loc::Point3D* longdirection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(longdirection_);
  }
  longdirection_ = longdirection;
  if (longdirection) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.crossWalks.longDirection)
}
inline ::loc::Point3D* crossWalks::release_longdirection() {
  _has_bits_[0] &= ~0x00000004u;
  ::loc::Point3D* temp = longdirection_;
  longdirection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::Point3D* crossWalks::unsafe_arena_release_longdirection() {
  // @@protoc_insertion_point(field_release:loc.crossWalks.longDirection)
  _has_bits_[0] &= ~0x00000004u;
  ::loc::Point3D* temp = longdirection_;
  longdirection_ = nullptr;
  return temp;
}
inline ::loc::Point3D* crossWalks::_internal_mutable_longdirection() {
  _has_bits_[0] |= 0x00000004u;
  if (longdirection_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::Point3D>(GetArenaForAllocation());
    longdirection_ = p;
  }
  return longdirection_;
}
inline ::loc::Point3D* crossWalks::mutable_longdirection() {
  ::loc::Point3D* _msg = _internal_mutable_longdirection();
  // @@protoc_insertion_point(field_mutable:loc.crossWalks.longDirection)
  return _msg;
}
inline void crossWalks::set_allocated_longdirection(::loc::Point3D* longdirection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete longdirection_;
  }
  if (longdirection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::Point3D>::GetOwningArena(longdirection);
    if (message_arena != submessage_arena) {
      longdirection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, longdirection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  longdirection_ = longdirection;
  // @@protoc_insertion_point(field_set_allocated:loc.crossWalks.longDirection)
}

// -------------------------------------------------------------------

// MapInfo

// optional uint64 timeStamp = 1;
inline bool MapInfo::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MapInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void MapInfo::clear_timestamp() {
  timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t MapInfo::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t MapInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:loc.MapInfo.timeStamp)
  return _internal_timestamp();
}
inline void MapInfo::_internal_set_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
}
inline void MapInfo::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:loc.MapInfo.timeStamp)
}

// repeated .loc.parkingSlots ParkingSlot = 2;
inline int MapInfo::_internal_parkingslot_size() const {
  return parkingslot_.size();
}
inline int MapInfo::parkingslot_size() const {
  return _internal_parkingslot_size();
}
inline void MapInfo::clear_parkingslot() {
  parkingslot_.Clear();
}
inline ::loc::parkingSlots* MapInfo::mutable_parkingslot(int index) {
  // @@protoc_insertion_point(field_mutable:loc.MapInfo.ParkingSlot)
  return parkingslot_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots >*
MapInfo::mutable_parkingslot() {
  // @@protoc_insertion_point(field_mutable_list:loc.MapInfo.ParkingSlot)
  return &parkingslot_;
}
inline const ::loc::parkingSlots& MapInfo::_internal_parkingslot(int index) const {
  return parkingslot_.Get(index);
}
inline const ::loc::parkingSlots& MapInfo::parkingslot(int index) const {
  // @@protoc_insertion_point(field_get:loc.MapInfo.ParkingSlot)
  return _internal_parkingslot(index);
}
inline ::loc::parkingSlots* MapInfo::_internal_add_parkingslot() {
  return parkingslot_.Add();
}
inline ::loc::parkingSlots* MapInfo::add_parkingslot() {
  ::loc::parkingSlots* _add = _internal_add_parkingslot();
  // @@protoc_insertion_point(field_add:loc.MapInfo.ParkingSlot)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots >&
MapInfo::parkingslot() const {
  // @@protoc_insertion_point(field_list:loc.MapInfo.ParkingSlot)
  return parkingslot_;
}

// repeated .loc.laneLines LaneLine = 3;
inline int MapInfo::_internal_laneline_size() const {
  return laneline_.size();
}
inline int MapInfo::laneline_size() const {
  return _internal_laneline_size();
}
inline void MapInfo::clear_laneline() {
  laneline_.Clear();
}
inline ::loc::laneLines* MapInfo::mutable_laneline(int index) {
  // @@protoc_insertion_point(field_mutable:loc.MapInfo.LaneLine)
  return laneline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::laneLines >*
MapInfo::mutable_laneline() {
  // @@protoc_insertion_point(field_mutable_list:loc.MapInfo.LaneLine)
  return &laneline_;
}
inline const ::loc::laneLines& MapInfo::_internal_laneline(int index) const {
  return laneline_.Get(index);
}
inline const ::loc::laneLines& MapInfo::laneline(int index) const {
  // @@protoc_insertion_point(field_get:loc.MapInfo.LaneLine)
  return _internal_laneline(index);
}
inline ::loc::laneLines* MapInfo::_internal_add_laneline() {
  return laneline_.Add();
}
inline ::loc::laneLines* MapInfo::add_laneline() {
  ::loc::laneLines* _add = _internal_add_laneline();
  // @@protoc_insertion_point(field_add:loc.MapInfo.LaneLine)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::laneLines >&
MapInfo::laneline() const {
  // @@protoc_insertion_point(field_list:loc.MapInfo.LaneLine)
  return laneline_;
}

// repeated .loc.stopLines StopLine = 4;
inline int MapInfo::_internal_stopline_size() const {
  return stopline_.size();
}
inline int MapInfo::stopline_size() const {
  return _internal_stopline_size();
}
inline void MapInfo::clear_stopline() {
  stopline_.Clear();
}
inline ::loc::stopLines* MapInfo::mutable_stopline(int index) {
  // @@protoc_insertion_point(field_mutable:loc.MapInfo.StopLine)
  return stopline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::stopLines >*
MapInfo::mutable_stopline() {
  // @@protoc_insertion_point(field_mutable_list:loc.MapInfo.StopLine)
  return &stopline_;
}
inline const ::loc::stopLines& MapInfo::_internal_stopline(int index) const {
  return stopline_.Get(index);
}
inline const ::loc::stopLines& MapInfo::stopline(int index) const {
  // @@protoc_insertion_point(field_get:loc.MapInfo.StopLine)
  return _internal_stopline(index);
}
inline ::loc::stopLines* MapInfo::_internal_add_stopline() {
  return stopline_.Add();
}
inline ::loc::stopLines* MapInfo::add_stopline() {
  ::loc::stopLines* _add = _internal_add_stopline();
  // @@protoc_insertion_point(field_add:loc.MapInfo.StopLine)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::stopLines >&
MapInfo::stopline() const {
  // @@protoc_insertion_point(field_list:loc.MapInfo.StopLine)
  return stopline_;
}

// repeated .loc.bumps Bump = 5;
inline int MapInfo::_internal_bump_size() const {
  return bump_.size();
}
inline int MapInfo::bump_size() const {
  return _internal_bump_size();
}
inline void MapInfo::clear_bump() {
  bump_.Clear();
}
inline ::loc::bumps* MapInfo::mutable_bump(int index) {
  // @@protoc_insertion_point(field_mutable:loc.MapInfo.Bump)
  return bump_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::bumps >*
MapInfo::mutable_bump() {
  // @@protoc_insertion_point(field_mutable_list:loc.MapInfo.Bump)
  return &bump_;
}
inline const ::loc::bumps& MapInfo::_internal_bump(int index) const {
  return bump_.Get(index);
}
inline const ::loc::bumps& MapInfo::bump(int index) const {
  // @@protoc_insertion_point(field_get:loc.MapInfo.Bump)
  return _internal_bump(index);
}
inline ::loc::bumps* MapInfo::_internal_add_bump() {
  return bump_.Add();
}
inline ::loc::bumps* MapInfo::add_bump() {
  ::loc::bumps* _add = _internal_add_bump();
  // @@protoc_insertion_point(field_add:loc.MapInfo.Bump)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::bumps >&
MapInfo::bump() const {
  // @@protoc_insertion_point(field_list:loc.MapInfo.Bump)
  return bump_;
}

// repeated .loc.crossWalks CrossWalk = 6;
inline int MapInfo::_internal_crosswalk_size() const {
  return crosswalk_.size();
}
inline int MapInfo::crosswalk_size() const {
  return _internal_crosswalk_size();
}
inline void MapInfo::clear_crosswalk() {
  crosswalk_.Clear();
}
inline ::loc::crossWalks* MapInfo::mutable_crosswalk(int index) {
  // @@protoc_insertion_point(field_mutable:loc.MapInfo.CrossWalk)
  return crosswalk_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::crossWalks >*
MapInfo::mutable_crosswalk() {
  // @@protoc_insertion_point(field_mutable_list:loc.MapInfo.CrossWalk)
  return &crosswalk_;
}
inline const ::loc::crossWalks& MapInfo::_internal_crosswalk(int index) const {
  return crosswalk_.Get(index);
}
inline const ::loc::crossWalks& MapInfo::crosswalk(int index) const {
  // @@protoc_insertion_point(field_get:loc.MapInfo.CrossWalk)
  return _internal_crosswalk(index);
}
inline ::loc::crossWalks* MapInfo::_internal_add_crosswalk() {
  return crosswalk_.Add();
}
inline ::loc::crossWalks* MapInfo::add_crosswalk() {
  ::loc::crossWalks* _add = _internal_add_crosswalk();
  // @@protoc_insertion_point(field_add:loc.MapInfo.CrossWalk)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::crossWalks >&
MapInfo::crosswalk() const {
  // @@protoc_insertion_point(field_list:loc.MapInfo.CrossWalk)
  return crosswalk_;
}

// repeated .loc.arrows Arrow = 7;
inline int MapInfo::_internal_arrow_size() const {
  return arrow_.size();
}
inline int MapInfo::arrow_size() const {
  return _internal_arrow_size();
}
inline void MapInfo::clear_arrow() {
  arrow_.Clear();
}
inline ::loc::arrows* MapInfo::mutable_arrow(int index) {
  // @@protoc_insertion_point(field_mutable:loc.MapInfo.Arrow)
  return arrow_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::arrows >*
MapInfo::mutable_arrow() {
  // @@protoc_insertion_point(field_mutable_list:loc.MapInfo.Arrow)
  return &arrow_;
}
inline const ::loc::arrows& MapInfo::_internal_arrow(int index) const {
  return arrow_.Get(index);
}
inline const ::loc::arrows& MapInfo::arrow(int index) const {
  // @@protoc_insertion_point(field_get:loc.MapInfo.Arrow)
  return _internal_arrow(index);
}
inline ::loc::arrows* MapInfo::_internal_add_arrow() {
  return arrow_.Add();
}
inline ::loc::arrows* MapInfo::add_arrow() {
  ::loc::arrows* _add = _internal_add_arrow();
  // @@protoc_insertion_point(field_add:loc.MapInfo.Arrow)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::arrows >&
MapInfo::arrow() const {
  // @@protoc_insertion_point(field_list:loc.MapInfo.Arrow)
  return arrow_;
}

// repeated .loc.parkingSlots parkingSlotsOptimize = 8;
inline int MapInfo::_internal_parkingslotsoptimize_size() const {
  return parkingslotsoptimize_.size();
}
inline int MapInfo::parkingslotsoptimize_size() const {
  return _internal_parkingslotsoptimize_size();
}
inline void MapInfo::clear_parkingslotsoptimize() {
  parkingslotsoptimize_.Clear();
}
inline ::loc::parkingSlots* MapInfo::mutable_parkingslotsoptimize(int index) {
  // @@protoc_insertion_point(field_mutable:loc.MapInfo.parkingSlotsOptimize)
  return parkingslotsoptimize_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots >*
MapInfo::mutable_parkingslotsoptimize() {
  // @@protoc_insertion_point(field_mutable_list:loc.MapInfo.parkingSlotsOptimize)
  return &parkingslotsoptimize_;
}
inline const ::loc::parkingSlots& MapInfo::_internal_parkingslotsoptimize(int index) const {
  return parkingslotsoptimize_.Get(index);
}
inline const ::loc::parkingSlots& MapInfo::parkingslotsoptimize(int index) const {
  // @@protoc_insertion_point(field_get:loc.MapInfo.parkingSlotsOptimize)
  return _internal_parkingslotsoptimize(index);
}
inline ::loc::parkingSlots* MapInfo::_internal_add_parkingslotsoptimize() {
  return parkingslotsoptimize_.Add();
}
inline ::loc::parkingSlots* MapInfo::add_parkingslotsoptimize() {
  ::loc::parkingSlots* _add = _internal_add_parkingslotsoptimize();
  // @@protoc_insertion_point(field_add:loc.MapInfo.parkingSlotsOptimize)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::loc::parkingSlots >&
MapInfo::parkingslotsoptimize() const {
  // @@protoc_insertion_point(field_list:loc.MapInfo.parkingSlotsOptimize)
  return parkingslotsoptimize_;
}

// optional uint64 mapId = 9;
inline bool MapInfo::_internal_has_mapid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MapInfo::has_mapid() const {
  return _internal_has_mapid();
}
inline void MapInfo::clear_mapid() {
  mapid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t MapInfo::_internal_mapid() const {
  return mapid_;
}
inline uint64_t MapInfo::mapid() const {
  // @@protoc_insertion_point(field_get:loc.MapInfo.mapId)
  return _internal_mapid();
}
inline void MapInfo::_internal_set_mapid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  mapid_ = value;
}
inline void MapInfo::set_mapid(uint64_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:loc.MapInfo.mapId)
}

// -------------------------------------------------------------------

// LocStatus

// optional .loc.LocStatusType locstatus = 1;
inline bool LocStatus::_internal_has_locstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocStatus::has_locstatus() const {
  return _internal_has_locstatus();
}
inline void LocStatus::clear_locstatus() {
  locstatus_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::loc::LocStatusType LocStatus::_internal_locstatus() const {
  return static_cast< ::loc::LocStatusType >(locstatus_);
}
inline ::loc::LocStatusType LocStatus::locstatus() const {
  // @@protoc_insertion_point(field_get:loc.LocStatus.locstatus)
  return _internal_locstatus();
}
inline void LocStatus::_internal_set_locstatus(::loc::LocStatusType value) {
  _has_bits_[0] |= 0x00000001u;
  locstatus_ = value;
}
inline void LocStatus::set_locstatus(::loc::LocStatusType value) {
  _internal_set_locstatus(value);
  // @@protoc_insertion_point(field_set:loc.LocStatus.locstatus)
}

// -------------------------------------------------------------------

// padRealTimeLocation

// optional .loc.LocStatusType LocWorkingStatus = 1;
inline bool padRealTimeLocation::_internal_has_locworkingstatus() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool padRealTimeLocation::has_locworkingstatus() const {
  return _internal_has_locworkingstatus();
}
inline void padRealTimeLocation::clear_locworkingstatus() {
  locworkingstatus_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::loc::LocStatusType padRealTimeLocation::_internal_locworkingstatus() const {
  return static_cast< ::loc::LocStatusType >(locworkingstatus_);
}
inline ::loc::LocStatusType padRealTimeLocation::locworkingstatus() const {
  // @@protoc_insertion_point(field_get:loc.padRealTimeLocation.LocWorkingStatus)
  return _internal_locworkingstatus();
}
inline void padRealTimeLocation::_internal_set_locworkingstatus(::loc::LocStatusType value) {
  _has_bits_[0] |= 0x00000004u;
  locworkingstatus_ = value;
}
inline void padRealTimeLocation::set_locworkingstatus(::loc::LocStatusType value) {
  _internal_set_locworkingstatus(value);
  // @@protoc_insertion_point(field_set:loc.padRealTimeLocation.LocWorkingStatus)
}

// optional uint32 flag_SlotWidthUpdate = 2;
inline bool padRealTimeLocation::_internal_has_flag_slotwidthupdate() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool padRealTimeLocation::has_flag_slotwidthupdate() const {
  return _internal_has_flag_slotwidthupdate();
}
inline void padRealTimeLocation::clear_flag_slotwidthupdate() {
  flag_slotwidthupdate_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t padRealTimeLocation::_internal_flag_slotwidthupdate() const {
  return flag_slotwidthupdate_;
}
inline uint32_t padRealTimeLocation::flag_slotwidthupdate() const {
  // @@protoc_insertion_point(field_get:loc.padRealTimeLocation.flag_SlotWidthUpdate)
  return _internal_flag_slotwidthupdate();
}
inline void padRealTimeLocation::_internal_set_flag_slotwidthupdate(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  flag_slotwidthupdate_ = value;
}
inline void padRealTimeLocation::set_flag_slotwidthupdate(uint32_t value) {
  _internal_set_flag_slotwidthupdate(value);
  // @@protoc_insertion_point(field_set:loc.padRealTimeLocation.flag_SlotWidthUpdate)
}

// optional uint32 updatedSlotWidth = 3;
inline bool padRealTimeLocation::_internal_has_updatedslotwidth() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool padRealTimeLocation::has_updatedslotwidth() const {
  return _internal_has_updatedslotwidth();
}
inline void padRealTimeLocation::clear_updatedslotwidth() {
  updatedslotwidth_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t padRealTimeLocation::_internal_updatedslotwidth() const {
  return updatedslotwidth_;
}
inline uint32_t padRealTimeLocation::updatedslotwidth() const {
  // @@protoc_insertion_point(field_get:loc.padRealTimeLocation.updatedSlotWidth)
  return _internal_updatedslotwidth();
}
inline void padRealTimeLocation::_internal_set_updatedslotwidth(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  updatedslotwidth_ = value;
}
inline void padRealTimeLocation::set_updatedslotwidth(uint32_t value) {
  _internal_set_updatedslotwidth(value);
  // @@protoc_insertion_point(field_set:loc.padRealTimeLocation.updatedSlotWidth)
}

// optional uint32 flag_SlotDepthUpdate = 4;
inline bool padRealTimeLocation::_internal_has_flag_slotdepthupdate() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool padRealTimeLocation::has_flag_slotdepthupdate() const {
  return _internal_has_flag_slotdepthupdate();
}
inline void padRealTimeLocation::clear_flag_slotdepthupdate() {
  flag_slotdepthupdate_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t padRealTimeLocation::_internal_flag_slotdepthupdate() const {
  return flag_slotdepthupdate_;
}
inline uint32_t padRealTimeLocation::flag_slotdepthupdate() const {
  // @@protoc_insertion_point(field_get:loc.padRealTimeLocation.flag_SlotDepthUpdate)
  return _internal_flag_slotdepthupdate();
}
inline void padRealTimeLocation::_internal_set_flag_slotdepthupdate(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  flag_slotdepthupdate_ = value;
}
inline void padRealTimeLocation::set_flag_slotdepthupdate(uint32_t value) {
  _internal_set_flag_slotdepthupdate(value);
  // @@protoc_insertion_point(field_set:loc.padRealTimeLocation.flag_SlotDepthUpdate)
}

// optional uint32 updatedSlotDepth = 5;
inline bool padRealTimeLocation::_internal_has_updatedslotdepth() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool padRealTimeLocation::has_updatedslotdepth() const {
  return _internal_has_updatedslotdepth();
}
inline void padRealTimeLocation::clear_updatedslotdepth() {
  updatedslotdepth_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t padRealTimeLocation::_internal_updatedslotdepth() const {
  return updatedslotdepth_;
}
inline uint32_t padRealTimeLocation::updatedslotdepth() const {
  // @@protoc_insertion_point(field_get:loc.padRealTimeLocation.updatedSlotDepth)
  return _internal_updatedslotdepth();
}
inline void padRealTimeLocation::_internal_set_updatedslotdepth(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  updatedslotdepth_ = value;
}
inline void padRealTimeLocation::set_updatedslotdepth(uint32_t value) {
  _internal_set_updatedslotdepth(value);
  // @@protoc_insertion_point(field_set:loc.padRealTimeLocation.updatedSlotDepth)
}

// optional .loc.VehiclePos vehLocation = 6;
inline bool padRealTimeLocation::_internal_has_vehlocation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || vehlocation_ != nullptr);
  return value;
}
inline bool padRealTimeLocation::has_vehlocation() const {
  return _internal_has_vehlocation();
}
inline void padRealTimeLocation::clear_vehlocation() {
  if (vehlocation_ != nullptr) vehlocation_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::loc::VehiclePos& padRealTimeLocation::_internal_vehlocation() const {
  const ::loc::VehiclePos* p = vehlocation_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::VehiclePos&>(
      ::loc::_VehiclePos_default_instance_);
}
inline const ::loc::VehiclePos& padRealTimeLocation::vehlocation() const {
  // @@protoc_insertion_point(field_get:loc.padRealTimeLocation.vehLocation)
  return _internal_vehlocation();
}
inline void padRealTimeLocation::unsafe_arena_set_allocated_vehlocation(
    ::loc::VehiclePos* vehlocation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehlocation_);
  }
  vehlocation_ = vehlocation;
  if (vehlocation) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.padRealTimeLocation.vehLocation)
}
inline ::loc::VehiclePos* padRealTimeLocation::release_vehlocation() {
  _has_bits_[0] &= ~0x00000001u;
  ::loc::VehiclePos* temp = vehlocation_;
  vehlocation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::VehiclePos* padRealTimeLocation::unsafe_arena_release_vehlocation() {
  // @@protoc_insertion_point(field_release:loc.padRealTimeLocation.vehLocation)
  _has_bits_[0] &= ~0x00000001u;
  ::loc::VehiclePos* temp = vehlocation_;
  vehlocation_ = nullptr;
  return temp;
}
inline ::loc::VehiclePos* padRealTimeLocation::_internal_mutable_vehlocation() {
  _has_bits_[0] |= 0x00000001u;
  if (vehlocation_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::VehiclePos>(GetArenaForAllocation());
    vehlocation_ = p;
  }
  return vehlocation_;
}
inline ::loc::VehiclePos* padRealTimeLocation::mutable_vehlocation() {
  ::loc::VehiclePos* _msg = _internal_mutable_vehlocation();
  // @@protoc_insertion_point(field_mutable:loc.padRealTimeLocation.vehLocation)
  return _msg;
}
inline void padRealTimeLocation::set_allocated_vehlocation(::loc::VehiclePos* vehlocation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete vehlocation_;
  }
  if (vehlocation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::VehiclePos>::GetOwningArena(vehlocation);
    if (message_arena != submessage_arena) {
      vehlocation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehlocation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vehlocation_ = vehlocation;
  // @@protoc_insertion_point(field_set_allocated:loc.padRealTimeLocation.vehLocation)
}

// optional .loc.VehiclePos locCorrection = 7;
inline bool padRealTimeLocation::_internal_has_loccorrection() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || loccorrection_ != nullptr);
  return value;
}
inline bool padRealTimeLocation::has_loccorrection() const {
  return _internal_has_loccorrection();
}
inline void padRealTimeLocation::clear_loccorrection() {
  if (loccorrection_ != nullptr) loccorrection_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::loc::VehiclePos& padRealTimeLocation::_internal_loccorrection() const {
  const ::loc::VehiclePos* p = loccorrection_;
  return p != nullptr ? *p : reinterpret_cast<const ::loc::VehiclePos&>(
      ::loc::_VehiclePos_default_instance_);
}
inline const ::loc::VehiclePos& padRealTimeLocation::loccorrection() const {
  // @@protoc_insertion_point(field_get:loc.padRealTimeLocation.locCorrection)
  return _internal_loccorrection();
}
inline void padRealTimeLocation::unsafe_arena_set_allocated_loccorrection(
    ::loc::VehiclePos* loccorrection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(loccorrection_);
  }
  loccorrection_ = loccorrection;
  if (loccorrection) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:loc.padRealTimeLocation.locCorrection)
}
inline ::loc::VehiclePos* padRealTimeLocation::release_loccorrection() {
  _has_bits_[0] &= ~0x00000002u;
  ::loc::VehiclePos* temp = loccorrection_;
  loccorrection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::loc::VehiclePos* padRealTimeLocation::unsafe_arena_release_loccorrection() {
  // @@protoc_insertion_point(field_release:loc.padRealTimeLocation.locCorrection)
  _has_bits_[0] &= ~0x00000002u;
  ::loc::VehiclePos* temp = loccorrection_;
  loccorrection_ = nullptr;
  return temp;
}
inline ::loc::VehiclePos* padRealTimeLocation::_internal_mutable_loccorrection() {
  _has_bits_[0] |= 0x00000002u;
  if (loccorrection_ == nullptr) {
    auto* p = CreateMaybeMessage<::loc::VehiclePos>(GetArenaForAllocation());
    loccorrection_ = p;
  }
  return loccorrection_;
}
inline ::loc::VehiclePos* padRealTimeLocation::mutable_loccorrection() {
  ::loc::VehiclePos* _msg = _internal_mutable_loccorrection();
  // @@protoc_insertion_point(field_mutable:loc.padRealTimeLocation.locCorrection)
  return _msg;
}
inline void padRealTimeLocation::set_allocated_loccorrection(::loc::VehiclePos* loccorrection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete loccorrection_;
  }
  if (loccorrection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::loc::VehiclePos>::GetOwningArena(loccorrection);
    if (message_arena != submessage_arena) {
      loccorrection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loccorrection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  loccorrection_ = loccorrection;
  // @@protoc_insertion_point(field_set_allocated:loc.padRealTimeLocation.locCorrection)
}

// optional uint64 timeStamp = 8;
inline bool padRealTimeLocation::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool padRealTimeLocation::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void padRealTimeLocation::clear_timestamp() {
  timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t padRealTimeLocation::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t padRealTimeLocation::timestamp() const {
  // @@protoc_insertion_point(field_get:loc.padRealTimeLocation.timeStamp)
  return _internal_timestamp();
}
inline void padRealTimeLocation::_internal_set_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  timestamp_ = value;
}
inline void padRealTimeLocation::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:loc.padRealTimeLocation.timeStamp)
}

// optional uint32 reserve = 9;
inline bool padRealTimeLocation::_internal_has_reserve() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool padRealTimeLocation::has_reserve() const {
  return _internal_has_reserve();
}
inline void padRealTimeLocation::clear_reserve() {
  reserve_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t padRealTimeLocation::_internal_reserve() const {
  return reserve_;
}
inline uint32_t padRealTimeLocation::reserve() const {
  // @@protoc_insertion_point(field_get:loc.padRealTimeLocation.reserve)
  return _internal_reserve();
}
inline void padRealTimeLocation::_internal_set_reserve(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  reserve_ = value;
}
inline void padRealTimeLocation::set_reserve(uint32_t value) {
  _internal_set_reserve(value);
  // @@protoc_insertion_point(field_set:loc.padRealTimeLocation.reserve)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace loc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::loc::LocStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::loc::LocStatusType>() {
  return ::loc::LocStatusType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_loc_2eproto
