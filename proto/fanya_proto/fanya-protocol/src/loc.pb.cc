// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loc.proto

#include "loc.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace loc {
constexpr Point3D::Point3D(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0)
  , z_(0){}
struct Point3DDefaultTypeInternal {
  constexpr Point3DDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Point3DDefaultTypeInternal() {}
  union {
    Point3D _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Point3DDefaultTypeInternal _Point3D_default_instance_;
constexpr padPoint::padPoint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0){}
struct padPointDefaultTypeInternal {
  constexpr padPointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~padPointDefaultTypeInternal() {}
  union {
    padPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT padPointDefaultTypeInternal _padPoint_default_instance_;
constexpr padVehiclePose::padVehiclePose(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : coord_(nullptr)
  , yaw_(0)
  , status_(0u)
  , timestamp_(uint64_t{0u}){}
struct padVehiclePoseDefaultTypeInternal {
  constexpr padVehiclePoseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~padVehiclePoseDefaultTypeInternal() {}
  union {
    padVehiclePose _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT padVehiclePoseDefaultTypeInternal _padVehiclePose_default_instance_;
constexpr VehiclePos::VehiclePos(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0)
  , yaw_(0){}
struct VehiclePosDefaultTypeInternal {
  constexpr VehiclePosDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VehiclePosDefaultTypeInternal() {}
  union {
    VehiclePos _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VehiclePosDefaultTypeInternal _VehiclePos_default_instance_;
constexpr App2emap_DR::App2emap_DR(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0)
  , canang_(0)
  , drstatus_(0u)
  , timestamp_(uint64_t{0u}){}
struct App2emap_DRDefaultTypeInternal {
  constexpr App2emap_DRDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~App2emap_DRDefaultTypeInternal() {}
  union {
    App2emap_DR _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT App2emap_DRDefaultTypeInternal _App2emap_DR_default_instance_;
constexpr parkingSlots::parkingSlots(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : center_(nullptr)
  , widedirection_(nullptr)
  , longdirection_(nullptr)
  , id_(uint64_t{0u})
  , width_(0)
  , length_(0)
  , pstype_(0u)
  , isoccupancy_(false){}
struct parkingSlotsDefaultTypeInternal {
  constexpr parkingSlotsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~parkingSlotsDefaultTypeInternal() {}
  union {
    parkingSlots _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT parkingSlotsDefaultTypeInternal _parkingSlots_default_instance_;
constexpr laneLines::laneLines(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : points_()
  , linetype_(0u){}
struct laneLinesDefaultTypeInternal {
  constexpr laneLinesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~laneLinesDefaultTypeInternal() {}
  union {
    laneLines _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT laneLinesDefaultTypeInternal _laneLines_default_instance_;
constexpr stopLines::stopLines(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : startpt_(nullptr)
  , endpt_(nullptr)
  , id_(uint64_t{0u}){}
struct stopLinesDefaultTypeInternal {
  constexpr stopLinesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~stopLinesDefaultTypeInternal() {}
  union {
    stopLines _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT stopLinesDefaultTypeInternal _stopLines_default_instance_;
constexpr bumps::bumps(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : endpt_(nullptr)
  , widedirection_(nullptr)
  , longdirection_(nullptr)
  , id_(uint64_t{0u})
  , halfwidth_(0)
  , length_(0){}
struct bumpsDefaultTypeInternal {
  constexpr bumpsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~bumpsDefaultTypeInternal() {}
  union {
    bumps _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT bumpsDefaultTypeInternal _bumps_default_instance_;
constexpr arrows::arrows(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : arrowtype_()
  , _arrowtype_cached_byte_size_(0)
  , points_()
  , id_(uint64_t{0u}){}
struct arrowsDefaultTypeInternal {
  constexpr arrowsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~arrowsDefaultTypeInternal() {}
  union {
    arrows _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT arrowsDefaultTypeInternal _arrows_default_instance_;
constexpr crossWalks::crossWalks(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : endpt_(nullptr)
  , widedirection_(nullptr)
  , longdirection_(nullptr)
  , id_(uint64_t{0u})
  , halfwidth_(0)
  , length_(0){}
struct crossWalksDefaultTypeInternal {
  constexpr crossWalksDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~crossWalksDefaultTypeInternal() {}
  union {
    crossWalks _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT crossWalksDefaultTypeInternal _crossWalks_default_instance_;
constexpr MapInfo::MapInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : parkingslot_()
  , laneline_()
  , stopline_()
  , bump_()
  , crosswalk_()
  , arrow_()
  , parkingslotsoptimize_()
  , timestamp_(uint64_t{0u})
  , mapid_(uint64_t{0u}){}
struct MapInfoDefaultTypeInternal {
  constexpr MapInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MapInfoDefaultTypeInternal() {}
  union {
    MapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MapInfoDefaultTypeInternal _MapInfo_default_instance_;
constexpr LocStatus::LocStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : locstatus_(0)
{}
struct LocStatusDefaultTypeInternal {
  constexpr LocStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LocStatusDefaultTypeInternal() {}
  union {
    LocStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LocStatusDefaultTypeInternal _LocStatus_default_instance_;
constexpr padRealTimeLocation::padRealTimeLocation(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : vehlocation_(nullptr)
  , loccorrection_(nullptr)
  , locworkingstatus_(0)

  , flag_slotwidthupdate_(0u)
  , updatedslotwidth_(0u)
  , flag_slotdepthupdate_(0u)
  , updatedslotdepth_(0u)
  , reserve_(0u)
  , timestamp_(uint64_t{0u}){}
struct padRealTimeLocationDefaultTypeInternal {
  constexpr padRealTimeLocationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~padRealTimeLocationDefaultTypeInternal() {}
  union {
    padRealTimeLocation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT padRealTimeLocationDefaultTypeInternal _padRealTimeLocation_default_instance_;
constexpr FusionSlotInfo2Location::FusionSlotInfo2Location(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fusionslotinfos_()
  , slotnum_(0){}
struct FusionSlotInfo2LocationDefaultTypeInternal {
  constexpr FusionSlotInfo2LocationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FusionSlotInfo2LocationDefaultTypeInternal() {}
  union {
    FusionSlotInfo2Location _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FusionSlotInfo2LocationDefaultTypeInternal _FusionSlotInfo2Location_default_instance_;
constexpr FusionSlotInfo::FusionSlotInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pt_()
  , slottype_(0)
  , fusionslottype_(0)
  , slotlabel_(0)
  , displaylabel_(0)
  , slotinnerobtype_(0)
  , slotstatustype_(0){}
struct FusionSlotInfoDefaultTypeInternal {
  constexpr FusionSlotInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FusionSlotInfoDefaultTypeInternal() {}
  union {
    FusionSlotInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FusionSlotInfoDefaultTypeInternal _FusionSlotInfo_default_instance_;
constexpr SlotPoint::SlotPoint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0){}
struct SlotPointDefaultTypeInternal {
  constexpr SlotPointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SlotPointDefaultTypeInternal() {}
  union {
    SlotPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SlotPointDefaultTypeInternal _SlotPoint_default_instance_;
}  // namespace loc
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_loc_2eproto[17];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_loc_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_loc_2eproto = nullptr;

const uint32_t TableStruct_loc_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::loc::Point3D, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::Point3D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::Point3D, x_),
  PROTOBUF_FIELD_OFFSET(::loc::Point3D, y_),
  PROTOBUF_FIELD_OFFSET(::loc::Point3D, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::loc::padPoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::padPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::padPoint, x_),
  PROTOBUF_FIELD_OFFSET(::loc::padPoint, y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::loc::padVehiclePose, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::padVehiclePose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::padVehiclePose, coord_),
  PROTOBUF_FIELD_OFFSET(::loc::padVehiclePose, yaw_),
  PROTOBUF_FIELD_OFFSET(::loc::padVehiclePose, status_),
  PROTOBUF_FIELD_OFFSET(::loc::padVehiclePose, timestamp_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::loc::VehiclePos, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::VehiclePos, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::VehiclePos, x_),
  PROTOBUF_FIELD_OFFSET(::loc::VehiclePos, y_),
  PROTOBUF_FIELD_OFFSET(::loc::VehiclePos, yaw_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::loc::App2emap_DR, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::App2emap_DR, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::App2emap_DR, x_),
  PROTOBUF_FIELD_OFFSET(::loc::App2emap_DR, y_),
  PROTOBUF_FIELD_OFFSET(::loc::App2emap_DR, canang_),
  PROTOBUF_FIELD_OFFSET(::loc::App2emap_DR, drstatus_),
  PROTOBUF_FIELD_OFFSET(::loc::App2emap_DR, timestamp_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, id_),
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, pstype_),
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, width_),
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, length_),
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, center_),
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, widedirection_),
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, longdirection_),
  PROTOBUF_FIELD_OFFSET(::loc::parkingSlots, isoccupancy_),
  3,
  6,
  4,
  5,
  0,
  1,
  2,
  7,
  PROTOBUF_FIELD_OFFSET(::loc::laneLines, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::laneLines, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::laneLines, linetype_),
  PROTOBUF_FIELD_OFFSET(::loc::laneLines, points_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::loc::stopLines, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::stopLines, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::stopLines, id_),
  PROTOBUF_FIELD_OFFSET(::loc::stopLines, startpt_),
  PROTOBUF_FIELD_OFFSET(::loc::stopLines, endpt_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::loc::bumps, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::bumps, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::bumps, id_),
  PROTOBUF_FIELD_OFFSET(::loc::bumps, halfwidth_),
  PROTOBUF_FIELD_OFFSET(::loc::bumps, length_),
  PROTOBUF_FIELD_OFFSET(::loc::bumps, endpt_),
  PROTOBUF_FIELD_OFFSET(::loc::bumps, widedirection_),
  PROTOBUF_FIELD_OFFSET(::loc::bumps, longdirection_),
  3,
  4,
  5,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::loc::arrows, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::arrows, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::arrows, id_),
  PROTOBUF_FIELD_OFFSET(::loc::arrows, arrowtype_),
  PROTOBUF_FIELD_OFFSET(::loc::arrows, points_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::loc::crossWalks, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::crossWalks, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::crossWalks, id_),
  PROTOBUF_FIELD_OFFSET(::loc::crossWalks, halfwidth_),
  PROTOBUF_FIELD_OFFSET(::loc::crossWalks, length_),
  PROTOBUF_FIELD_OFFSET(::loc::crossWalks, endpt_),
  PROTOBUF_FIELD_OFFSET(::loc::crossWalks, widedirection_),
  PROTOBUF_FIELD_OFFSET(::loc::crossWalks, longdirection_),
  3,
  4,
  5,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, timestamp_),
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, parkingslot_),
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, laneline_),
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, stopline_),
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, bump_),
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, crosswalk_),
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, arrow_),
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, parkingslotsoptimize_),
  PROTOBUF_FIELD_OFFSET(::loc::MapInfo, mapid_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::loc::LocStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::LocStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::LocStatus, locstatus_),
  0,
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, locworkingstatus_),
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, flag_slotwidthupdate_),
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, updatedslotwidth_),
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, flag_slotdepthupdate_),
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, updatedslotdepth_),
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, vehlocation_),
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, loccorrection_),
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, timestamp_),
  PROTOBUF_FIELD_OFFSET(::loc::padRealTimeLocation, reserve_),
  2,
  3,
  4,
  5,
  6,
  0,
  1,
  8,
  7,
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo2Location, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo2Location, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo2Location, slotnum_),
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo2Location, fusionslotinfos_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo, pt_),
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo, slottype_),
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo, fusionslottype_),
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo, slotlabel_),
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo, displaylabel_),
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo, slotinnerobtype_),
  PROTOBUF_FIELD_OFFSET(::loc::FusionSlotInfo, slotstatustype_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::loc::SlotPoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::loc::SlotPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::loc::SlotPoint, x_),
  PROTOBUF_FIELD_OFFSET(::loc::SlotPoint, y_),
  0,
  1,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::loc::Point3D)},
  { 12, 20, -1, sizeof(::loc::padPoint)},
  { 22, 32, -1, sizeof(::loc::padVehiclePose)},
  { 36, 45, -1, sizeof(::loc::VehiclePos)},
  { 48, 59, -1, sizeof(::loc::App2emap_DR)},
  { 64, 78, -1, sizeof(::loc::parkingSlots)},
  { 86, 94, -1, sizeof(::loc::laneLines)},
  { 96, 105, -1, sizeof(::loc::stopLines)},
  { 108, 120, -1, sizeof(::loc::bumps)},
  { 126, 135, -1, sizeof(::loc::arrows)},
  { 138, 150, -1, sizeof(::loc::crossWalks)},
  { 156, 171, -1, sizeof(::loc::MapInfo)},
  { 180, 187, -1, sizeof(::loc::LocStatus)},
  { 188, 203, -1, sizeof(::loc::padRealTimeLocation)},
  { 212, 220, -1, sizeof(::loc::FusionSlotInfo2Location)},
  { 222, 235, -1, sizeof(::loc::FusionSlotInfo)},
  { 242, 250, -1, sizeof(::loc::SlotPoint)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_Point3D_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_padPoint_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_padVehiclePose_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_VehiclePos_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_App2emap_DR_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_parkingSlots_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_laneLines_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_stopLines_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_bumps_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_arrows_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_crossWalks_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_MapInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_LocStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_padRealTimeLocation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_FusionSlotInfo2Location_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_FusionSlotInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::loc::_SlotPoint_default_instance_),
};

const char descriptor_table_protodef_loc_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\tloc.proto\022\003loc\"K\n\007Point3D\022\016\n\001x\030\001 \001(\001H\000"
  "\210\001\001\022\016\n\001y\030\002 \001(\001H\001\210\001\001\022\016\n\001z\030\003 \001(\001H\002\210\001\001B\004\n\002_"
  "xB\004\n\002_yB\004\n\002_z\"6\n\010padPoint\022\016\n\001x\030\001 \001(\005H\000\210\001"
  "\001\022\016\n\001y\030\002 \001(\005H\001\210\001\001B\004\n\002_xB\004\n\002_y\"\235\001\n\016padVeh"
  "iclePose\022!\n\005coord\030\001 \001(\0132\r.loc.padPointH\000"
  "\210\001\001\022\020\n\003yaw\030\002 \001(\002H\001\210\001\001\022\023\n\006status\030\003 \001(\rH\002\210"
  "\001\001\022\026\n\ttimeStamp\030\004 \001(\004H\003\210\001\001B\010\n\006_coordB\006\n\004"
  "_yawB\t\n\007_statusB\014\n\n_timeStamp\"R\n\nVehicle"
  "Pos\022\016\n\001x\030\001 \001(\002H\000\210\001\001\022\016\n\001y\030\002 \001(\002H\001\210\001\001\022\020\n\003y"
  "aw\030\003 \001(\002H\002\210\001\001B\004\n\002_xB\004\n\002_yB\006\n\004_yaw\"\243\001\n\013Ap"
  "p2emap_DR\022\016\n\001x\030\001 \001(\002H\000\210\001\001\022\016\n\001y\030\002 \001(\002H\001\210\001"
  "\001\022\023\n\006canAng\030\003 \001(\002H\002\210\001\001\022\025\n\010DRStatus\030\004 \001(\r"
  "H\003\210\001\001\022\026\n\ttimeStamp\030\005 \001(\004H\004\210\001\001B\004\n\002_xB\004\n\002_"
  "yB\t\n\007_canAngB\013\n\t_DRStatusB\014\n\n_timeStamp\""
  "\324\002\n\014parkingSlots\022\017\n\002id\030\001 \001(\004H\000\210\001\001\022\023\n\006psT"
  "ype\030\002 \001(\rH\001\210\001\001\022\022\n\005width\030\003 \001(\001H\002\210\001\001\022\023\n\006le"
  "ngth\030\004 \001(\001H\003\210\001\001\022!\n\006center\030\005 \001(\0132\014.loc.Po"
  "int3DH\004\210\001\001\022(\n\rwideDirection\030\006 \001(\0132\014.loc."
  "Point3DH\005\210\001\001\022(\n\rlongDirection\030\007 \001(\0132\014.lo"
  "c.Point3DH\006\210\001\001\022\030\n\013isOccupancy\030\010 \001(\010H\007\210\001\001"
  "B\005\n\003_idB\t\n\007_psTypeB\010\n\006_widthB\t\n\007_lengthB"
  "\t\n\007_centerB\020\n\016_wideDirectionB\020\n\016_longDir"
  "ectionB\016\n\014_isOccupancy\"M\n\tlaneLines\022\025\n\010l"
  "ineType\030\001 \001(\rH\000\210\001\001\022\034\n\006points\030\002 \003(\0132\014.loc"
  ".Point3DB\013\n\t_lineType\"\177\n\tstopLines\022\017\n\002id"
  "\030\001 \001(\004H\000\210\001\001\022\"\n\007startPt\030\002 \001(\0132\014.loc.Point"
  "3DH\001\210\001\001\022 \n\005endPt\030\003 \001(\0132\014.loc.Point3DH\002\210\001"
  "\001B\005\n\003_idB\n\n\010_startPtB\010\n\006_endPt\"\211\002\n\005bumps"
  "\022\017\n\002id\030\001 \001(\004H\000\210\001\001\022\026\n\thalfWidth\030\002 \001(\001H\001\210\001"
  "\001\022\023\n\006length\030\003 \001(\001H\002\210\001\001\022 \n\005endPt\030\004 \001(\0132\014."
  "loc.Point3DH\003\210\001\001\022(\n\rwideDirection\030\005 \001(\0132"
  "\014.loc.Point3DH\004\210\001\001\022(\n\rlongDirection\030\006 \001("
  "\0132\014.loc.Point3DH\005\210\001\001B\005\n\003_idB\014\n\n_halfWidt"
  "hB\t\n\007_lengthB\010\n\006_endPtB\020\n\016_wideDirection"
  "B\020\n\016_longDirection\"Q\n\006arrows\022\017\n\002id\030\001 \001(\004"
  "H\000\210\001\001\022\021\n\tarrowType\030\002 \003(\r\022\034\n\006points\030\003 \003(\013"
  "2\014.loc.Point3DB\005\n\003_id\"\216\002\n\ncrossWalks\022\017\n\002"
  "id\030\001 \001(\004H\000\210\001\001\022\026\n\thalfWidth\030\002 \001(\002H\001\210\001\001\022\023\n"
  "\006length\030\003 \001(\002H\002\210\001\001\022 \n\005endPt\030\004 \001(\0132\014.loc."
  "Point3DH\003\210\001\001\022(\n\rwideDirection\030\005 \001(\0132\014.lo"
  "c.Point3DH\004\210\001\001\022(\n\rlongDirection\030\006 \001(\0132\014."
  "loc.Point3DH\005\210\001\001B\005\n\003_idB\014\n\n_halfWidthB\t\n"
  "\007_lengthB\010\n\006_endPtB\020\n\016_wideDirectionB\020\n\016"
  "_longDirection\"\304\002\n\007MapInfo\022\026\n\ttimeStamp\030"
  "\001 \001(\004H\000\210\001\001\022&\n\013ParkingSlot\030\002 \003(\0132\021.loc.pa"
  "rkingSlots\022 \n\010LaneLine\030\003 \003(\0132\016.loc.laneL"
  "ines\022 \n\010StopLine\030\004 \003(\0132\016.loc.stopLines\022\030"
  "\n\004Bump\030\005 \003(\0132\n.loc.bumps\022\"\n\tCrossWalk\030\006 "
  "\003(\0132\017.loc.crossWalks\022\032\n\005Arrow\030\007 \003(\0132\013.lo"
  "c.arrows\022/\n\024parkingSlotsOptimize\030\010 \003(\0132\021"
  ".loc.parkingSlots\022\022\n\005mapId\030\t \001(\004H\001\210\001\001B\014\n"
  "\n_timeStampB\010\n\006_mapId\"E\n\tLocStatus\022*\n\tlo"
  "cstatus\030\001 \001(\0162\022.loc.LocStatusTypeH\000\210\001\001B\014"
  "\n\n_locstatus\"\377\003\n\023padRealTimeLocation\0221\n\020"
  "LocWorkingStatus\030\001 \001(\0162\022.loc.LocStatusTy"
  "peH\000\210\001\001\022!\n\024flag_SlotWidthUpdate\030\002 \001(\rH\001\210"
  "\001\001\022\035\n\020updatedSlotWidth\030\003 \001(\rH\002\210\001\001\022!\n\024fla"
  "g_SlotDepthUpdate\030\004 \001(\rH\003\210\001\001\022\035\n\020updatedS"
  "lotDepth\030\005 \001(\rH\004\210\001\001\022)\n\013vehLocation\030\006 \001(\013"
  "2\017.loc.VehiclePosH\005\210\001\001\022+\n\rlocCorrection\030"
  "\007 \001(\0132\017.loc.VehiclePosH\006\210\001\001\022\026\n\ttimeStamp"
  "\030\010 \001(\004H\007\210\001\001\022\024\n\007reserve\030\t \001(\rH\010\210\001\001B\023\n\021_Lo"
  "cWorkingStatusB\027\n\025_flag_SlotWidthUpdateB"
  "\023\n\021_updatedSlotWidthB\027\n\025_flag_SlotDepthU"
  "pdateB\023\n\021_updatedSlotDepthB\016\n\014_vehLocati"
  "onB\020\n\016_locCorrectionB\014\n\n_timeStampB\n\n\010_r"
  "eserve\"i\n\027FusionSlotInfo2Location\022\024\n\007slo"
  "tNum\030\001 \001(\005H\000\210\001\001\022,\n\017fusionSlotInfos\030\002 \003(\013"
  "2\023.loc.FusionSlotInfoB\n\n\010_slotNum\"\264\002\n\016Fu"
  "sionSlotInfo\022\032\n\002pt\030\001 \003(\0132\016.loc.SlotPoint"
  "\022\025\n\010slotType\030\002 \001(\005H\000\210\001\001\022\033\n\016fusionSlotTyp"
  "e\030\003 \001(\005H\001\210\001\001\022\026\n\tslotLabel\030\004 \001(\005H\002\210\001\001\022\031\n\014"
  "displayLabel\030\005 \001(\005H\003\210\001\001\022\034\n\017slotInnerObTy"
  "pe\030\006 \001(\005H\004\210\001\001\022\033\n\016slotStatusType\030\007 \001(\005H\005\210"
  "\001\001B\013\n\t_slotTypeB\021\n\017_fusionSlotTypeB\014\n\n_s"
  "lotLabelB\017\n\r_displayLabelB\022\n\020_slotInnerO"
  "bTypeB\021\n\017_slotStatusType\"7\n\tSlotPoint\022\016\n"
  "\001x\030\001 \001(\005H\000\210\001\001\022\016\n\001y\030\002 \001(\005H\001\210\001\001B\004\n\002_xB\004\n\002_"
  "y*^\n\rLocStatusType\022\017\n\013LOCSTS_NULL\020\000\022\024\n\020L"
  "OCSTS_SEARCHING\020\001\022\022\n\016LOCSTS_PARKING\020\002\022\022\n"
  "\016LOCSTS_STANDBY\020\003b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_loc_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_loc_2eproto = {
  false, false, 3225, descriptor_table_protodef_loc_2eproto, "loc.proto", 
  &descriptor_table_loc_2eproto_once, nullptr, 0, 17,
  schemas, file_default_instances, TableStruct_loc_2eproto::offsets,
  file_level_metadata_loc_2eproto, file_level_enum_descriptors_loc_2eproto, file_level_service_descriptors_loc_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_loc_2eproto_getter() {
  return &descriptor_table_loc_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_loc_2eproto(&descriptor_table_loc_2eproto);
namespace loc {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocStatusType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_loc_2eproto);
  return file_level_enum_descriptors_loc_2eproto[0];
}
bool LocStatusType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Point3D::_Internal {
 public:
  using HasBits = decltype(std::declval<Point3D>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Point3D::Point3D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.Point3D)
}
Point3D::Point3D(const Point3D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:loc.Point3D)
}

inline void Point3D::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Point3D::~Point3D() {
  // @@protoc_insertion_point(destructor:loc.Point3D)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Point3D::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Point3D::ArenaDtor(void* object) {
  Point3D* _this = reinterpret_cast< Point3D* >(object);
  (void)_this;
}
void Point3D::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Point3D::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Point3D::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.Point3D)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Point3D::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Point3D::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.Point3D)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional double x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // optional double y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // optional double z = 3;
  if (_internal_has_z()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.Point3D)
  return target;
}

size_t Point3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.Point3D)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Point3D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Point3D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Point3D::GetClassData() const { return &_class_data_; }

void Point3D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Point3D *>(to)->MergeFrom(
      static_cast<const Point3D &>(from));
}


void Point3D::MergeFrom(const Point3D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.Point3D)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Point3D::CopyFrom(const Point3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.Point3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point3D::IsInitialized() const {
  return true;
}

void Point3D::InternalSwap(Point3D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Point3D, z_)
      + sizeof(Point3D::z_)
      - PROTOBUF_FIELD_OFFSET(Point3D, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Point3D::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[0]);
}

// ===================================================================

class padPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<padPoint>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

padPoint::padPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.padPoint)
}
padPoint::padPoint(const padPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:loc.padPoint)
}

inline void padPoint::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

padPoint::~padPoint() {
  // @@protoc_insertion_point(destructor:loc.padPoint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void padPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void padPoint::ArenaDtor(void* object) {
  padPoint* _this = reinterpret_cast< padPoint* >(object);
  (void)_this;
}
void padPoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void padPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void padPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.padPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* padPoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* padPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.padPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // optional int32 y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.padPoint)
  return target;
}

size_t padPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.padPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData padPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    padPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*padPoint::GetClassData() const { return &_class_data_; }

void padPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<padPoint *>(to)->MergeFrom(
      static_cast<const padPoint &>(from));
}


void padPoint::MergeFrom(const padPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.padPoint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void padPoint::CopyFrom(const padPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.padPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool padPoint::IsInitialized() const {
  return true;
}

void padPoint::InternalSwap(padPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(padPoint, y_)
      + sizeof(padPoint::y_)
      - PROTOBUF_FIELD_OFFSET(padPoint, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata padPoint::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[1]);
}

// ===================================================================

class padVehiclePose::_Internal {
 public:
  using HasBits = decltype(std::declval<padVehiclePose>()._has_bits_);
  static const ::loc::padPoint& coord(const padVehiclePose* msg);
  static void set_has_coord(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::loc::padPoint&
padVehiclePose::_Internal::coord(const padVehiclePose* msg) {
  return *msg->coord_;
}
padVehiclePose::padVehiclePose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.padVehiclePose)
}
padVehiclePose::padVehiclePose(const padVehiclePose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_coord()) {
    coord_ = new ::loc::padPoint(*from.coord_);
  } else {
    coord_ = nullptr;
  }
  ::memcpy(&yaw_, &from.yaw_,
    static_cast<size_t>(reinterpret_cast<char*>(&timestamp_) -
    reinterpret_cast<char*>(&yaw_)) + sizeof(timestamp_));
  // @@protoc_insertion_point(copy_constructor:loc.padVehiclePose)
}

inline void padVehiclePose::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&coord_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timestamp_) -
    reinterpret_cast<char*>(&coord_)) + sizeof(timestamp_));
}

padVehiclePose::~padVehiclePose() {
  // @@protoc_insertion_point(destructor:loc.padVehiclePose)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void padVehiclePose::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete coord_;
}

void padVehiclePose::ArenaDtor(void* object) {
  padVehiclePose* _this = reinterpret_cast< padVehiclePose* >(object);
  (void)_this;
}
void padVehiclePose::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void padVehiclePose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void padVehiclePose::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.padVehiclePose)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(coord_ != nullptr);
    coord_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&yaw_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timestamp_) -
        reinterpret_cast<char*>(&yaw_)) + sizeof(timestamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* padVehiclePose::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .loc.padPoint coord = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_coord(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float yaw = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_yaw(&has_bits);
          yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 timeStamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* padVehiclePose::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.padVehiclePose)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .loc.padPoint coord = 1;
  if (_internal_has_coord()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::coord(this), target, stream);
  }

  // optional float yaw = 2;
  if (_internal_has_yaw()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_yaw(), target);
  }

  // optional uint32 status = 3;
  if (_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_status(), target);
  }

  // optional uint64 timeStamp = 4;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.padVehiclePose)
  return target;
}

size_t padVehiclePose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.padVehiclePose)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .loc.padPoint coord = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *coord_);
    }

    // optional float yaw = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
    }

    // optional uint64 timeStamp = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData padVehiclePose::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    padVehiclePose::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*padVehiclePose::GetClassData() const { return &_class_data_; }

void padVehiclePose::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<padVehiclePose *>(to)->MergeFrom(
      static_cast<const padVehiclePose &>(from));
}


void padVehiclePose::MergeFrom(const padVehiclePose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.padVehiclePose)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_coord()->::loc::padPoint::MergeFrom(from._internal_coord());
    }
    if (cached_has_bits & 0x00000002u) {
      yaw_ = from.yaw_;
    }
    if (cached_has_bits & 0x00000004u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000008u) {
      timestamp_ = from.timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void padVehiclePose::CopyFrom(const padVehiclePose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.padVehiclePose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool padVehiclePose::IsInitialized() const {
  return true;
}

void padVehiclePose::InternalSwap(padVehiclePose* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(padVehiclePose, timestamp_)
      + sizeof(padVehiclePose::timestamp_)
      - PROTOBUF_FIELD_OFFSET(padVehiclePose, coord_)>(
          reinterpret_cast<char*>(&coord_),
          reinterpret_cast<char*>(&other->coord_));
}

::PROTOBUF_NAMESPACE_ID::Metadata padVehiclePose::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[2]);
}

// ===================================================================

class VehiclePos::_Internal {
 public:
  using HasBits = decltype(std::declval<VehiclePos>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

VehiclePos::VehiclePos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.VehiclePos)
}
VehiclePos::VehiclePos(const VehiclePos& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&yaw_) -
    reinterpret_cast<char*>(&x_)) + sizeof(yaw_));
  // @@protoc_insertion_point(copy_constructor:loc.VehiclePos)
}

inline void VehiclePos::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&yaw_) -
    reinterpret_cast<char*>(&x_)) + sizeof(yaw_));
}

VehiclePos::~VehiclePos() {
  // @@protoc_insertion_point(destructor:loc.VehiclePos)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VehiclePos::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VehiclePos::ArenaDtor(void* object) {
  VehiclePos* _this = reinterpret_cast< VehiclePos* >(object);
  (void)_this;
}
void VehiclePos::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VehiclePos::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VehiclePos::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.VehiclePos)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&yaw_) -
        reinterpret_cast<char*>(&x_)) + sizeof(yaw_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VehiclePos::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float yaw = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_yaw(&has_bits);
          yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VehiclePos::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.VehiclePos)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // optional float yaw = 3;
  if (_internal_has_yaw()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_yaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.VehiclePos)
  return target;
}

size_t VehiclePos::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.VehiclePos)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float yaw = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VehiclePos::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VehiclePos::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VehiclePos::GetClassData() const { return &_class_data_; }

void VehiclePos::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VehiclePos *>(to)->MergeFrom(
      static_cast<const VehiclePos &>(from));
}


void VehiclePos::MergeFrom(const VehiclePos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.VehiclePos)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      yaw_ = from.yaw_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VehiclePos::CopyFrom(const VehiclePos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.VehiclePos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehiclePos::IsInitialized() const {
  return true;
}

void VehiclePos::InternalSwap(VehiclePos* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VehiclePos, yaw_)
      + sizeof(VehiclePos::yaw_)
      - PROTOBUF_FIELD_OFFSET(VehiclePos, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VehiclePos::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[3]);
}

// ===================================================================

class App2emap_DR::_Internal {
 public:
  using HasBits = decltype(std::declval<App2emap_DR>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_canang(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_drstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

App2emap_DR::App2emap_DR(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.App2emap_DR)
}
App2emap_DR::App2emap_DR(const App2emap_DR& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&timestamp_) -
    reinterpret_cast<char*>(&x_)) + sizeof(timestamp_));
  // @@protoc_insertion_point(copy_constructor:loc.App2emap_DR)
}

inline void App2emap_DR::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timestamp_) -
    reinterpret_cast<char*>(&x_)) + sizeof(timestamp_));
}

App2emap_DR::~App2emap_DR() {
  // @@protoc_insertion_point(destructor:loc.App2emap_DR)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void App2emap_DR::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void App2emap_DR::ArenaDtor(void* object) {
  App2emap_DR* _this = reinterpret_cast< App2emap_DR* >(object);
  (void)_this;
}
void App2emap_DR::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void App2emap_DR::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void App2emap_DR::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.App2emap_DR)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timestamp_) -
        reinterpret_cast<char*>(&x_)) + sizeof(timestamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* App2emap_DR::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float canAng = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_canang(&has_bits);
          canang_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 DRStatus = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_drstatus(&has_bits);
          drstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 timeStamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* App2emap_DR::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.App2emap_DR)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // optional float canAng = 3;
  if (_internal_has_canang()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_canang(), target);
  }

  // optional uint32 DRStatus = 4;
  if (_internal_has_drstatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_drstatus(), target);
  }

  // optional uint64 timeStamp = 5;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.App2emap_DR)
  return target;
}

size_t App2emap_DR::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.App2emap_DR)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float canAng = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 DRStatus = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_drstatus());
    }

    // optional uint64 timeStamp = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData App2emap_DR::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    App2emap_DR::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*App2emap_DR::GetClassData() const { return &_class_data_; }

void App2emap_DR::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<App2emap_DR *>(to)->MergeFrom(
      static_cast<const App2emap_DR &>(from));
}


void App2emap_DR::MergeFrom(const App2emap_DR& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.App2emap_DR)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      canang_ = from.canang_;
    }
    if (cached_has_bits & 0x00000008u) {
      drstatus_ = from.drstatus_;
    }
    if (cached_has_bits & 0x00000010u) {
      timestamp_ = from.timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void App2emap_DR::CopyFrom(const App2emap_DR& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.App2emap_DR)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool App2emap_DR::IsInitialized() const {
  return true;
}

void App2emap_DR::InternalSwap(App2emap_DR* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(App2emap_DR, timestamp_)
      + sizeof(App2emap_DR::timestamp_)
      - PROTOBUF_FIELD_OFFSET(App2emap_DR, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata App2emap_DR::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[4]);
}

// ===================================================================

class parkingSlots::_Internal {
 public:
  using HasBits = decltype(std::declval<parkingSlots>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pstype(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::loc::Point3D& center(const parkingSlots* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::loc::Point3D& widedirection(const parkingSlots* msg);
  static void set_has_widedirection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::loc::Point3D& longdirection(const parkingSlots* msg);
  static void set_has_longdirection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_isoccupancy(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::loc::Point3D&
parkingSlots::_Internal::center(const parkingSlots* msg) {
  return *msg->center_;
}
const ::loc::Point3D&
parkingSlots::_Internal::widedirection(const parkingSlots* msg) {
  return *msg->widedirection_;
}
const ::loc::Point3D&
parkingSlots::_Internal::longdirection(const parkingSlots* msg) {
  return *msg->longdirection_;
}
parkingSlots::parkingSlots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.parkingSlots)
}
parkingSlots::parkingSlots(const parkingSlots& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_center()) {
    center_ = new ::loc::Point3D(*from.center_);
  } else {
    center_ = nullptr;
  }
  if (from._internal_has_widedirection()) {
    widedirection_ = new ::loc::Point3D(*from.widedirection_);
  } else {
    widedirection_ = nullptr;
  }
  if (from._internal_has_longdirection()) {
    longdirection_ = new ::loc::Point3D(*from.longdirection_);
  } else {
    longdirection_ = nullptr;
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&isoccupancy_) -
    reinterpret_cast<char*>(&id_)) + sizeof(isoccupancy_));
  // @@protoc_insertion_point(copy_constructor:loc.parkingSlots)
}

inline void parkingSlots::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&center_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isoccupancy_) -
    reinterpret_cast<char*>(&center_)) + sizeof(isoccupancy_));
}

parkingSlots::~parkingSlots() {
  // @@protoc_insertion_point(destructor:loc.parkingSlots)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void parkingSlots::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete center_;
  if (this != internal_default_instance()) delete widedirection_;
  if (this != internal_default_instance()) delete longdirection_;
}

void parkingSlots::ArenaDtor(void* object) {
  parkingSlots* _this = reinterpret_cast< parkingSlots* >(object);
  (void)_this;
}
void parkingSlots::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void parkingSlots::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void parkingSlots::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.parkingSlots)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(center_ != nullptr);
      center_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(widedirection_ != nullptr);
      widedirection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(longdirection_ != nullptr);
      longdirection_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isoccupancy_) -
        reinterpret_cast<char*>(&id_)) + sizeof(isoccupancy_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* parkingSlots::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 psType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pstype(&has_bits);
          pstype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D center = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D wideDirection = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_widedirection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D longDirection = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_longdirection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool isOccupancy = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_isoccupancy(&has_bits);
          isoccupancy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* parkingSlots::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.parkingSlots)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint64 id = 1;
  if (_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // optional uint32 psType = 2;
  if (_internal_has_pstype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_pstype(), target);
  }

  // optional double width = 3;
  if (_internal_has_width()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_width(), target);
  }

  // optional double length = 4;
  if (_internal_has_length()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_length(), target);
  }

  // optional .loc.Point3D center = 5;
  if (_internal_has_center()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::center(this), target, stream);
  }

  // optional .loc.Point3D wideDirection = 6;
  if (_internal_has_widedirection()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::widedirection(this), target, stream);
  }

  // optional .loc.Point3D longDirection = 7;
  if (_internal_has_longdirection()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::longdirection(this), target, stream);
  }

  // optional bool isOccupancy = 8;
  if (_internal_has_isoccupancy()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_isoccupancy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.parkingSlots)
  return target;
}

size_t parkingSlots::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.parkingSlots)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .loc.Point3D center = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *center_);
    }

    // optional .loc.Point3D wideDirection = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *widedirection_);
    }

    // optional .loc.Point3D longDirection = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *longdirection_);
    }

    // optional uint64 id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
    }

    // optional double width = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double length = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 psType = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_pstype());
    }

    // optional bool isOccupancy = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData parkingSlots::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    parkingSlots::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*parkingSlots::GetClassData() const { return &_class_data_; }

void parkingSlots::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<parkingSlots *>(to)->MergeFrom(
      static_cast<const parkingSlots &>(from));
}


void parkingSlots::MergeFrom(const parkingSlots& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.parkingSlots)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_center()->::loc::Point3D::MergeFrom(from._internal_center());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_widedirection()->::loc::Point3D::MergeFrom(from._internal_widedirection());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_longdirection()->::loc::Point3D::MergeFrom(from._internal_longdirection());
    }
    if (cached_has_bits & 0x00000008u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000020u) {
      length_ = from.length_;
    }
    if (cached_has_bits & 0x00000040u) {
      pstype_ = from.pstype_;
    }
    if (cached_has_bits & 0x00000080u) {
      isoccupancy_ = from.isoccupancy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void parkingSlots::CopyFrom(const parkingSlots& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.parkingSlots)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool parkingSlots::IsInitialized() const {
  return true;
}

void parkingSlots::InternalSwap(parkingSlots* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(parkingSlots, isoccupancy_)
      + sizeof(parkingSlots::isoccupancy_)
      - PROTOBUF_FIELD_OFFSET(parkingSlots, center_)>(
          reinterpret_cast<char*>(&center_),
          reinterpret_cast<char*>(&other->center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata parkingSlots::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[5]);
}

// ===================================================================

class laneLines::_Internal {
 public:
  using HasBits = decltype(std::declval<laneLines>()._has_bits_);
  static void set_has_linetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

laneLines::laneLines(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  points_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.laneLines)
}
laneLines::laneLines(const laneLines& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      points_(from.points_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  linetype_ = from.linetype_;
  // @@protoc_insertion_point(copy_constructor:loc.laneLines)
}

inline void laneLines::SharedCtor() {
linetype_ = 0u;
}

laneLines::~laneLines() {
  // @@protoc_insertion_point(destructor:loc.laneLines)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void laneLines::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void laneLines::ArenaDtor(void* object) {
  laneLines* _this = reinterpret_cast< laneLines* >(object);
  (void)_this;
}
void laneLines::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void laneLines::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void laneLines::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.laneLines)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_.Clear();
  linetype_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* laneLines::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 lineType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_linetype(&has_bits);
          linetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.Point3D points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* laneLines::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.laneLines)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 lineType = 1;
  if (_internal_has_linetype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_linetype(), target);
  }

  // repeated .loc.Point3D points = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_points_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_points(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.laneLines)
  return target;
}

size_t laneLines::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.laneLines)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .loc.Point3D points = 2;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 lineType = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_linetype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData laneLines::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    laneLines::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*laneLines::GetClassData() const { return &_class_data_; }

void laneLines::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<laneLines *>(to)->MergeFrom(
      static_cast<const laneLines &>(from));
}


void laneLines::MergeFrom(const laneLines& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.laneLines)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
  if (from._internal_has_linetype()) {
    _internal_set_linetype(from._internal_linetype());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void laneLines::CopyFrom(const laneLines& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.laneLines)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool laneLines::IsInitialized() const {
  return true;
}

void laneLines::InternalSwap(laneLines* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  points_.InternalSwap(&other->points_);
  swap(linetype_, other->linetype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata laneLines::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[6]);
}

// ===================================================================

class stopLines::_Internal {
 public:
  using HasBits = decltype(std::declval<stopLines>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::loc::Point3D& startpt(const stopLines* msg);
  static void set_has_startpt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::loc::Point3D& endpt(const stopLines* msg);
  static void set_has_endpt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::loc::Point3D&
stopLines::_Internal::startpt(const stopLines* msg) {
  return *msg->startpt_;
}
const ::loc::Point3D&
stopLines::_Internal::endpt(const stopLines* msg) {
  return *msg->endpt_;
}
stopLines::stopLines(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.stopLines)
}
stopLines::stopLines(const stopLines& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_startpt()) {
    startpt_ = new ::loc::Point3D(*from.startpt_);
  } else {
    startpt_ = nullptr;
  }
  if (from._internal_has_endpt()) {
    endpt_ = new ::loc::Point3D(*from.endpt_);
  } else {
    endpt_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:loc.stopLines)
}

inline void stopLines::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&startpt_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&startpt_)) + sizeof(id_));
}

stopLines::~stopLines() {
  // @@protoc_insertion_point(destructor:loc.stopLines)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void stopLines::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete startpt_;
  if (this != internal_default_instance()) delete endpt_;
}

void stopLines::ArenaDtor(void* object) {
  stopLines* _this = reinterpret_cast< stopLines* >(object);
  (void)_this;
}
void stopLines::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void stopLines::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void stopLines::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.stopLines)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(startpt_ != nullptr);
      startpt_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(endpt_ != nullptr);
      endpt_->Clear();
    }
  }
  id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* stopLines::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D startPt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_startpt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D endPt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_endpt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* stopLines::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.stopLines)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint64 id = 1;
  if (_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // optional .loc.Point3D startPt = 2;
  if (_internal_has_startpt()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::startpt(this), target, stream);
  }

  // optional .loc.Point3D endPt = 3;
  if (_internal_has_endpt()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::endpt(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.stopLines)
  return target;
}

size_t stopLines::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.stopLines)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .loc.Point3D startPt = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *startpt_);
    }

    // optional .loc.Point3D endPt = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endpt_);
    }

    // optional uint64 id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData stopLines::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    stopLines::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*stopLines::GetClassData() const { return &_class_data_; }

void stopLines::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<stopLines *>(to)->MergeFrom(
      static_cast<const stopLines &>(from));
}


void stopLines::MergeFrom(const stopLines& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.stopLines)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_startpt()->::loc::Point3D::MergeFrom(from._internal_startpt());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_endpt()->::loc::Point3D::MergeFrom(from._internal_endpt());
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void stopLines::CopyFrom(const stopLines& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.stopLines)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool stopLines::IsInitialized() const {
  return true;
}

void stopLines::InternalSwap(stopLines* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(stopLines, id_)
      + sizeof(stopLines::id_)
      - PROTOBUF_FIELD_OFFSET(stopLines, startpt_)>(
          reinterpret_cast<char*>(&startpt_),
          reinterpret_cast<char*>(&other->startpt_));
}

::PROTOBUF_NAMESPACE_ID::Metadata stopLines::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[7]);
}

// ===================================================================

class bumps::_Internal {
 public:
  using HasBits = decltype(std::declval<bumps>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_halfwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::loc::Point3D& endpt(const bumps* msg);
  static void set_has_endpt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::loc::Point3D& widedirection(const bumps* msg);
  static void set_has_widedirection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::loc::Point3D& longdirection(const bumps* msg);
  static void set_has_longdirection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::loc::Point3D&
bumps::_Internal::endpt(const bumps* msg) {
  return *msg->endpt_;
}
const ::loc::Point3D&
bumps::_Internal::widedirection(const bumps* msg) {
  return *msg->widedirection_;
}
const ::loc::Point3D&
bumps::_Internal::longdirection(const bumps* msg) {
  return *msg->longdirection_;
}
bumps::bumps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.bumps)
}
bumps::bumps(const bumps& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_endpt()) {
    endpt_ = new ::loc::Point3D(*from.endpt_);
  } else {
    endpt_ = nullptr;
  }
  if (from._internal_has_widedirection()) {
    widedirection_ = new ::loc::Point3D(*from.widedirection_);
  } else {
    widedirection_ = nullptr;
  }
  if (from._internal_has_longdirection()) {
    longdirection_ = new ::loc::Point3D(*from.longdirection_);
  } else {
    longdirection_ = nullptr;
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&id_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:loc.bumps)
}

inline void bumps::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&endpt_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&endpt_)) + sizeof(length_));
}

bumps::~bumps() {
  // @@protoc_insertion_point(destructor:loc.bumps)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void bumps::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete endpt_;
  if (this != internal_default_instance()) delete widedirection_;
  if (this != internal_default_instance()) delete longdirection_;
}

void bumps::ArenaDtor(void* object) {
  bumps* _this = reinterpret_cast< bumps* >(object);
  (void)_this;
}
void bumps::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void bumps::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void bumps::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.bumps)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(endpt_ != nullptr);
      endpt_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(widedirection_ != nullptr);
      widedirection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(longdirection_ != nullptr);
      longdirection_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&id_)) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* bumps::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double halfWidth = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_halfwidth(&has_bits);
          halfwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D endPt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_endpt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D wideDirection = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_widedirection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D longDirection = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_longdirection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* bumps::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.bumps)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint64 id = 1;
  if (_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // optional double halfWidth = 2;
  if (_internal_has_halfwidth()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_halfwidth(), target);
  }

  // optional double length = 3;
  if (_internal_has_length()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_length(), target);
  }

  // optional .loc.Point3D endPt = 4;
  if (_internal_has_endpt()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::endpt(this), target, stream);
  }

  // optional .loc.Point3D wideDirection = 5;
  if (_internal_has_widedirection()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::widedirection(this), target, stream);
  }

  // optional .loc.Point3D longDirection = 6;
  if (_internal_has_longdirection()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::longdirection(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.bumps)
  return target;
}

size_t bumps::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.bumps)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .loc.Point3D endPt = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endpt_);
    }

    // optional .loc.Point3D wideDirection = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *widedirection_);
    }

    // optional .loc.Point3D longDirection = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *longdirection_);
    }

    // optional uint64 id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
    }

    // optional double halfWidth = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double length = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData bumps::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    bumps::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*bumps::GetClassData() const { return &_class_data_; }

void bumps::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<bumps *>(to)->MergeFrom(
      static_cast<const bumps &>(from));
}


void bumps::MergeFrom(const bumps& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.bumps)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_endpt()->::loc::Point3D::MergeFrom(from._internal_endpt());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_widedirection()->::loc::Point3D::MergeFrom(from._internal_widedirection());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_longdirection()->::loc::Point3D::MergeFrom(from._internal_longdirection());
    }
    if (cached_has_bits & 0x00000008u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      halfwidth_ = from.halfwidth_;
    }
    if (cached_has_bits & 0x00000020u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void bumps::CopyFrom(const bumps& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.bumps)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool bumps::IsInitialized() const {
  return true;
}

void bumps::InternalSwap(bumps* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(bumps, length_)
      + sizeof(bumps::length_)
      - PROTOBUF_FIELD_OFFSET(bumps, endpt_)>(
          reinterpret_cast<char*>(&endpt_),
          reinterpret_cast<char*>(&other->endpt_));
}

::PROTOBUF_NAMESPACE_ID::Metadata bumps::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[8]);
}

// ===================================================================

class arrows::_Internal {
 public:
  using HasBits = decltype(std::declval<arrows>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

arrows::arrows(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  arrowtype_(arena),
  points_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.arrows)
}
arrows::arrows(const arrows& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      arrowtype_(from.arrowtype_),
      points_(from.points_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:loc.arrows)
}

inline void arrows::SharedCtor() {
id_ = uint64_t{0u};
}

arrows::~arrows() {
  // @@protoc_insertion_point(destructor:loc.arrows)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void arrows::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void arrows::ArenaDtor(void* object) {
  arrows* _this = reinterpret_cast< arrows* >(object);
  (void)_this;
}
void arrows::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void arrows::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void arrows::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.arrows)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  arrowtype_.Clear();
  points_.Clear();
  id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* arrows::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 arrowType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_arrowtype(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_arrowtype(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.Point3D points = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* arrows::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.arrows)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint64 id = 1;
  if (_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // repeated uint32 arrowType = 2;
  {
    int byte_size = _arrowtype_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_arrowtype(), byte_size, target);
    }
  }

  // repeated .loc.Point3D points = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_points_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_points(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.arrows)
  return target;
}

size_t arrows::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.arrows)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 arrowType = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->arrowtype_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _arrowtype_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .loc.Point3D points = 3;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint64 id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData arrows::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    arrows::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*arrows::GetClassData() const { return &_class_data_; }

void arrows::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<arrows *>(to)->MergeFrom(
      static_cast<const arrows &>(from));
}


void arrows::MergeFrom(const arrows& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.arrows)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  arrowtype_.MergeFrom(from.arrowtype_);
  points_.MergeFrom(from.points_);
  if (from._internal_has_id()) {
    _internal_set_id(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void arrows::CopyFrom(const arrows& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.arrows)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool arrows::IsInitialized() const {
  return true;
}

void arrows::InternalSwap(arrows* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  arrowtype_.InternalSwap(&other->arrowtype_);
  points_.InternalSwap(&other->points_);
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata arrows::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[9]);
}

// ===================================================================

class crossWalks::_Internal {
 public:
  using HasBits = decltype(std::declval<crossWalks>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_halfwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::loc::Point3D& endpt(const crossWalks* msg);
  static void set_has_endpt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::loc::Point3D& widedirection(const crossWalks* msg);
  static void set_has_widedirection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::loc::Point3D& longdirection(const crossWalks* msg);
  static void set_has_longdirection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::loc::Point3D&
crossWalks::_Internal::endpt(const crossWalks* msg) {
  return *msg->endpt_;
}
const ::loc::Point3D&
crossWalks::_Internal::widedirection(const crossWalks* msg) {
  return *msg->widedirection_;
}
const ::loc::Point3D&
crossWalks::_Internal::longdirection(const crossWalks* msg) {
  return *msg->longdirection_;
}
crossWalks::crossWalks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.crossWalks)
}
crossWalks::crossWalks(const crossWalks& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_endpt()) {
    endpt_ = new ::loc::Point3D(*from.endpt_);
  } else {
    endpt_ = nullptr;
  }
  if (from._internal_has_widedirection()) {
    widedirection_ = new ::loc::Point3D(*from.widedirection_);
  } else {
    widedirection_ = nullptr;
  }
  if (from._internal_has_longdirection()) {
    longdirection_ = new ::loc::Point3D(*from.longdirection_);
  } else {
    longdirection_ = nullptr;
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&id_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:loc.crossWalks)
}

inline void crossWalks::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&endpt_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&endpt_)) + sizeof(length_));
}

crossWalks::~crossWalks() {
  // @@protoc_insertion_point(destructor:loc.crossWalks)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void crossWalks::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete endpt_;
  if (this != internal_default_instance()) delete widedirection_;
  if (this != internal_default_instance()) delete longdirection_;
}

void crossWalks::ArenaDtor(void* object) {
  crossWalks* _this = reinterpret_cast< crossWalks* >(object);
  (void)_this;
}
void crossWalks::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void crossWalks::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void crossWalks::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.crossWalks)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(endpt_ != nullptr);
      endpt_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(widedirection_ != nullptr);
      widedirection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(longdirection_ != nullptr);
      longdirection_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&id_)) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* crossWalks::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float halfWidth = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_halfwidth(&has_bits);
          halfwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D endPt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_endpt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D wideDirection = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_widedirection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.Point3D longDirection = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_longdirection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* crossWalks::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.crossWalks)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint64 id = 1;
  if (_internal_has_id()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // optional float halfWidth = 2;
  if (_internal_has_halfwidth()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_halfwidth(), target);
  }

  // optional float length = 3;
  if (_internal_has_length()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_length(), target);
  }

  // optional .loc.Point3D endPt = 4;
  if (_internal_has_endpt()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::endpt(this), target, stream);
  }

  // optional .loc.Point3D wideDirection = 5;
  if (_internal_has_widedirection()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::widedirection(this), target, stream);
  }

  // optional .loc.Point3D longDirection = 6;
  if (_internal_has_longdirection()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::longdirection(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.crossWalks)
  return target;
}

size_t crossWalks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.crossWalks)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .loc.Point3D endPt = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *endpt_);
    }

    // optional .loc.Point3D wideDirection = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *widedirection_);
    }

    // optional .loc.Point3D longDirection = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *longdirection_);
    }

    // optional uint64 id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
    }

    // optional float halfWidth = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float length = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData crossWalks::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    crossWalks::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*crossWalks::GetClassData() const { return &_class_data_; }

void crossWalks::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<crossWalks *>(to)->MergeFrom(
      static_cast<const crossWalks &>(from));
}


void crossWalks::MergeFrom(const crossWalks& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.crossWalks)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_endpt()->::loc::Point3D::MergeFrom(from._internal_endpt());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_widedirection()->::loc::Point3D::MergeFrom(from._internal_widedirection());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_longdirection()->::loc::Point3D::MergeFrom(from._internal_longdirection());
    }
    if (cached_has_bits & 0x00000008u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      halfwidth_ = from.halfwidth_;
    }
    if (cached_has_bits & 0x00000020u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void crossWalks::CopyFrom(const crossWalks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.crossWalks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool crossWalks::IsInitialized() const {
  return true;
}

void crossWalks::InternalSwap(crossWalks* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(crossWalks, length_)
      + sizeof(crossWalks::length_)
      - PROTOBUF_FIELD_OFFSET(crossWalks, endpt_)>(
          reinterpret_cast<char*>(&endpt_),
          reinterpret_cast<char*>(&other->endpt_));
}

::PROTOBUF_NAMESPACE_ID::Metadata crossWalks::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[10]);
}

// ===================================================================

class MapInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MapInfo>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mapid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MapInfo::MapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  parkingslot_(arena),
  laneline_(arena),
  stopline_(arena),
  bump_(arena),
  crosswalk_(arena),
  arrow_(arena),
  parkingslotsoptimize_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.MapInfo)
}
MapInfo::MapInfo(const MapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      parkingslot_(from.parkingslot_),
      laneline_(from.laneline_),
      stopline_(from.stopline_),
      bump_(from.bump_),
      crosswalk_(from.crosswalk_),
      arrow_(from.arrow_),
      parkingslotsoptimize_(from.parkingslotsoptimize_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&mapid_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(mapid_));
  // @@protoc_insertion_point(copy_constructor:loc.MapInfo)
}

inline void MapInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mapid_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(mapid_));
}

MapInfo::~MapInfo() {
  // @@protoc_insertion_point(destructor:loc.MapInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MapInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MapInfo::ArenaDtor(void* object) {
  MapInfo* _this = reinterpret_cast< MapInfo* >(object);
  (void)_this;
}
void MapInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MapInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.MapInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  parkingslot_.Clear();
  laneline_.Clear();
  stopline_.Clear();
  bump_.Clear();
  crosswalk_.Clear();
  arrow_.Clear();
  parkingslotsoptimize_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mapid_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(mapid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MapInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 timeStamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.parkingSlots ParkingSlot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parkingslot(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.laneLines LaneLine = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_laneline(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.stopLines StopLine = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stopline(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.bumps Bump = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bump(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.crossWalks CrossWalk = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_crosswalk(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.arrows Arrow = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_arrow(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.parkingSlots parkingSlotsOptimize = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_parkingslotsoptimize(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 mapId = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_mapid(&has_bits);
          mapid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.MapInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint64 timeStamp = 1;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // repeated .loc.parkingSlots ParkingSlot = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_parkingslot_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_parkingslot(i), target, stream);
  }

  // repeated .loc.laneLines LaneLine = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_laneline_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_laneline(i), target, stream);
  }

  // repeated .loc.stopLines StopLine = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_stopline_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_stopline(i), target, stream);
  }

  // repeated .loc.bumps Bump = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_bump_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_bump(i), target, stream);
  }

  // repeated .loc.crossWalks CrossWalk = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_crosswalk_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_crosswalk(i), target, stream);
  }

  // repeated .loc.arrows Arrow = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_arrow_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_arrow(i), target, stream);
  }

  // repeated .loc.parkingSlots parkingSlotsOptimize = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_parkingslotsoptimize_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_parkingslotsoptimize(i), target, stream);
  }

  // optional uint64 mapId = 9;
  if (_internal_has_mapid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_mapid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.MapInfo)
  return target;
}

size_t MapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.MapInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .loc.parkingSlots ParkingSlot = 2;
  total_size += 1UL * this->_internal_parkingslot_size();
  for (const auto& msg : this->parkingslot_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .loc.laneLines LaneLine = 3;
  total_size += 1UL * this->_internal_laneline_size();
  for (const auto& msg : this->laneline_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .loc.stopLines StopLine = 4;
  total_size += 1UL * this->_internal_stopline_size();
  for (const auto& msg : this->stopline_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .loc.bumps Bump = 5;
  total_size += 1UL * this->_internal_bump_size();
  for (const auto& msg : this->bump_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .loc.crossWalks CrossWalk = 6;
  total_size += 1UL * this->_internal_crosswalk_size();
  for (const auto& msg : this->crosswalk_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .loc.arrows Arrow = 7;
  total_size += 1UL * this->_internal_arrow_size();
  for (const auto& msg : this->arrow_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .loc.parkingSlots parkingSlotsOptimize = 8;
  total_size += 1UL * this->_internal_parkingslotsoptimize_size();
  for (const auto& msg : this->parkingslotsoptimize_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 timeStamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
    }

    // optional uint64 mapId = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_mapid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MapInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MapInfo::GetClassData() const { return &_class_data_; }

void MapInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MapInfo *>(to)->MergeFrom(
      static_cast<const MapInfo &>(from));
}


void MapInfo::MergeFrom(const MapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.MapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  parkingslot_.MergeFrom(from.parkingslot_);
  laneline_.MergeFrom(from.laneline_);
  stopline_.MergeFrom(from.stopline_);
  bump_.MergeFrom(from.bump_);
  crosswalk_.MergeFrom(from.crosswalk_);
  arrow_.MergeFrom(from.arrow_);
  parkingslotsoptimize_.MergeFrom(from.parkingslotsoptimize_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      mapid_ = from.mapid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MapInfo::CopyFrom(const MapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.MapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapInfo::IsInitialized() const {
  return true;
}

void MapInfo::InternalSwap(MapInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  parkingslot_.InternalSwap(&other->parkingslot_);
  laneline_.InternalSwap(&other->laneline_);
  stopline_.InternalSwap(&other->stopline_);
  bump_.InternalSwap(&other->bump_);
  crosswalk_.InternalSwap(&other->crosswalk_);
  arrow_.InternalSwap(&other->arrow_);
  parkingslotsoptimize_.InternalSwap(&other->parkingslotsoptimize_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapInfo, mapid_)
      + sizeof(MapInfo::mapid_)
      - PROTOBUF_FIELD_OFFSET(MapInfo, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MapInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[11]);
}

// ===================================================================

class LocStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<LocStatus>()._has_bits_);
  static void set_has_locstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LocStatus::LocStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.LocStatus)
}
LocStatus::LocStatus(const LocStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  locstatus_ = from.locstatus_;
  // @@protoc_insertion_point(copy_constructor:loc.LocStatus)
}

inline void LocStatus::SharedCtor() {
locstatus_ = 0;
}

LocStatus::~LocStatus() {
  // @@protoc_insertion_point(destructor:loc.LocStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LocStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LocStatus::ArenaDtor(void* object) {
  LocStatus* _this = reinterpret_cast< LocStatus* >(object);
  (void)_this;
}
void LocStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LocStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LocStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.LocStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  locstatus_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .loc.LocStatusType locstatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_locstatus(static_cast<::loc::LocStatusType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.LocStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .loc.LocStatusType locstatus = 1;
  if (_internal_has_locstatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_locstatus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.LocStatus)
  return target;
}

size_t LocStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.LocStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .loc.LocStatusType locstatus = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_locstatus());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LocStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocStatus::GetClassData() const { return &_class_data_; }

void LocStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LocStatus *>(to)->MergeFrom(
      static_cast<const LocStatus &>(from));
}


void LocStatus::MergeFrom(const LocStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.LocStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_locstatus()) {
    _internal_set_locstatus(from._internal_locstatus());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocStatus::CopyFrom(const LocStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.LocStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocStatus::IsInitialized() const {
  return true;
}

void LocStatus::InternalSwap(LocStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(locstatus_, other->locstatus_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LocStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[12]);
}

// ===================================================================

class padRealTimeLocation::_Internal {
 public:
  using HasBits = decltype(std::declval<padRealTimeLocation>()._has_bits_);
  static void set_has_locworkingstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flag_slotwidthupdate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_updatedslotwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_flag_slotdepthupdate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_updatedslotdepth(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::loc::VehiclePos& vehlocation(const padRealTimeLocation* msg);
  static void set_has_vehlocation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::loc::VehiclePos& loccorrection(const padRealTimeLocation* msg);
  static void set_has_loccorrection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_reserve(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::loc::VehiclePos&
padRealTimeLocation::_Internal::vehlocation(const padRealTimeLocation* msg) {
  return *msg->vehlocation_;
}
const ::loc::VehiclePos&
padRealTimeLocation::_Internal::loccorrection(const padRealTimeLocation* msg) {
  return *msg->loccorrection_;
}
padRealTimeLocation::padRealTimeLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.padRealTimeLocation)
}
padRealTimeLocation::padRealTimeLocation(const padRealTimeLocation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_vehlocation()) {
    vehlocation_ = new ::loc::VehiclePos(*from.vehlocation_);
  } else {
    vehlocation_ = nullptr;
  }
  if (from._internal_has_loccorrection()) {
    loccorrection_ = new ::loc::VehiclePos(*from.loccorrection_);
  } else {
    loccorrection_ = nullptr;
  }
  ::memcpy(&locworkingstatus_, &from.locworkingstatus_,
    static_cast<size_t>(reinterpret_cast<char*>(&timestamp_) -
    reinterpret_cast<char*>(&locworkingstatus_)) + sizeof(timestamp_));
  // @@protoc_insertion_point(copy_constructor:loc.padRealTimeLocation)
}

inline void padRealTimeLocation::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vehlocation_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timestamp_) -
    reinterpret_cast<char*>(&vehlocation_)) + sizeof(timestamp_));
}

padRealTimeLocation::~padRealTimeLocation() {
  // @@protoc_insertion_point(destructor:loc.padRealTimeLocation)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void padRealTimeLocation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete vehlocation_;
  if (this != internal_default_instance()) delete loccorrection_;
}

void padRealTimeLocation::ArenaDtor(void* object) {
  padRealTimeLocation* _this = reinterpret_cast< padRealTimeLocation* >(object);
  (void)_this;
}
void padRealTimeLocation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void padRealTimeLocation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void padRealTimeLocation::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.padRealTimeLocation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(vehlocation_ != nullptr);
      vehlocation_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(loccorrection_ != nullptr);
      loccorrection_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&locworkingstatus_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reserve_) -
        reinterpret_cast<char*>(&locworkingstatus_)) + sizeof(reserve_));
  }
  timestamp_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* padRealTimeLocation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .loc.LocStatusType LocWorkingStatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_locworkingstatus(static_cast<::loc::LocStatusType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flag_SlotWidthUpdate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flag_slotwidthupdate(&has_bits);
          flag_slotwidthupdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 updatedSlotWidth = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_updatedslotwidth(&has_bits);
          updatedslotwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flag_SlotDepthUpdate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_flag_slotdepthupdate(&has_bits);
          flag_slotdepthupdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 updatedSlotDepth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_updatedslotdepth(&has_bits);
          updatedslotdepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.VehiclePos vehLocation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_vehlocation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .loc.VehiclePos locCorrection = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_loccorrection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 timeStamp = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reserve = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_reserve(&has_bits);
          reserve_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* padRealTimeLocation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.padRealTimeLocation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .loc.LocStatusType LocWorkingStatus = 1;
  if (_internal_has_locworkingstatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_locworkingstatus(), target);
  }

  // optional uint32 flag_SlotWidthUpdate = 2;
  if (_internal_has_flag_slotwidthupdate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flag_slotwidthupdate(), target);
  }

  // optional uint32 updatedSlotWidth = 3;
  if (_internal_has_updatedslotwidth()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_updatedslotwidth(), target);
  }

  // optional uint32 flag_SlotDepthUpdate = 4;
  if (_internal_has_flag_slotdepthupdate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_flag_slotdepthupdate(), target);
  }

  // optional uint32 updatedSlotDepth = 5;
  if (_internal_has_updatedslotdepth()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_updatedslotdepth(), target);
  }

  // optional .loc.VehiclePos vehLocation = 6;
  if (_internal_has_vehlocation()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::vehlocation(this), target, stream);
  }

  // optional .loc.VehiclePos locCorrection = 7;
  if (_internal_has_loccorrection()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::loccorrection(this), target, stream);
  }

  // optional uint64 timeStamp = 8;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_timestamp(), target);
  }

  // optional uint32 reserve = 9;
  if (_internal_has_reserve()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_reserve(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.padRealTimeLocation)
  return target;
}

size_t padRealTimeLocation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.padRealTimeLocation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .loc.VehiclePos vehLocation = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *vehlocation_);
    }

    // optional .loc.VehiclePos locCorrection = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *loccorrection_);
    }

    // optional .loc.LocStatusType LocWorkingStatus = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_locworkingstatus());
    }

    // optional uint32 flag_SlotWidthUpdate = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flag_slotwidthupdate());
    }

    // optional uint32 updatedSlotWidth = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_updatedslotwidth());
    }

    // optional uint32 flag_SlotDepthUpdate = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flag_slotdepthupdate());
    }

    // optional uint32 updatedSlotDepth = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_updatedslotdepth());
    }

    // optional uint32 reserve = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_reserve());
    }

  }
  // optional uint64 timeStamp = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData padRealTimeLocation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    padRealTimeLocation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*padRealTimeLocation::GetClassData() const { return &_class_data_; }

void padRealTimeLocation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<padRealTimeLocation *>(to)->MergeFrom(
      static_cast<const padRealTimeLocation &>(from));
}


void padRealTimeLocation::MergeFrom(const padRealTimeLocation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.padRealTimeLocation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_vehlocation()->::loc::VehiclePos::MergeFrom(from._internal_vehlocation());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_loccorrection()->::loc::VehiclePos::MergeFrom(from._internal_loccorrection());
    }
    if (cached_has_bits & 0x00000004u) {
      locworkingstatus_ = from.locworkingstatus_;
    }
    if (cached_has_bits & 0x00000008u) {
      flag_slotwidthupdate_ = from.flag_slotwidthupdate_;
    }
    if (cached_has_bits & 0x00000010u) {
      updatedslotwidth_ = from.updatedslotwidth_;
    }
    if (cached_has_bits & 0x00000020u) {
      flag_slotdepthupdate_ = from.flag_slotdepthupdate_;
    }
    if (cached_has_bits & 0x00000040u) {
      updatedslotdepth_ = from.updatedslotdepth_;
    }
    if (cached_has_bits & 0x00000080u) {
      reserve_ = from.reserve_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_timestamp(from._internal_timestamp());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void padRealTimeLocation::CopyFrom(const padRealTimeLocation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.padRealTimeLocation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool padRealTimeLocation::IsInitialized() const {
  return true;
}

void padRealTimeLocation::InternalSwap(padRealTimeLocation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(padRealTimeLocation, timestamp_)
      + sizeof(padRealTimeLocation::timestamp_)
      - PROTOBUF_FIELD_OFFSET(padRealTimeLocation, vehlocation_)>(
          reinterpret_cast<char*>(&vehlocation_),
          reinterpret_cast<char*>(&other->vehlocation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata padRealTimeLocation::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[13]);
}

// ===================================================================

class FusionSlotInfo2Location::_Internal {
 public:
  using HasBits = decltype(std::declval<FusionSlotInfo2Location>()._has_bits_);
  static void set_has_slotnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FusionSlotInfo2Location::FusionSlotInfo2Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  fusionslotinfos_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.FusionSlotInfo2Location)
}
FusionSlotInfo2Location::FusionSlotInfo2Location(const FusionSlotInfo2Location& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      fusionslotinfos_(from.fusionslotinfos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  slotnum_ = from.slotnum_;
  // @@protoc_insertion_point(copy_constructor:loc.FusionSlotInfo2Location)
}

inline void FusionSlotInfo2Location::SharedCtor() {
slotnum_ = 0;
}

FusionSlotInfo2Location::~FusionSlotInfo2Location() {
  // @@protoc_insertion_point(destructor:loc.FusionSlotInfo2Location)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FusionSlotInfo2Location::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FusionSlotInfo2Location::ArenaDtor(void* object) {
  FusionSlotInfo2Location* _this = reinterpret_cast< FusionSlotInfo2Location* >(object);
  (void)_this;
}
void FusionSlotInfo2Location::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FusionSlotInfo2Location::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FusionSlotInfo2Location::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.FusionSlotInfo2Location)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fusionslotinfos_.Clear();
  slotnum_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FusionSlotInfo2Location::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 slotNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_slotnum(&has_bits);
          slotnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .loc.FusionSlotInfo fusionSlotInfos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fusionslotinfos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FusionSlotInfo2Location::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.FusionSlotInfo2Location)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 slotNum = 1;
  if (_internal_has_slotnum()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_slotnum(), target);
  }

  // repeated .loc.FusionSlotInfo fusionSlotInfos = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fusionslotinfos_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_fusionslotinfos(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.FusionSlotInfo2Location)
  return target;
}

size_t FusionSlotInfo2Location::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.FusionSlotInfo2Location)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .loc.FusionSlotInfo fusionSlotInfos = 2;
  total_size += 1UL * this->_internal_fusionslotinfos_size();
  for (const auto& msg : this->fusionslotinfos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 slotNum = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_slotnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FusionSlotInfo2Location::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FusionSlotInfo2Location::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FusionSlotInfo2Location::GetClassData() const { return &_class_data_; }

void FusionSlotInfo2Location::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FusionSlotInfo2Location *>(to)->MergeFrom(
      static_cast<const FusionSlotInfo2Location &>(from));
}


void FusionSlotInfo2Location::MergeFrom(const FusionSlotInfo2Location& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.FusionSlotInfo2Location)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fusionslotinfos_.MergeFrom(from.fusionslotinfos_);
  if (from._internal_has_slotnum()) {
    _internal_set_slotnum(from._internal_slotnum());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FusionSlotInfo2Location::CopyFrom(const FusionSlotInfo2Location& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.FusionSlotInfo2Location)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FusionSlotInfo2Location::IsInitialized() const {
  return true;
}

void FusionSlotInfo2Location::InternalSwap(FusionSlotInfo2Location* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fusionslotinfos_.InternalSwap(&other->fusionslotinfos_);
  swap(slotnum_, other->slotnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FusionSlotInfo2Location::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[14]);
}

// ===================================================================

class FusionSlotInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FusionSlotInfo>()._has_bits_);
  static void set_has_slottype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fusionslottype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_slotlabel(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_displaylabel(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_slotinnerobtype(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_slotstatustype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

FusionSlotInfo::FusionSlotInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  pt_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.FusionSlotInfo)
}
FusionSlotInfo::FusionSlotInfo(const FusionSlotInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      pt_(from.pt_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&slottype_, &from.slottype_,
    static_cast<size_t>(reinterpret_cast<char*>(&slotstatustype_) -
    reinterpret_cast<char*>(&slottype_)) + sizeof(slotstatustype_));
  // @@protoc_insertion_point(copy_constructor:loc.FusionSlotInfo)
}

inline void FusionSlotInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&slottype_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&slotstatustype_) -
    reinterpret_cast<char*>(&slottype_)) + sizeof(slotstatustype_));
}

FusionSlotInfo::~FusionSlotInfo() {
  // @@protoc_insertion_point(destructor:loc.FusionSlotInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FusionSlotInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FusionSlotInfo::ArenaDtor(void* object) {
  FusionSlotInfo* _this = reinterpret_cast< FusionSlotInfo* >(object);
  (void)_this;
}
void FusionSlotInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FusionSlotInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FusionSlotInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.FusionSlotInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pt_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&slottype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&slotstatustype_) -
        reinterpret_cast<char*>(&slottype_)) + sizeof(slotstatustype_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FusionSlotInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .loc.SlotPoint pt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pt(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 slotType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_slottype(&has_bits);
          slottype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fusionSlotType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fusionslottype(&has_bits);
          fusionslottype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slotLabel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_slotlabel(&has_bits);
          slotlabel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 displayLabel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_displaylabel(&has_bits);
          displaylabel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slotInnerObType = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_slotinnerobtype(&has_bits);
          slotinnerobtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slotStatusType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_slotstatustype(&has_bits);
          slotstatustype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FusionSlotInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.FusionSlotInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .loc.SlotPoint pt = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_pt_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_pt(i), target, stream);
  }

  // optional int32 slotType = 2;
  if (_internal_has_slottype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_slottype(), target);
  }

  // optional int32 fusionSlotType = 3;
  if (_internal_has_fusionslottype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_fusionslottype(), target);
  }

  // optional int32 slotLabel = 4;
  if (_internal_has_slotlabel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_slotlabel(), target);
  }

  // optional int32 displayLabel = 5;
  if (_internal_has_displaylabel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_displaylabel(), target);
  }

  // optional int32 slotInnerObType = 6;
  if (_internal_has_slotinnerobtype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_slotinnerobtype(), target);
  }

  // optional int32 slotStatusType = 7;
  if (_internal_has_slotstatustype()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_slotstatustype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.FusionSlotInfo)
  return target;
}

size_t FusionSlotInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.FusionSlotInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .loc.SlotPoint pt = 1;
  total_size += 1UL * this->_internal_pt_size();
  for (const auto& msg : this->pt_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 slotType = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_slottype());
    }

    // optional int32 fusionSlotType = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fusionslottype());
    }

    // optional int32 slotLabel = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_slotlabel());
    }

    // optional int32 displayLabel = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_displaylabel());
    }

    // optional int32 slotInnerObType = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_slotinnerobtype());
    }

    // optional int32 slotStatusType = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_slotstatustype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FusionSlotInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FusionSlotInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FusionSlotInfo::GetClassData() const { return &_class_data_; }

void FusionSlotInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FusionSlotInfo *>(to)->MergeFrom(
      static_cast<const FusionSlotInfo &>(from));
}


void FusionSlotInfo::MergeFrom(const FusionSlotInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.FusionSlotInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  pt_.MergeFrom(from.pt_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      slottype_ = from.slottype_;
    }
    if (cached_has_bits & 0x00000002u) {
      fusionslottype_ = from.fusionslottype_;
    }
    if (cached_has_bits & 0x00000004u) {
      slotlabel_ = from.slotlabel_;
    }
    if (cached_has_bits & 0x00000008u) {
      displaylabel_ = from.displaylabel_;
    }
    if (cached_has_bits & 0x00000010u) {
      slotinnerobtype_ = from.slotinnerobtype_;
    }
    if (cached_has_bits & 0x00000020u) {
      slotstatustype_ = from.slotstatustype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FusionSlotInfo::CopyFrom(const FusionSlotInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.FusionSlotInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FusionSlotInfo::IsInitialized() const {
  return true;
}

void FusionSlotInfo::InternalSwap(FusionSlotInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  pt_.InternalSwap(&other->pt_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FusionSlotInfo, slotstatustype_)
      + sizeof(FusionSlotInfo::slotstatustype_)
      - PROTOBUF_FIELD_OFFSET(FusionSlotInfo, slottype_)>(
          reinterpret_cast<char*>(&slottype_),
          reinterpret_cast<char*>(&other->slottype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FusionSlotInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[15]);
}

// ===================================================================

class SlotPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<SlotPoint>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SlotPoint::SlotPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:loc.SlotPoint)
}
SlotPoint::SlotPoint(const SlotPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:loc.SlotPoint)
}

inline void SlotPoint::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

SlotPoint::~SlotPoint() {
  // @@protoc_insertion_point(destructor:loc.SlotPoint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SlotPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SlotPoint::ArenaDtor(void* object) {
  SlotPoint* _this = reinterpret_cast< SlotPoint* >(object);
  (void)_this;
}
void SlotPoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SlotPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SlotPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:loc.SlotPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SlotPoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SlotPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:loc.SlotPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // optional int32 y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:loc.SlotPoint)
  return target;
}

size_t SlotPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:loc.SlotPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SlotPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SlotPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SlotPoint::GetClassData() const { return &_class_data_; }

void SlotPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SlotPoint *>(to)->MergeFrom(
      static_cast<const SlotPoint &>(from));
}


void SlotPoint::MergeFrom(const SlotPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:loc.SlotPoint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SlotPoint::CopyFrom(const SlotPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:loc.SlotPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlotPoint::IsInitialized() const {
  return true;
}

void SlotPoint::InternalSwap(SlotPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SlotPoint, y_)
      + sizeof(SlotPoint::y_)
      - PROTOBUF_FIELD_OFFSET(SlotPoint, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SlotPoint::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_loc_2eproto_getter, &descriptor_table_loc_2eproto_once,
      file_level_metadata_loc_2eproto[16]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace loc
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::loc::Point3D* Arena::CreateMaybeMessage< ::loc::Point3D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::Point3D >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::padPoint* Arena::CreateMaybeMessage< ::loc::padPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::padPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::padVehiclePose* Arena::CreateMaybeMessage< ::loc::padVehiclePose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::padVehiclePose >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::VehiclePos* Arena::CreateMaybeMessage< ::loc::VehiclePos >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::VehiclePos >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::App2emap_DR* Arena::CreateMaybeMessage< ::loc::App2emap_DR >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::App2emap_DR >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::parkingSlots* Arena::CreateMaybeMessage< ::loc::parkingSlots >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::parkingSlots >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::laneLines* Arena::CreateMaybeMessage< ::loc::laneLines >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::laneLines >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::stopLines* Arena::CreateMaybeMessage< ::loc::stopLines >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::stopLines >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::bumps* Arena::CreateMaybeMessage< ::loc::bumps >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::bumps >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::arrows* Arena::CreateMaybeMessage< ::loc::arrows >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::arrows >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::crossWalks* Arena::CreateMaybeMessage< ::loc::crossWalks >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::crossWalks >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::MapInfo* Arena::CreateMaybeMessage< ::loc::MapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::MapInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::LocStatus* Arena::CreateMaybeMessage< ::loc::LocStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::LocStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::padRealTimeLocation* Arena::CreateMaybeMessage< ::loc::padRealTimeLocation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::padRealTimeLocation >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::FusionSlotInfo2Location* Arena::CreateMaybeMessage< ::loc::FusionSlotInfo2Location >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::FusionSlotInfo2Location >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::FusionSlotInfo* Arena::CreateMaybeMessage< ::loc::FusionSlotInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::FusionSlotInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::loc::SlotPoint* Arena::CreateMaybeMessage< ::loc::SlotPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::loc::SlotPoint >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
