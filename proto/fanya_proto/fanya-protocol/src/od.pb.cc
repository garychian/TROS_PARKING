// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: od.proto

#include "od.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace od {
constexpr Obstacles::Obstacles(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cylindricalobstalces_()
  , cubeobstacles_()
  , rawobjects_()
  , rangeunitarray_()
  , header_(nullptr){}
struct ObstaclesDefaultTypeInternal {
  constexpr ObstaclesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObstaclesDefaultTypeInternal() {}
  union {
    Obstacles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
constexpr Header::Header(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : frameid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , timestampns_(nullptr)
  , seq_(0u){}
struct HeaderDefaultTypeInternal {
  constexpr HeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HeaderDefaultTypeInternal() {}
  union {
    Header _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HeaderDefaultTypeInternal _Header_default_instance_;
constexpr Time::Time(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nanosec_(uint64_t{0u}){}
struct TimeDefaultTypeInternal {
  constexpr TimeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TimeDefaultTypeInternal() {}
  union {
    Time _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TimeDefaultTypeInternal _Time_default_instance_;
constexpr ObstacleCylindrical::ObstacleCylindrical(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : trajectory_()
  , camera_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , center_(nullptr)
  , direction_(nullptr)
  , motioninfo_(nullptr)
  , label_(0)
  , typeconfidence_(0)
  , existenceconfidence_(0)
  , trackid_(0)
  , radius_(0)
  , height_(0)
  , staticstate_(0)
  , attrscore_(0){}
struct ObstacleCylindricalDefaultTypeInternal {
  constexpr ObstacleCylindricalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObstacleCylindricalDefaultTypeInternal() {}
  union {
    ObstacleCylindrical _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObstacleCylindricalDefaultTypeInternal _ObstacleCylindrical_default_instance_;
constexpr Vector3d::Vector3d(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0)
  , z_(0){}
struct Vector3dDefaultTypeInternal {
  constexpr Vector3dDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Vector3dDefaultTypeInternal() {}
  union {
    Vector3d _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Vector3dDefaultTypeInternal _Vector3d_default_instance_;
constexpr MotionInfo::MotionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : center_(nullptr)
  , centeruncertainty_(nullptr)
  , velocity_(nullptr)
  , velocityuncertainty_(nullptr)
  , acceleration_(nullptr)
  , accelerationuncertainty_(nullptr)
  , jerk_(nullptr)
  , jerkuncertainty_(nullptr)
  , isvalid_(false)
  , motionstatus_(0)
  , velocityheading_(0)
  , velocityheadinguncertainty_(0)
  , velocityheadingrate_(0)
  , velocityheadingrateuncertainty_(0){}
struct MotionInfoDefaultTypeInternal {
  constexpr MotionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionInfoDefaultTypeInternal() {}
  union {
    MotionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionInfoDefaultTypeInternal _MotionInfo_default_instance_;
constexpr Point2f::Point2f(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0){}
struct Point2fDefaultTypeInternal {
  constexpr Point2fDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Point2fDefaultTypeInternal() {}
  union {
    Point2f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Point2fDefaultTypeInternal _Point2f_default_instance_;
constexpr Vector3f::Vector3f(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0)
  , z_(0){}
struct Vector3fDefaultTypeInternal {
  constexpr Vector3fDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Vector3fDefaultTypeInternal() {}
  union {
    Vector3f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Vector3fDefaultTypeInternal _Vector3f_default_instance_;
constexpr Matrix3f::Matrix3f(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(nullptr)
  , y_(nullptr)
  , z_(nullptr){}
struct Matrix3fDefaultTypeInternal {
  constexpr Matrix3fDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Matrix3fDefaultTypeInternal() {}
  union {
    Matrix3f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Matrix3fDefaultTypeInternal _Matrix3f_default_instance_;
constexpr ObstacleCube::ObstacleCube(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : trajectory_()
  , camera_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , center_(nullptr)
  , shape_(nullptr)
  , direction_(nullptr)
  , motioninfo_(nullptr)
  , label_(0)
  , typeconfidence_(0)
  , existenceconfidence_(0)
  , trackid_(0){}
struct ObstacleCubeDefaultTypeInternal {
  constexpr ObstacleCubeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObstacleCubeDefaultTypeInternal() {}
  union {
    ObstacleCube _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObstacleCubeDefaultTypeInternal _ObstacleCube_default_instance_;
constexpr ObstacleTrajectory::ObstacleTrajectory(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : points_()
  , motionstatus_(0)

  , confidence_(0){}
struct ObstacleTrajectoryDefaultTypeInternal {
  constexpr ObstacleTrajectoryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObstacleTrajectoryDefaultTypeInternal() {}
  union {
    ObstacleTrajectory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObstacleTrajectoryDefaultTypeInternal _ObstacleTrajectory_default_instance_;
constexpr ObstacleTrajectoryPoint::ObstacleTrajectoryPoint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : center_(nullptr)
  , direction_(nullptr)
  , deltatns_(uint64_t{0u}){}
struct ObstacleTrajectoryPointDefaultTypeInternal {
  constexpr ObstacleTrajectoryPointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObstacleTrajectoryPointDefaultTypeInternal() {}
  union {
    ObstacleTrajectoryPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObstacleTrajectoryPointDefaultTypeInternal _ObstacleTrajectoryPoint_default_instance_;
constexpr ObstacleRaw::ObstacleRaw(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : landmark_()
  , landmarkscores_()
  , landmark4_()
  , landmark4scores_()
  , landmark9_()
  , landmark9scores_()
  , box3d_()
  , camera_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , box2d_(nullptr)
  , directioninfo_(nullptr)
  , positioninfo_(nullptr)
  , label_(0)
  , typeconfidence_(0)
  , existenceconfidence_(0)
  , staticstate_(0)
  , attrscore_(0){}
struct ObstacleRawDefaultTypeInternal {
  constexpr ObstacleRawDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObstacleRawDefaultTypeInternal() {}
  union {
    ObstacleRaw _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObstacleRawDefaultTypeInternal _ObstacleRaw_default_instance_;
constexpr Bbox2D::Bbox2D(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : initialized_(false)
  , topleftx_(0)
  , toplefty_(0)
  , bottomrightx_(0)
  , bottomrighty_(0)
  , confidence_(0){}
struct Bbox2DDefaultTypeInternal {
  constexpr Bbox2DDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Bbox2DDefaultTypeInternal() {}
  union {
    Bbox2D _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Bbox2DDefaultTypeInternal _Bbox2D_default_instance_;
constexpr DirectionInfo::DirectionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : directionypr_(nullptr)
  , directionypruncertainty_(nullptr)
  , isvalid_(false)
  , yaw_(0)
  , yawuncertainty_(0)
  , yawrate_(0)
  , yawrateuncertainty_(0)
  , surface_(0)
  , surfacescore_(0){}
struct DirectionInfoDefaultTypeInternal {
  constexpr DirectionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DirectionInfoDefaultTypeInternal() {}
  union {
    DirectionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DirectionInfoDefaultTypeInternal _DirectionInfo_default_instance_;
constexpr UssRange::UssRange(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : distanceid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , position_(nullptr)
  , recvtimens_(uint64_t{0u})
  , distance_(0u)
  , isvalid_(false){}
struct UssRangeDefaultTypeInternal {
  constexpr UssRangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UssRangeDefaultTypeInternal() {}
  union {
    UssRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UssRangeDefaultTypeInternal _UssRange_default_instance_;
constexpr PositionInfo::PositionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : position_(nullptr)
  , isvalid_(false){}
struct PositionInfoDefaultTypeInternal {
  constexpr PositionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PositionInfoDefaultTypeInternal() {}
  union {
    PositionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PositionInfoDefaultTypeInternal _PositionInfo_default_instance_;
constexpr FSLine::FSLine(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fsline_(){}
struct FSLineDefaultTypeInternal {
  constexpr FSLineDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FSLineDefaultTypeInternal() {}
  union {
    FSLine _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FSLineDefaultTypeInternal _FSLine_default_instance_;
constexpr FSLinesimple::FSLinesimple(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fslinepoints_()
  , header_(nullptr)
  , frametimestampns_(uint64_t{0u}){}
struct FSLinesimpleDefaultTypeInternal {
  constexpr FSLinesimpleDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FSLinesimpleDefaultTypeInternal() {}
  union {
    FSLinesimple _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FSLinesimpleDefaultTypeInternal _FSLinesimple_default_instance_;
constexpr FSLinePoint::FSLinePoint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : coordinate_(nullptr)
  , pointlabel_(0)
{}
struct FSLinePointDefaultTypeInternal {
  constexpr FSLinePointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FSLinePointDefaultTypeInternal() {}
  union {
    FSLinePoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FSLinePointDefaultTypeInternal _FSLinePoint_default_instance_;
}  // namespace od
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_od_2eproto[20];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_od_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_od_2eproto = nullptr;

const uint32_t TableStruct_od_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::od::Obstacles, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::Obstacles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::Obstacles, header_),
  PROTOBUF_FIELD_OFFSET(::od::Obstacles, cylindricalobstalces_),
  PROTOBUF_FIELD_OFFSET(::od::Obstacles, cubeobstacles_),
  PROTOBUF_FIELD_OFFSET(::od::Obstacles, rawobjects_),
  PROTOBUF_FIELD_OFFSET(::od::Obstacles, rangeunitarray_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::od::Header, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::Header, seq_),
  PROTOBUF_FIELD_OFFSET(::od::Header, timestampns_),
  PROTOBUF_FIELD_OFFSET(::od::Header, frameid_),
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::od::Time, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::Time, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::Time, nanosec_),
  0,
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, camera_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, label_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, typeconfidence_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, existenceconfidence_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, trackid_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, center_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, radius_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, height_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, direction_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, motioninfo_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, trajectory_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, staticstate_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCylindrical, attrscore_),
  0,
  4,
  5,
  6,
  7,
  1,
  8,
  9,
  2,
  3,
  ~0u,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::od::Vector3d, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::Vector3d, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::Vector3d, x_),
  PROTOBUF_FIELD_OFFSET(::od::Vector3d, y_),
  PROTOBUF_FIELD_OFFSET(::od::Vector3d, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, isvalid_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, motionstatus_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, center_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, centeruncertainty_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, velocity_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, velocityuncertainty_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, acceleration_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, accelerationuncertainty_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, jerk_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, jerkuncertainty_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, velocityheading_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, velocityheadinguncertainty_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, velocityheadingrate_),
  PROTOBUF_FIELD_OFFSET(::od::MotionInfo, velocityheadingrateuncertainty_),
  8,
  9,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::od::Point2f, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::Point2f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::Point2f, x_),
  PROTOBUF_FIELD_OFFSET(::od::Point2f, y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::od::Vector3f, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::Vector3f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::Vector3f, x_),
  PROTOBUF_FIELD_OFFSET(::od::Vector3f, y_),
  PROTOBUF_FIELD_OFFSET(::od::Vector3f, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::od::Matrix3f, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::Matrix3f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::Matrix3f, x_),
  PROTOBUF_FIELD_OFFSET(::od::Matrix3f, y_),
  PROTOBUF_FIELD_OFFSET(::od::Matrix3f, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, camera_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, label_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, typeconfidence_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, existenceconfidence_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, trackid_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, center_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, shape_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, direction_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, motioninfo_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleCube, trajectory_),
  0,
  5,
  6,
  7,
  8,
  1,
  2,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectory, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectory, motionstatus_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectory, confidence_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectory, points_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectoryPoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectoryPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectoryPoint, deltatns_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectoryPoint, center_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleTrajectoryPoint, direction_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, camera_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, label_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, typeconfidence_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, existenceconfidence_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, box2d_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, directioninfo_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, landmark_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, landmarkscores_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, landmark4_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, landmark4scores_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, landmark9_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, landmark9scores_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, positioninfo_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, box3d_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, staticstate_),
  PROTOBUF_FIELD_OFFSET(::od::ObstacleRaw, attrscore_),
  0,
  4,
  5,
  6,
  1,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  3,
  ~0u,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::od::Bbox2D, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::Bbox2D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::Bbox2D, initialized_),
  PROTOBUF_FIELD_OFFSET(::od::Bbox2D, topleftx_),
  PROTOBUF_FIELD_OFFSET(::od::Bbox2D, toplefty_),
  PROTOBUF_FIELD_OFFSET(::od::Bbox2D, bottomrightx_),
  PROTOBUF_FIELD_OFFSET(::od::Bbox2D, bottomrighty_),
  PROTOBUF_FIELD_OFFSET(::od::Bbox2D, confidence_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, isvalid_),
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, directionypr_),
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, directionypruncertainty_),
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, yaw_),
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, yawuncertainty_),
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, yawrate_),
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, yawrateuncertainty_),
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, surface_),
  PROTOBUF_FIELD_OFFSET(::od::DirectionInfo, surfacescore_),
  2,
  0,
  1,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::od::UssRange, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::UssRange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::UssRange, distanceid_),
  PROTOBUF_FIELD_OFFSET(::od::UssRange, recvtimens_),
  PROTOBUF_FIELD_OFFSET(::od::UssRange, distance_),
  PROTOBUF_FIELD_OFFSET(::od::UssRange, isvalid_),
  PROTOBUF_FIELD_OFFSET(::od::UssRange, position_),
  0,
  2,
  3,
  4,
  1,
  PROTOBUF_FIELD_OFFSET(::od::PositionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::PositionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::PositionInfo, isvalid_),
  PROTOBUF_FIELD_OFFSET(::od::PositionInfo, position_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::od::FSLine, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::FSLine, fsline_),
  PROTOBUF_FIELD_OFFSET(::od::FSLinesimple, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::FSLinesimple, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::FSLinesimple, header_),
  PROTOBUF_FIELD_OFFSET(::od::FSLinesimple, frametimestampns_),
  PROTOBUF_FIELD_OFFSET(::od::FSLinesimple, fslinepoints_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::od::FSLinePoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::od::FSLinePoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::od::FSLinePoint, coordinate_),
  PROTOBUF_FIELD_OFFSET(::od::FSLinePoint, pointlabel_),
  0,
  1,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::od::Obstacles)},
  { 16, 25, -1, sizeof(::od::Header)},
  { 28, 35, -1, sizeof(::od::Time)},
  { 36, 55, -1, sizeof(::od::ObstacleCylindrical)},
  { 68, 77, -1, sizeof(::od::Vector3d)},
  { 80, 100, -1, sizeof(::od::MotionInfo)},
  { 114, 122, -1, sizeof(::od::Point2f)},
  { 124, 133, -1, sizeof(::od::Vector3f)},
  { 136, 145, -1, sizeof(::od::Matrix3f)},
  { 148, 164, -1, sizeof(::od::ObstacleCube)},
  { 174, 183, -1, sizeof(::od::ObstacleTrajectory)},
  { 186, 195, -1, sizeof(::od::ObstacleTrajectoryPoint)},
  { 198, 220, -1, sizeof(::od::ObstacleRaw)},
  { 236, 248, -1, sizeof(::od::Bbox2D)},
  { 254, 269, -1, sizeof(::od::DirectionInfo)},
  { 278, 289, -1, sizeof(::od::UssRange)},
  { 294, 302, -1, sizeof(::od::PositionInfo)},
  { 304, -1, -1, sizeof(::od::FSLine)},
  { 311, 320, -1, sizeof(::od::FSLinesimple)},
  { 323, 331, -1, sizeof(::od::FSLinePoint)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_Obstacles_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_Header_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_Time_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_ObstacleCylindrical_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_Vector3d_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_MotionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_Point2f_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_Vector3f_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_Matrix3f_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_ObstacleCube_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_ObstacleTrajectory_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_ObstacleTrajectoryPoint_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_ObstacleRaw_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_Bbox2D_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_DirectionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_UssRange_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_PositionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_FSLine_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_FSLinesimple_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::od::_FSLinePoint_default_instance_),
};

const char descriptor_table_protodef_od_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\010od.proto\022\002od\"\342\001\n\tObstacles\022\037\n\006header\030\001"
  " \001(\0132\n.od.HeaderH\000\210\001\001\0225\n\024cylindricalObst"
  "alces\030\002 \003(\0132\027.od.ObstacleCylindrical\022\'\n\r"
  "cubeObstacles\030\003 \003(\0132\020.od.ObstacleCube\022#\n"
  "\nrawObjects\030\004 \003(\0132\017.od.ObstacleRaw\022$\n\016ra"
  "ngeUnitArray\030\005 \003(\0132\014.od.UssRangeB\t\n\007_hea"
  "der\"x\n\006Header\022\020\n\003seq\030\001 \001(\rH\000\210\001\001\022\"\n\013times"
  "tampNs\030\002 \001(\0132\010.od.TimeH\001\210\001\001\022\024\n\007frameId\030\003"
  " \001(\tH\002\210\001\001B\006\n\004_seqB\016\n\014_timestampNsB\n\n\010_fr"
  "ameId\"(\n\004Time\022\024\n\007nanoSec\030\001 \001(\004H\000\210\001\001B\n\n\010_"
  "nanoSec\"\265\004\n\023ObstacleCylindrical\022\023\n\006camer"
  "a\030\001 \001(\tH\000\210\001\001\022\022\n\005label\030\002 \001(\005H\001\210\001\001\022\033\n\016type"
  "Confidence\030\003 \001(\002H\002\210\001\001\022 \n\023existenceConfid"
  "ence\030\004 \001(\002H\003\210\001\001\022\024\n\007trackId\030\005 \001(\005H\004\210\001\001\022!\n"
  "\006Center\030\006 \001(\0132\014.od.Vector3dH\005\210\001\001\022\023\n\006radi"
  "us\030\007 \001(\002H\006\210\001\001\022\023\n\006height\030\010 \001(\002H\007\210\001\001\022$\n\tdi"
  "rection\030\t \001(\0132\014.od.Vector3dH\010\210\001\001\022\'\n\nmoti"
  "onInfo\030\n \001(\0132\016.od.MotionInfoH\t\210\001\001\022*\n\ntra"
  "jectory\030\013 \003(\0132\026.od.ObstacleTrajectory\022\030\n"
  "\013staticState\030\014 \001(\005H\n\210\001\001\022\026\n\tattrScore\030\r \001"
  "(\002H\013\210\001\001B\t\n\007_cameraB\010\n\006_labelB\021\n\017_typeCon"
  "fidenceB\026\n\024_existenceConfidenceB\n\n\010_trac"
  "kIdB\t\n\007_CenterB\t\n\007_radiusB\t\n\007_heightB\014\n\n"
  "_directionB\r\n\013_motionInfoB\016\n\014_staticStat"
  "eB\014\n\n_attrScore\"L\n\010Vector3d\022\016\n\001x\030\001 \001(\002H\000"
  "\210\001\001\022\016\n\001y\030\002 \001(\002H\001\210\001\001\022\016\n\001z\030\003 \001(\002H\002\210\001\001B\004\n\002_"
  "xB\004\n\002_yB\004\n\002_z\"\276\006\n\nMotionInfo\022\024\n\007isValid\030"
  "\001 \001(\010H\000\210\001\001\022\031\n\014motionStatus\030\002 \001(\005H\001\210\001\001\022!\n"
  "\006center\030\003 \001(\0132\014.od.Vector3dH\002\210\001\001\022,\n\021cent"
  "erUncertainty\030\004 \001(\0132\014.od.Matrix3fH\003\210\001\001\022#"
  "\n\010velocity\030\005 \001(\0132\014.od.Vector3dH\004\210\001\001\022.\n\023v"
  "elocityUncertainty\030\006 \001(\0132\014.od.Matrix3fH\005"
  "\210\001\001\022\'\n\014acceleration\030\007 \001(\0132\014.od.Vector3dH"
  "\006\210\001\001\0222\n\027accelerationUncertainty\030\010 \001(\0132\014."
  "od.Matrix3fH\007\210\001\001\022\037\n\004jerk\030\t \001(\0132\014.od.Vect"
  "or3fH\010\210\001\001\022*\n\017jerkUncertainty\030\n \001(\0132\014.od."
  "Matrix3fH\t\210\001\001\022\034\n\017velocityHeading\030\013 \001(\002H\n"
  "\210\001\001\022\'\n\032velocityHeadingUncertainty\030\014 \001(\002H"
  "\013\210\001\001\022 \n\023velocityHeadingRate\030\r \001(\002H\014\210\001\001\022+"
  "\n\036velocityHeadingRateUncertainty\030\016 \001(\002H\r"
  "\210\001\001B\n\n\010_isValidB\017\n\r_motionStatusB\t\n\007_cen"
  "terB\024\n\022_centerUncertaintyB\013\n\t_velocityB\026"
  "\n\024_velocityUncertaintyB\017\n\r_accelerationB"
  "\032\n\030_accelerationUncertaintyB\007\n\005_jerkB\022\n\020"
  "_jerkUncertaintyB\022\n\020_velocityHeadingB\035\n\033"
  "_velocityHeadingUncertaintyB\026\n\024_velocity"
  "HeadingRateB!\n\037_velocityHeadingRateUncer"
  "tainty\"5\n\007Point2f\022\016\n\001x\030\001 \001(\002H\000\210\001\001\022\016\n\001y\030\002"
  " \001(\002H\001\210\001\001B\004\n\002_xB\004\n\002_y\"L\n\010Vector3f\022\016\n\001x\030\001"
  " \001(\002H\000\210\001\001\022\016\n\001y\030\002 \001(\002H\001\210\001\001\022\016\n\001z\030\003 \001(\002H\002\210\001"
  "\001B\004\n\002_xB\004\n\002_yB\004\n\002_z\"v\n\010Matrix3f\022\034\n\001x\030\001 \001"
  "(\0132\014.od.Vector3fH\000\210\001\001\022\034\n\001y\030\002 \001(\0132\014.od.Ve"
  "ctor3fH\001\210\001\001\022\034\n\001z\030\003 \001(\0132\014.od.Vector3fH\002\210\001"
  "\001B\004\n\002_xB\004\n\002_yB\004\n\002_z\"\312\003\n\014ObstacleCube\022\023\n\006"
  "camera\030\001 \001(\tH\000\210\001\001\022\022\n\005label\030\002 \001(\005H\001\210\001\001\022\033\n"
  "\016typeConfidence\030\003 \001(\002H\002\210\001\001\022 \n\023existenceC"
  "onfidence\030\004 \001(\002H\003\210\001\001\022\024\n\007trackId\030\005 \001(\005H\004\210"
  "\001\001\022!\n\006Center\030\006 \001(\0132\014.od.Vector3dH\005\210\001\001\022 \n"
  "\005shape\030\007 \001(\0132\014.od.Vector3dH\006\210\001\001\022$\n\tdirec"
  "tion\030\010 \001(\0132\014.od.Vector3dH\007\210\001\001\022\'\n\nmotionI"
  "nfo\030\t \001(\0132\016.od.MotionInfoH\010\210\001\001\022*\n\ntrajec"
  "tory\030\n \003(\0132\026.od.ObstacleTrajectoryB\t\n\007_c"
  "ameraB\010\n\006_labelB\021\n\017_typeConfidenceB\026\n\024_e"
  "xistenceConfidenceB\n\n\010_trackIdB\t\n\007_Cente"
  "rB\010\n\006_shapeB\014\n\n_directionB\r\n\013_motionInfo"
  "\"\247\001\n\022ObstacleTrajectory\022+\n\014motionStatus\030"
  "\001 \001(\0162\020.od.MotionStatusH\000\210\001\001\022\027\n\nconfiden"
  "ce\030\002 \001(\002H\001\210\001\001\022+\n\006points\030\003 \003(\0132\033.od.Obsta"
  "cleTrajectoryPointB\017\n\r_motionStatusB\r\n\013_"
  "confidence\"\237\001\n\027ObstacleTrajectoryPoint\022\025"
  "\n\010deltaTNs\030\001 \001(\004H\000\210\001\001\022!\n\006center\030\002 \001(\0132\014."
  "od.Vector3fH\001\210\001\001\022$\n\tdirection\030\003 \001(\0132\014.od"
  ".Vector3fH\002\210\001\001B\013\n\t_deltaTNsB\t\n\007_centerB\014"
  "\n\n_direction\"\346\004\n\013ObstacleRaw\022\023\n\006camera\030\001"
  " \001(\tH\000\210\001\001\022\022\n\005label\030\002 \001(\005H\001\210\001\001\022\033\n\016typeCon"
  "fidence\030\003 \001(\002H\002\210\001\001\022 \n\023existenceConfidenc"
  "e\030\004 \001(\002H\003\210\001\001\022\036\n\005box2D\030\005 \001(\0132\n.od.Bbox2DH"
  "\004\210\001\001\022-\n\rdirectionInfo\030\006 \001(\0132\021.od.Directi"
  "onInfoH\005\210\001\001\022\035\n\010landmark\030\007 \003(\0132\013.od.Point"
  "2f\022\026\n\016landmarkScores\030\010 \003(\002\022\036\n\tlandmark4\030"
  "\t \003(\0132\013.od.Point2f\022\027\n\017landmark4Scores\030\n "
  "\003(\002\022\036\n\tlandmark9\030\013 \003(\0132\013.od.Point2f\022\027\n\017l"
  "andmark9Scores\030\014 \003(\002\022+\n\014positionInfo\030\r \001"
  "(\0132\020.od.PositionInfoH\006\210\001\001\022\r\n\005box3D\030\016 \003(\002"
  "\022\030\n\013staticState\030\017 \001(\005H\007\210\001\001\022\026\n\tattrScore\030"
  "\020 \001(\002H\010\210\001\001B\t\n\007_cameraB\010\n\006_labelB\021\n\017_type"
  "ConfidenceB\026\n\024_existenceConfidenceB\010\n\006_b"
  "ox2DB\020\n\016_directionInfoB\017\n\r_positionInfoB"
  "\016\n\014_staticStateB\014\n\n_attrScore\"\372\001\n\006Bbox2D"
  "\022\030\n\013initialized\030\001 \001(\010H\000\210\001\001\022\025\n\010topLeftX\030\002"
  " \001(\002H\001\210\001\001\022\025\n\010topLeftY\030\003 \001(\002H\002\210\001\001\022\031\n\014bott"
  "omRightX\030\004 \001(\002H\003\210\001\001\022\031\n\014bottomRightY\030\005 \001("
  "\002H\004\210\001\001\022\027\n\nconfidence\030\006 \001(\002H\005\210\001\001B\016\n\014_init"
  "ializedB\013\n\t_topLeftXB\013\n\t_topLeftYB\017\n\r_bo"
  "ttomRightXB\017\n\r_bottomRightYB\r\n\013_confiden"
  "ce\"\255\003\n\rDirectionInfo\022\024\n\007isValid\030\001 \001(\010H\000\210"
  "\001\001\022\'\n\014directionYpr\030\002 \001(\0132\014.od.Vector3fH\001"
  "\210\001\001\0222\n\027directionYprUncertainty\030\003 \001(\0132\014.o"
  "d.Matrix3fH\002\210\001\001\022\020\n\003yaw\030\004 \001(\002H\003\210\001\001\022\033\n\016yaw"
  "Uncertainty\030\005 \001(\002H\004\210\001\001\022\024\n\007yawRate\030\006 \001(\002H"
  "\005\210\001\001\022\037\n\022yawRateUncertainty\030\007 \001(\002H\006\210\001\001\022\024\n"
  "\007surface\030\010 \001(\005H\007\210\001\001\022\031\n\014surfaceScore\030\t \001("
  "\002H\010\210\001\001B\n\n\010_isValidB\017\n\r_directionYprB\032\n\030_"
  "directionYprUncertaintyB\006\n\004_yawB\021\n\017_yawU"
  "ncertaintyB\n\n\010_yawRateB\025\n\023_yawRateUncert"
  "aintyB\n\n\010_surfaceB\017\n\r_surfaceScore\"\322\001\n\010U"
  "ssRange\022\027\n\ndistanceId\030\001 \001(\tH\000\210\001\001\022\027\n\nrecv"
  "TimeNs\030\002 \001(\004H\001\210\001\001\022\025\n\010distance\030\003 \001(\rH\002\210\001\001"
  "\022\024\n\007isValid\030\004 \001(\010H\003\210\001\001\022#\n\010position\030\005 \001(\013"
  "2\014.od.Vector3fH\004\210\001\001B\r\n\013_distanceIdB\r\n\013_r"
  "ecvTimeNsB\013\n\t_distanceB\n\n\010_isValidB\013\n\t_p"
  "osition\"b\n\014PositionInfo\022\024\n\007isValid\030\001 \001(\010"
  "H\000\210\001\001\022#\n\010position\030\002 \001(\0132\014.od.Vector3fH\001\210"
  "\001\001B\n\n\010_isValidB\013\n\t_position\"*\n\006FSLine\022 \n"
  "\006fsLine\030\001 \003(\0132\020.od.FSLinesimple\"\225\001\n\014FSLi"
  "nesimple\022\037\n\006header\030\001 \001(\0132\n.od.HeaderH\000\210\001"
  "\001\022\035\n\020frameTimestampNs\030\002 \001(\004H\001\210\001\001\022%\n\014fsLi"
  "nepoints\030\003 \003(\0132\017.od.FSLinePointB\t\n\007_head"
  "erB\023\n\021_frameTimestampNs\"z\n\013FSLinePoint\022$"
  "\n\ncoordinate\030\001 \001(\0132\013.od.Point2fH\000\210\001\001\022\'\n\n"
  "pointLabel\030\002 \001(\0162\016.od.SpaceLabelH\001\210\001\001B\r\n"
  "\013_coordinateB\r\n\013_pointLabel*2\n\014MotionSta"
  "tus\022\013\n\007Unknown\020\000\022\n\n\006Moving\020\001\022\t\n\005Still\020\002*"
  "]\n\nSpaceLabel\022\013\n\007vehicle\020\000\022\016\n\npedestrian"
  "\020\001\022\014\n\010RoadEdge\020\002\022\010\n\004Wall\020\003\022\017\n\013TrafficCon"
  "e\020\004\022\t\n\005Other\020\005b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_od_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_od_2eproto = {
  false, false, 5022, descriptor_table_protodef_od_2eproto, "od.proto", 
  &descriptor_table_od_2eproto_once, nullptr, 0, 20,
  schemas, file_default_instances, TableStruct_od_2eproto::offsets,
  file_level_metadata_od_2eproto, file_level_enum_descriptors_od_2eproto, file_level_service_descriptors_od_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_od_2eproto_getter() {
  return &descriptor_table_od_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_od_2eproto(&descriptor_table_od_2eproto);
namespace od {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_od_2eproto);
  return file_level_enum_descriptors_od_2eproto[0];
}
bool MotionStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpaceLabel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_od_2eproto);
  return file_level_enum_descriptors_od_2eproto[1];
}
bool SpaceLabel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Obstacles::_Internal {
 public:
  using HasBits = decltype(std::declval<Obstacles>()._has_bits_);
  static const ::od::Header& header(const Obstacles* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::od::Header&
Obstacles::_Internal::header(const Obstacles* msg) {
  return *msg->header_;
}
Obstacles::Obstacles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  cylindricalobstalces_(arena),
  cubeobstacles_(arena),
  rawobjects_(arena),
  rangeunitarray_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.Obstacles)
}
Obstacles::Obstacles(const Obstacles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      cylindricalobstalces_(from.cylindricalobstalces_),
      cubeobstacles_(from.cubeobstacles_),
      rawobjects_(from.rawobjects_),
      rangeunitarray_(from.rangeunitarray_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::od::Header(*from.header_);
  } else {
    header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:od.Obstacles)
}

inline void Obstacles::SharedCtor() {
header_ = nullptr;
}

Obstacles::~Obstacles() {
  // @@protoc_insertion_point(destructor:od.Obstacles)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Obstacles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_;
}

void Obstacles::ArenaDtor(void* object) {
  Obstacles* _this = reinterpret_cast< Obstacles* >(object);
  (void)_this;
}
void Obstacles::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Obstacles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Obstacles::Clear() {
// @@protoc_insertion_point(message_clear_start:od.Obstacles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cylindricalobstalces_.Clear();
  cubeobstacles_.Clear();
  rawobjects_.Clear();
  rangeunitarray_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(header_ != nullptr);
    header_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Obstacles::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .od.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .od.ObstacleCylindrical cylindricalObstalces = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cylindricalobstalces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .od.ObstacleCube cubeObstacles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cubeobstacles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .od.ObstacleRaw rawObjects = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rawobjects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .od.UssRange rangeUnitArray = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rangeunitarray(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Obstacles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.Obstacles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .od.Header header = 1;
  if (_internal_has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // repeated .od.ObstacleCylindrical cylindricalObstalces = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cylindricalobstalces_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_cylindricalobstalces(i), target, stream);
  }

  // repeated .od.ObstacleCube cubeObstacles = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cubeobstacles_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_cubeobstacles(i), target, stream);
  }

  // repeated .od.ObstacleRaw rawObjects = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_rawobjects_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_rawobjects(i), target, stream);
  }

  // repeated .od.UssRange rangeUnitArray = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_rangeunitarray_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_rangeunitarray(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.Obstacles)
  return target;
}

size_t Obstacles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.Obstacles)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .od.ObstacleCylindrical cylindricalObstalces = 2;
  total_size += 1UL * this->_internal_cylindricalobstalces_size();
  for (const auto& msg : this->cylindricalobstalces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .od.ObstacleCube cubeObstacles = 3;
  total_size += 1UL * this->_internal_cubeobstacles_size();
  for (const auto& msg : this->cubeobstacles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .od.ObstacleRaw rawObjects = 4;
  total_size += 1UL * this->_internal_rawobjects_size();
  for (const auto& msg : this->rawobjects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .od.UssRange rangeUnitArray = 5;
  total_size += 1UL * this->_internal_rangeunitarray_size();
  for (const auto& msg : this->rangeunitarray_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .od.Header header = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Obstacles::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Obstacles::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Obstacles::GetClassData() const { return &_class_data_; }

void Obstacles::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Obstacles *>(to)->MergeFrom(
      static_cast<const Obstacles &>(from));
}


void Obstacles::MergeFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.Obstacles)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cylindricalobstalces_.MergeFrom(from.cylindricalobstalces_);
  cubeobstacles_.MergeFrom(from.cubeobstacles_);
  rawobjects_.MergeFrom(from.rawobjects_);
  rangeunitarray_.MergeFrom(from.rangeunitarray_);
  if (from._internal_has_header()) {
    _internal_mutable_header()->::od::Header::MergeFrom(from._internal_header());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Obstacles::CopyFrom(const Obstacles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.Obstacles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacles::IsInitialized() const {
  return true;
}

void Obstacles::InternalSwap(Obstacles* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  cylindricalobstalces_.InternalSwap(&other->cylindricalobstalces_);
  cubeobstacles_.InternalSwap(&other->cubeobstacles_);
  rawobjects_.InternalSwap(&other->rawobjects_);
  rangeunitarray_.InternalSwap(&other->rangeunitarray_);
  swap(header_, other->header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Obstacles::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[0]);
}

// ===================================================================

class Header::_Internal {
 public:
  using HasBits = decltype(std::declval<Header>()._has_bits_);
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::od::Time& timestampns(const Header* msg);
  static void set_has_timestampns(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_frameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::od::Time&
Header::_Internal::timestampns(const Header* msg) {
  return *msg->timestampns_;
}
Header::Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.Header)
}
Header::Header(const Header& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  frameid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    frameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_frameid()) {
    frameid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_frameid(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_timestampns()) {
    timestampns_ = new ::od::Time(*from.timestampns_);
  } else {
    timestampns_ = nullptr;
  }
  seq_ = from.seq_;
  // @@protoc_insertion_point(copy_constructor:od.Header)
}

inline void Header::SharedCtor() {
frameid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  frameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestampns_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seq_) -
    reinterpret_cast<char*>(&timestampns_)) + sizeof(seq_));
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:od.Header)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Header::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  frameid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete timestampns_;
}

void Header::ArenaDtor(void* object) {
  Header* _this = reinterpret_cast< Header* >(object);
  (void)_this;
}
void Header::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Header::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:od.Header)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      frameid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(timestampns_ != nullptr);
      timestampns_->Clear();
    }
  }
  seq_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Header::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 seq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seq(&has_bits);
          seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Time timestampNs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestampns(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string frameId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_frameid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "od.Header.frameId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Header::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.Header)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 seq = 1;
  if (_internal_has_seq()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_seq(), target);
  }

  // optional .od.Time timestampNs = 2;
  if (_internal_has_timestampns()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::timestampns(this), target, stream);
  }

  // optional string frameId = 3;
  if (_internal_has_frameid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_frameid().data(), static_cast<int>(this->_internal_frameid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "od.Header.frameId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_frameid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.Header)
  return target;
}

size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.Header)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string frameId = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_frameid());
    }

    // optional .od.Time timestampNs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *timestampns_);
    }

    // optional uint32 seq = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_seq());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Header::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Header::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Header::GetClassData() const { return &_class_data_; }

void Header::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Header *>(to)->MergeFrom(
      static_cast<const Header &>(from));
}


void Header::MergeFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.Header)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_frameid(from._internal_frameid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_timestampns()->::od::Time::MergeFrom(from._internal_timestampns());
    }
    if (cached_has_bits & 0x00000004u) {
      seq_ = from.seq_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  return true;
}

void Header::InternalSwap(Header* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &frameid_, lhs_arena,
      &other->frameid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Header, seq_)
      + sizeof(Header::seq_)
      - PROTOBUF_FIELD_OFFSET(Header, timestampns_)>(
          reinterpret_cast<char*>(&timestampns_),
          reinterpret_cast<char*>(&other->timestampns_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Header::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[1]);
}

// ===================================================================

class Time::_Internal {
 public:
  using HasBits = decltype(std::declval<Time>()._has_bits_);
  static void set_has_nanosec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Time::Time(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.Time)
}
Time::Time(const Time& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nanosec_ = from.nanosec_;
  // @@protoc_insertion_point(copy_constructor:od.Time)
}

inline void Time::SharedCtor() {
nanosec_ = uint64_t{0u};
}

Time::~Time() {
  // @@protoc_insertion_point(destructor:od.Time)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Time::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Time::ArenaDtor(void* object) {
  Time* _this = reinterpret_cast< Time* >(object);
  (void)_this;
}
void Time::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Time::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Time::Clear() {
// @@protoc_insertion_point(message_clear_start:od.Time)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nanosec_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Time::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 nanoSec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_nanosec(&has_bits);
          nanosec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Time::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.Time)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint64 nanoSec = 1;
  if (_internal_has_nanosec()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_nanosec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.Time)
  return target;
}

size_t Time::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.Time)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 nanoSec = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_nanosec());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Time::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Time::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Time::GetClassData() const { return &_class_data_; }

void Time::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Time *>(to)->MergeFrom(
      static_cast<const Time &>(from));
}


void Time::MergeFrom(const Time& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.Time)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nanosec()) {
    _internal_set_nanosec(from._internal_nanosec());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Time::CopyFrom(const Time& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.Time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Time::IsInitialized() const {
  return true;
}

void Time::InternalSwap(Time* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(nanosec_, other->nanosec_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Time::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[2]);
}

// ===================================================================

class ObstacleCylindrical::_Internal {
 public:
  using HasBits = decltype(std::declval<ObstacleCylindrical>()._has_bits_);
  static void set_has_camera(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_typeconfidence(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_existenceconfidence(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_trackid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::od::Vector3d& center(const ObstacleCylindrical* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::od::Vector3d& direction(const ObstacleCylindrical* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::od::MotionInfo& motioninfo(const ObstacleCylindrical* msg);
  static void set_has_motioninfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_staticstate(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_attrscore(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::od::Vector3d&
ObstacleCylindrical::_Internal::center(const ObstacleCylindrical* msg) {
  return *msg->center_;
}
const ::od::Vector3d&
ObstacleCylindrical::_Internal::direction(const ObstacleCylindrical* msg) {
  return *msg->direction_;
}
const ::od::MotionInfo&
ObstacleCylindrical::_Internal::motioninfo(const ObstacleCylindrical* msg) {
  return *msg->motioninfo_;
}
ObstacleCylindrical::ObstacleCylindrical(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  trajectory_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.ObstacleCylindrical)
}
ObstacleCylindrical::ObstacleCylindrical(const ObstacleCylindrical& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      trajectory_(from.trajectory_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  camera_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_camera()) {
    camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_camera(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_center()) {
    center_ = new ::od::Vector3d(*from.center_);
  } else {
    center_ = nullptr;
  }
  if (from._internal_has_direction()) {
    direction_ = new ::od::Vector3d(*from.direction_);
  } else {
    direction_ = nullptr;
  }
  if (from._internal_has_motioninfo()) {
    motioninfo_ = new ::od::MotionInfo(*from.motioninfo_);
  } else {
    motioninfo_ = nullptr;
  }
  ::memcpy(&label_, &from.label_,
    static_cast<size_t>(reinterpret_cast<char*>(&attrscore_) -
    reinterpret_cast<char*>(&label_)) + sizeof(attrscore_));
  // @@protoc_insertion_point(copy_constructor:od.ObstacleCylindrical)
}

inline void ObstacleCylindrical::SharedCtor() {
camera_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&center_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&attrscore_) -
    reinterpret_cast<char*>(&center_)) + sizeof(attrscore_));
}

ObstacleCylindrical::~ObstacleCylindrical() {
  // @@protoc_insertion_point(destructor:od.ObstacleCylindrical)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObstacleCylindrical::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  camera_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete center_;
  if (this != internal_default_instance()) delete direction_;
  if (this != internal_default_instance()) delete motioninfo_;
}

void ObstacleCylindrical::ArenaDtor(void* object) {
  ObstacleCylindrical* _this = reinterpret_cast< ObstacleCylindrical* >(object);
  (void)_this;
}
void ObstacleCylindrical::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObstacleCylindrical::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObstacleCylindrical::Clear() {
// @@protoc_insertion_point(message_clear_start:od.ObstacleCylindrical)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trajectory_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      camera_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(center_ != nullptr);
      center_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(direction_ != nullptr);
      direction_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(motioninfo_ != nullptr);
      motioninfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&label_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&trackid_) -
        reinterpret_cast<char*>(&label_)) + sizeof(trackid_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&radius_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&attrscore_) -
        reinterpret_cast<char*>(&radius_)) + sizeof(attrscore_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObstacleCylindrical::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string camera = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_camera();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "od.ObstacleCylindrical.camera"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_label(&has_bits);
          label_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float typeConfidence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_typeconfidence(&has_bits);
          typeconfidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float existenceConfidence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_existenceconfidence(&has_bits);
          existenceconfidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 trackId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_trackid(&has_bits);
          trackid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3d Center = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float radius = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float height = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3d direction = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_direction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.MotionInfo motionInfo = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_motioninfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .od.ObstacleTrajectory trajectory = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trajectory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 staticState = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_staticstate(&has_bits);
          staticstate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float attrScore = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_attrscore(&has_bits);
          attrscore_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObstacleCylindrical::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.ObstacleCylindrical)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string camera = 1;
  if (_internal_has_camera()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_camera().data(), static_cast<int>(this->_internal_camera().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "od.ObstacleCylindrical.camera");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_camera(), target);
  }

  // optional int32 label = 2;
  if (_internal_has_label()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_label(), target);
  }

  // optional float typeConfidence = 3;
  if (_internal_has_typeconfidence()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_typeconfidence(), target);
  }

  // optional float existenceConfidence = 4;
  if (_internal_has_existenceconfidence()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_existenceconfidence(), target);
  }

  // optional int32 trackId = 5;
  if (_internal_has_trackid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_trackid(), target);
  }

  // optional .od.Vector3d Center = 6;
  if (_internal_has_center()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::center(this), target, stream);
  }

  // optional float radius = 7;
  if (_internal_has_radius()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_radius(), target);
  }

  // optional float height = 8;
  if (_internal_has_height()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_height(), target);
  }

  // optional .od.Vector3d direction = 9;
  if (_internal_has_direction()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::direction(this), target, stream);
  }

  // optional .od.MotionInfo motionInfo = 10;
  if (_internal_has_motioninfo()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::motioninfo(this), target, stream);
  }

  // repeated .od.ObstacleTrajectory trajectory = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_trajectory_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_trajectory(i), target, stream);
  }

  // optional int32 staticState = 12;
  if (_internal_has_staticstate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_staticstate(), target);
  }

  // optional float attrScore = 13;
  if (_internal_has_attrscore()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_attrscore(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.ObstacleCylindrical)
  return target;
}

size_t ObstacleCylindrical::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.ObstacleCylindrical)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .od.ObstacleTrajectory trajectory = 11;
  total_size += 1UL * this->_internal_trajectory_size();
  for (const auto& msg : this->trajectory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string camera = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_camera());
    }

    // optional .od.Vector3d Center = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *center_);
    }

    // optional .od.Vector3d direction = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *direction_);
    }

    // optional .od.MotionInfo motionInfo = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *motioninfo_);
    }

    // optional int32 label = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_label());
    }

    // optional float typeConfidence = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float existenceConfidence = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional int32 trackId = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_trackid());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional float radius = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float height = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional int32 staticState = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_staticstate());
    }

    // optional float attrScore = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObstacleCylindrical::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObstacleCylindrical::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObstacleCylindrical::GetClassData() const { return &_class_data_; }

void ObstacleCylindrical::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObstacleCylindrical *>(to)->MergeFrom(
      static_cast<const ObstacleCylindrical &>(from));
}


void ObstacleCylindrical::MergeFrom(const ObstacleCylindrical& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.ObstacleCylindrical)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  trajectory_.MergeFrom(from.trajectory_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_camera(from._internal_camera());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_center()->::od::Vector3d::MergeFrom(from._internal_center());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_direction()->::od::Vector3d::MergeFrom(from._internal_direction());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_motioninfo()->::od::MotionInfo::MergeFrom(from._internal_motioninfo());
    }
    if (cached_has_bits & 0x00000010u) {
      label_ = from.label_;
    }
    if (cached_has_bits & 0x00000020u) {
      typeconfidence_ = from.typeconfidence_;
    }
    if (cached_has_bits & 0x00000040u) {
      existenceconfidence_ = from.existenceconfidence_;
    }
    if (cached_has_bits & 0x00000080u) {
      trackid_ = from.trackid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      radius_ = from.radius_;
    }
    if (cached_has_bits & 0x00000200u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000400u) {
      staticstate_ = from.staticstate_;
    }
    if (cached_has_bits & 0x00000800u) {
      attrscore_ = from.attrscore_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObstacleCylindrical::CopyFrom(const ObstacleCylindrical& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.ObstacleCylindrical)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleCylindrical::IsInitialized() const {
  return true;
}

void ObstacleCylindrical::InternalSwap(ObstacleCylindrical* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  trajectory_.InternalSwap(&other->trajectory_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &camera_, lhs_arena,
      &other->camera_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObstacleCylindrical, attrscore_)
      + sizeof(ObstacleCylindrical::attrscore_)
      - PROTOBUF_FIELD_OFFSET(ObstacleCylindrical, center_)>(
          reinterpret_cast<char*>(&center_),
          reinterpret_cast<char*>(&other->center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObstacleCylindrical::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[3]);
}

// ===================================================================

class Vector3d::_Internal {
 public:
  using HasBits = decltype(std::declval<Vector3d>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Vector3d::Vector3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.Vector3d)
}
Vector3d::Vector3d(const Vector3d& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:od.Vector3d)
}

inline void Vector3d::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Vector3d::~Vector3d() {
  // @@protoc_insertion_point(destructor:od.Vector3d)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Vector3d::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector3d::ArenaDtor(void* object) {
  Vector3d* _this = reinterpret_cast< Vector3d* >(object);
  (void)_this;
}
void Vector3d::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Vector3d::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Vector3d::Clear() {
// @@protoc_insertion_point(message_clear_start:od.Vector3d)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector3d::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vector3d::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.Vector3d)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // optional float z = 3;
  if (_internal_has_z()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.Vector3d)
  return target;
}

size_t Vector3d::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.Vector3d)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector3d::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Vector3d::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector3d::GetClassData() const { return &_class_data_; }

void Vector3d::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Vector3d *>(to)->MergeFrom(
      static_cast<const Vector3d &>(from));
}


void Vector3d::MergeFrom(const Vector3d& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.Vector3d)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector3d::CopyFrom(const Vector3d& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.Vector3d)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector3d::IsInitialized() const {
  return true;
}

void Vector3d::InternalSwap(Vector3d* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector3d, z_)
      + sizeof(Vector3d::z_)
      - PROTOBUF_FIELD_OFFSET(Vector3d, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector3d::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[4]);
}

// ===================================================================

class MotionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionInfo>()._has_bits_);
  static void set_has_isvalid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_motionstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::od::Vector3d& center(const MotionInfo* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::od::Matrix3f& centeruncertainty(const MotionInfo* msg);
  static void set_has_centeruncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::od::Vector3d& velocity(const MotionInfo* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::od::Matrix3f& velocityuncertainty(const MotionInfo* msg);
  static void set_has_velocityuncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::od::Vector3d& acceleration(const MotionInfo* msg);
  static void set_has_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::od::Matrix3f& accelerationuncertainty(const MotionInfo* msg);
  static void set_has_accelerationuncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::od::Vector3f& jerk(const MotionInfo* msg);
  static void set_has_jerk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::od::Matrix3f& jerkuncertainty(const MotionInfo* msg);
  static void set_has_jerkuncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_velocityheading(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_velocityheadinguncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_velocityheadingrate(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_velocityheadingrateuncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

const ::od::Vector3d&
MotionInfo::_Internal::center(const MotionInfo* msg) {
  return *msg->center_;
}
const ::od::Matrix3f&
MotionInfo::_Internal::centeruncertainty(const MotionInfo* msg) {
  return *msg->centeruncertainty_;
}
const ::od::Vector3d&
MotionInfo::_Internal::velocity(const MotionInfo* msg) {
  return *msg->velocity_;
}
const ::od::Matrix3f&
MotionInfo::_Internal::velocityuncertainty(const MotionInfo* msg) {
  return *msg->velocityuncertainty_;
}
const ::od::Vector3d&
MotionInfo::_Internal::acceleration(const MotionInfo* msg) {
  return *msg->acceleration_;
}
const ::od::Matrix3f&
MotionInfo::_Internal::accelerationuncertainty(const MotionInfo* msg) {
  return *msg->accelerationuncertainty_;
}
const ::od::Vector3f&
MotionInfo::_Internal::jerk(const MotionInfo* msg) {
  return *msg->jerk_;
}
const ::od::Matrix3f&
MotionInfo::_Internal::jerkuncertainty(const MotionInfo* msg) {
  return *msg->jerkuncertainty_;
}
MotionInfo::MotionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.MotionInfo)
}
MotionInfo::MotionInfo(const MotionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_center()) {
    center_ = new ::od::Vector3d(*from.center_);
  } else {
    center_ = nullptr;
  }
  if (from._internal_has_centeruncertainty()) {
    centeruncertainty_ = new ::od::Matrix3f(*from.centeruncertainty_);
  } else {
    centeruncertainty_ = nullptr;
  }
  if (from._internal_has_velocity()) {
    velocity_ = new ::od::Vector3d(*from.velocity_);
  } else {
    velocity_ = nullptr;
  }
  if (from._internal_has_velocityuncertainty()) {
    velocityuncertainty_ = new ::od::Matrix3f(*from.velocityuncertainty_);
  } else {
    velocityuncertainty_ = nullptr;
  }
  if (from._internal_has_acceleration()) {
    acceleration_ = new ::od::Vector3d(*from.acceleration_);
  } else {
    acceleration_ = nullptr;
  }
  if (from._internal_has_accelerationuncertainty()) {
    accelerationuncertainty_ = new ::od::Matrix3f(*from.accelerationuncertainty_);
  } else {
    accelerationuncertainty_ = nullptr;
  }
  if (from._internal_has_jerk()) {
    jerk_ = new ::od::Vector3f(*from.jerk_);
  } else {
    jerk_ = nullptr;
  }
  if (from._internal_has_jerkuncertainty()) {
    jerkuncertainty_ = new ::od::Matrix3f(*from.jerkuncertainty_);
  } else {
    jerkuncertainty_ = nullptr;
  }
  ::memcpy(&isvalid_, &from.isvalid_,
    static_cast<size_t>(reinterpret_cast<char*>(&velocityheadingrateuncertainty_) -
    reinterpret_cast<char*>(&isvalid_)) + sizeof(velocityheadingrateuncertainty_));
  // @@protoc_insertion_point(copy_constructor:od.MotionInfo)
}

inline void MotionInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&center_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&velocityheadingrateuncertainty_) -
    reinterpret_cast<char*>(&center_)) + sizeof(velocityheadingrateuncertainty_));
}

MotionInfo::~MotionInfo() {
  // @@protoc_insertion_point(destructor:od.MotionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MotionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete center_;
  if (this != internal_default_instance()) delete centeruncertainty_;
  if (this != internal_default_instance()) delete velocity_;
  if (this != internal_default_instance()) delete velocityuncertainty_;
  if (this != internal_default_instance()) delete acceleration_;
  if (this != internal_default_instance()) delete accelerationuncertainty_;
  if (this != internal_default_instance()) delete jerk_;
  if (this != internal_default_instance()) delete jerkuncertainty_;
}

void MotionInfo::ArenaDtor(void* object) {
  MotionInfo* _this = reinterpret_cast< MotionInfo* >(object);
  (void)_this;
}
void MotionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:od.MotionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(center_ != nullptr);
      center_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(centeruncertainty_ != nullptr);
      centeruncertainty_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(velocity_ != nullptr);
      velocity_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(velocityuncertainty_ != nullptr);
      velocityuncertainty_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(acceleration_ != nullptr);
      acceleration_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(accelerationuncertainty_ != nullptr);
      accelerationuncertainty_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(jerk_ != nullptr);
      jerk_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(jerkuncertainty_ != nullptr);
      jerkuncertainty_->Clear();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&isvalid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&velocityheadingrateuncertainty_) -
        reinterpret_cast<char*>(&isvalid_)) + sizeof(velocityheadingrateuncertainty_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool isValid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_isvalid(&has_bits);
          isvalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 motionStatus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_motionstatus(&has_bits);
          motionstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3d center = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Matrix3f centerUncertainty = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_centeruncertainty(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3d velocity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Matrix3f velocityUncertainty = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocityuncertainty(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3d acceleration = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_acceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Matrix3f accelerationUncertainty = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_accelerationuncertainty(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3f jerk = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_jerk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Matrix3f jerkUncertainty = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_jerkuncertainty(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float velocityHeading = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_velocityheading(&has_bits);
          velocityheading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float velocityHeadingUncertainty = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_velocityheadinguncertainty(&has_bits);
          velocityheadinguncertainty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float velocityHeadingRate = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_velocityheadingrate(&has_bits);
          velocityheadingrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float velocityHeadingRateUncertainty = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_velocityheadingrateuncertainty(&has_bits);
          velocityheadingrateuncertainty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MotionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.MotionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool isValid = 1;
  if (_internal_has_isvalid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_isvalid(), target);
  }

  // optional int32 motionStatus = 2;
  if (_internal_has_motionstatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_motionstatus(), target);
  }

  // optional .od.Vector3d center = 3;
  if (_internal_has_center()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::center(this), target, stream);
  }

  // optional .od.Matrix3f centerUncertainty = 4;
  if (_internal_has_centeruncertainty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::centeruncertainty(this), target, stream);
  }

  // optional .od.Vector3d velocity = 5;
  if (_internal_has_velocity()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::velocity(this), target, stream);
  }

  // optional .od.Matrix3f velocityUncertainty = 6;
  if (_internal_has_velocityuncertainty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::velocityuncertainty(this), target, stream);
  }

  // optional .od.Vector3d acceleration = 7;
  if (_internal_has_acceleration()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::acceleration(this), target, stream);
  }

  // optional .od.Matrix3f accelerationUncertainty = 8;
  if (_internal_has_accelerationuncertainty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::accelerationuncertainty(this), target, stream);
  }

  // optional .od.Vector3f jerk = 9;
  if (_internal_has_jerk()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::jerk(this), target, stream);
  }

  // optional .od.Matrix3f jerkUncertainty = 10;
  if (_internal_has_jerkuncertainty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::jerkuncertainty(this), target, stream);
  }

  // optional float velocityHeading = 11;
  if (_internal_has_velocityheading()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_velocityheading(), target);
  }

  // optional float velocityHeadingUncertainty = 12;
  if (_internal_has_velocityheadinguncertainty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_velocityheadinguncertainty(), target);
  }

  // optional float velocityHeadingRate = 13;
  if (_internal_has_velocityheadingrate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_velocityheadingrate(), target);
  }

  // optional float velocityHeadingRateUncertainty = 14;
  if (_internal_has_velocityheadingrateuncertainty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_velocityheadingrateuncertainty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.MotionInfo)
  return target;
}

size_t MotionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.MotionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .od.Vector3d center = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *center_);
    }

    // optional .od.Matrix3f centerUncertainty = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *centeruncertainty_);
    }

    // optional .od.Vector3d velocity = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *velocity_);
    }

    // optional .od.Matrix3f velocityUncertainty = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *velocityuncertainty_);
    }

    // optional .od.Vector3d acceleration = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *acceleration_);
    }

    // optional .od.Matrix3f accelerationUncertainty = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *accelerationuncertainty_);
    }

    // optional .od.Vector3f jerk = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *jerk_);
    }

    // optional .od.Matrix3f jerkUncertainty = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *jerkuncertainty_);
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional bool isValid = 1;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int32 motionStatus = 2;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_motionstatus());
    }

    // optional float velocityHeading = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float velocityHeadingUncertainty = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float velocityHeadingRate = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float velocityHeadingRateUncertainty = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MotionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotionInfo::GetClassData() const { return &_class_data_; }

void MotionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MotionInfo *>(to)->MergeFrom(
      static_cast<const MotionInfo &>(from));
}


void MotionInfo::MergeFrom(const MotionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.MotionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_center()->::od::Vector3d::MergeFrom(from._internal_center());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_centeruncertainty()->::od::Matrix3f::MergeFrom(from._internal_centeruncertainty());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_velocity()->::od::Vector3d::MergeFrom(from._internal_velocity());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_velocityuncertainty()->::od::Matrix3f::MergeFrom(from._internal_velocityuncertainty());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_acceleration()->::od::Vector3d::MergeFrom(from._internal_acceleration());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_accelerationuncertainty()->::od::Matrix3f::MergeFrom(from._internal_accelerationuncertainty());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_jerk()->::od::Vector3f::MergeFrom(from._internal_jerk());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_jerkuncertainty()->::od::Matrix3f::MergeFrom(from._internal_jerkuncertainty());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      isvalid_ = from.isvalid_;
    }
    if (cached_has_bits & 0x00000200u) {
      motionstatus_ = from.motionstatus_;
    }
    if (cached_has_bits & 0x00000400u) {
      velocityheading_ = from.velocityheading_;
    }
    if (cached_has_bits & 0x00000800u) {
      velocityheadinguncertainty_ = from.velocityheadinguncertainty_;
    }
    if (cached_has_bits & 0x00001000u) {
      velocityheadingrate_ = from.velocityheadingrate_;
    }
    if (cached_has_bits & 0x00002000u) {
      velocityheadingrateuncertainty_ = from.velocityheadingrateuncertainty_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotionInfo::CopyFrom(const MotionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.MotionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionInfo::IsInitialized() const {
  return true;
}

void MotionInfo::InternalSwap(MotionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MotionInfo, velocityheadingrateuncertainty_)
      + sizeof(MotionInfo::velocityheadingrateuncertainty_)
      - PROTOBUF_FIELD_OFFSET(MotionInfo, center_)>(
          reinterpret_cast<char*>(&center_),
          reinterpret_cast<char*>(&other->center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[5]);
}

// ===================================================================

class Point2f::_Internal {
 public:
  using HasBits = decltype(std::declval<Point2f>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Point2f::Point2f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.Point2f)
}
Point2f::Point2f(const Point2f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:od.Point2f)
}

inline void Point2f::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

Point2f::~Point2f() {
  // @@protoc_insertion_point(destructor:od.Point2f)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Point2f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Point2f::ArenaDtor(void* object) {
  Point2f* _this = reinterpret_cast< Point2f* >(object);
  (void)_this;
}
void Point2f::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Point2f::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Point2f::Clear() {
// @@protoc_insertion_point(message_clear_start:od.Point2f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Point2f::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Point2f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.Point2f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.Point2f)
  return target;
}

size_t Point2f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.Point2f)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Point2f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Point2f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Point2f::GetClassData() const { return &_class_data_; }

void Point2f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Point2f *>(to)->MergeFrom(
      static_cast<const Point2f &>(from));
}


void Point2f::MergeFrom(const Point2f& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.Point2f)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Point2f::CopyFrom(const Point2f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.Point2f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point2f::IsInitialized() const {
  return true;
}

void Point2f::InternalSwap(Point2f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Point2f, y_)
      + sizeof(Point2f::y_)
      - PROTOBUF_FIELD_OFFSET(Point2f, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Point2f::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[6]);
}

// ===================================================================

class Vector3f::_Internal {
 public:
  using HasBits = decltype(std::declval<Vector3f>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Vector3f::Vector3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.Vector3f)
}
Vector3f::Vector3f(const Vector3f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:od.Vector3f)
}

inline void Vector3f::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Vector3f::~Vector3f() {
  // @@protoc_insertion_point(destructor:od.Vector3f)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Vector3f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Vector3f::ArenaDtor(void* object) {
  Vector3f* _this = reinterpret_cast< Vector3f* >(object);
  (void)_this;
}
void Vector3f::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Vector3f::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Vector3f::Clear() {
// @@protoc_insertion_point(message_clear_start:od.Vector3f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector3f::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vector3f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.Vector3f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // optional float z = 3;
  if (_internal_has_z()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.Vector3f)
  return target;
}

size_t Vector3f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.Vector3f)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vector3f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Vector3f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vector3f::GetClassData() const { return &_class_data_; }

void Vector3f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Vector3f *>(to)->MergeFrom(
      static_cast<const Vector3f &>(from));
}


void Vector3f::MergeFrom(const Vector3f& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.Vector3f)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vector3f::CopyFrom(const Vector3f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.Vector3f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector3f::IsInitialized() const {
  return true;
}

void Vector3f::InternalSwap(Vector3f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector3f, z_)
      + sizeof(Vector3f::z_)
      - PROTOBUF_FIELD_OFFSET(Vector3f, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector3f::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[7]);
}

// ===================================================================

class Matrix3f::_Internal {
 public:
  using HasBits = decltype(std::declval<Matrix3f>()._has_bits_);
  static const ::od::Vector3f& x(const Matrix3f* msg);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::od::Vector3f& y(const Matrix3f* msg);
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::od::Vector3f& z(const Matrix3f* msg);
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::od::Vector3f&
Matrix3f::_Internal::x(const Matrix3f* msg) {
  return *msg->x_;
}
const ::od::Vector3f&
Matrix3f::_Internal::y(const Matrix3f* msg) {
  return *msg->y_;
}
const ::od::Vector3f&
Matrix3f::_Internal::z(const Matrix3f* msg) {
  return *msg->z_;
}
Matrix3f::Matrix3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.Matrix3f)
}
Matrix3f::Matrix3f(const Matrix3f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_x()) {
    x_ = new ::od::Vector3f(*from.x_);
  } else {
    x_ = nullptr;
  }
  if (from._internal_has_y()) {
    y_ = new ::od::Vector3f(*from.y_);
  } else {
    y_ = nullptr;
  }
  if (from._internal_has_z()) {
    z_ = new ::od::Vector3f(*from.z_);
  } else {
    z_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:od.Matrix3f)
}

inline void Matrix3f::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Matrix3f::~Matrix3f() {
  // @@protoc_insertion_point(destructor:od.Matrix3f)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Matrix3f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete x_;
  if (this != internal_default_instance()) delete y_;
  if (this != internal_default_instance()) delete z_;
}

void Matrix3f::ArenaDtor(void* object) {
  Matrix3f* _this = reinterpret_cast< Matrix3f* >(object);
  (void)_this;
}
void Matrix3f::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Matrix3f::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Matrix3f::Clear() {
// @@protoc_insertion_point(message_clear_start:od.Matrix3f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(x_ != nullptr);
      x_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(y_ != nullptr);
      y_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(z_ != nullptr);
      z_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Matrix3f::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .od.Vector3f x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_x(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3f y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_y(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3f z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_z(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Matrix3f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.Matrix3f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .od.Vector3f x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::x(this), target, stream);
  }

  // optional .od.Vector3f y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::y(this), target, stream);
  }

  // optional .od.Vector3f z = 3;
  if (_internal_has_z()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::z(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.Matrix3f)
  return target;
}

size_t Matrix3f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.Matrix3f)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .od.Vector3f x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *x_);
    }

    // optional .od.Vector3f y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *y_);
    }

    // optional .od.Vector3f z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *z_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Matrix3f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Matrix3f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Matrix3f::GetClassData() const { return &_class_data_; }

void Matrix3f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Matrix3f *>(to)->MergeFrom(
      static_cast<const Matrix3f &>(from));
}


void Matrix3f::MergeFrom(const Matrix3f& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.Matrix3f)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_x()->::od::Vector3f::MergeFrom(from._internal_x());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_y()->::od::Vector3f::MergeFrom(from._internal_y());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_z()->::od::Vector3f::MergeFrom(from._internal_z());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Matrix3f::CopyFrom(const Matrix3f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.Matrix3f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Matrix3f::IsInitialized() const {
  return true;
}

void Matrix3f::InternalSwap(Matrix3f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Matrix3f, z_)
      + sizeof(Matrix3f::z_)
      - PROTOBUF_FIELD_OFFSET(Matrix3f, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Matrix3f::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[8]);
}

// ===================================================================

class ObstacleCube::_Internal {
 public:
  using HasBits = decltype(std::declval<ObstacleCube>()._has_bits_);
  static void set_has_camera(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_typeconfidence(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_existenceconfidence(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_trackid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::od::Vector3d& center(const ObstacleCube* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::od::Vector3d& shape(const ObstacleCube* msg);
  static void set_has_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::od::Vector3d& direction(const ObstacleCube* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::od::MotionInfo& motioninfo(const ObstacleCube* msg);
  static void set_has_motioninfo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::od::Vector3d&
ObstacleCube::_Internal::center(const ObstacleCube* msg) {
  return *msg->center_;
}
const ::od::Vector3d&
ObstacleCube::_Internal::shape(const ObstacleCube* msg) {
  return *msg->shape_;
}
const ::od::Vector3d&
ObstacleCube::_Internal::direction(const ObstacleCube* msg) {
  return *msg->direction_;
}
const ::od::MotionInfo&
ObstacleCube::_Internal::motioninfo(const ObstacleCube* msg) {
  return *msg->motioninfo_;
}
ObstacleCube::ObstacleCube(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  trajectory_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.ObstacleCube)
}
ObstacleCube::ObstacleCube(const ObstacleCube& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      trajectory_(from.trajectory_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  camera_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_camera()) {
    camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_camera(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_center()) {
    center_ = new ::od::Vector3d(*from.center_);
  } else {
    center_ = nullptr;
  }
  if (from._internal_has_shape()) {
    shape_ = new ::od::Vector3d(*from.shape_);
  } else {
    shape_ = nullptr;
  }
  if (from._internal_has_direction()) {
    direction_ = new ::od::Vector3d(*from.direction_);
  } else {
    direction_ = nullptr;
  }
  if (from._internal_has_motioninfo()) {
    motioninfo_ = new ::od::MotionInfo(*from.motioninfo_);
  } else {
    motioninfo_ = nullptr;
  }
  ::memcpy(&label_, &from.label_,
    static_cast<size_t>(reinterpret_cast<char*>(&trackid_) -
    reinterpret_cast<char*>(&label_)) + sizeof(trackid_));
  // @@protoc_insertion_point(copy_constructor:od.ObstacleCube)
}

inline void ObstacleCube::SharedCtor() {
camera_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&center_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&trackid_) -
    reinterpret_cast<char*>(&center_)) + sizeof(trackid_));
}

ObstacleCube::~ObstacleCube() {
  // @@protoc_insertion_point(destructor:od.ObstacleCube)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObstacleCube::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  camera_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete center_;
  if (this != internal_default_instance()) delete shape_;
  if (this != internal_default_instance()) delete direction_;
  if (this != internal_default_instance()) delete motioninfo_;
}

void ObstacleCube::ArenaDtor(void* object) {
  ObstacleCube* _this = reinterpret_cast< ObstacleCube* >(object);
  (void)_this;
}
void ObstacleCube::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObstacleCube::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObstacleCube::Clear() {
// @@protoc_insertion_point(message_clear_start:od.ObstacleCube)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trajectory_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      camera_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(center_ != nullptr);
      center_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(shape_ != nullptr);
      shape_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(direction_ != nullptr);
      direction_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(motioninfo_ != nullptr);
      motioninfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&label_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&existenceconfidence_) -
        reinterpret_cast<char*>(&label_)) + sizeof(existenceconfidence_));
  }
  trackid_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObstacleCube::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string camera = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_camera();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "od.ObstacleCube.camera"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_label(&has_bits);
          label_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float typeConfidence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_typeconfidence(&has_bits);
          typeconfidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float existenceConfidence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_existenceconfidence(&has_bits);
          existenceconfidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 trackId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_trackid(&has_bits);
          trackid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3d Center = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3d shape = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3d direction = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_direction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.MotionInfo motionInfo = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_motioninfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .od.ObstacleTrajectory trajectory = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trajectory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObstacleCube::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.ObstacleCube)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string camera = 1;
  if (_internal_has_camera()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_camera().data(), static_cast<int>(this->_internal_camera().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "od.ObstacleCube.camera");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_camera(), target);
  }

  // optional int32 label = 2;
  if (_internal_has_label()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_label(), target);
  }

  // optional float typeConfidence = 3;
  if (_internal_has_typeconfidence()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_typeconfidence(), target);
  }

  // optional float existenceConfidence = 4;
  if (_internal_has_existenceconfidence()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_existenceconfidence(), target);
  }

  // optional int32 trackId = 5;
  if (_internal_has_trackid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_trackid(), target);
  }

  // optional .od.Vector3d Center = 6;
  if (_internal_has_center()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::center(this), target, stream);
  }

  // optional .od.Vector3d shape = 7;
  if (_internal_has_shape()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::shape(this), target, stream);
  }

  // optional .od.Vector3d direction = 8;
  if (_internal_has_direction()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::direction(this), target, stream);
  }

  // optional .od.MotionInfo motionInfo = 9;
  if (_internal_has_motioninfo()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::motioninfo(this), target, stream);
  }

  // repeated .od.ObstacleTrajectory trajectory = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_trajectory_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_trajectory(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.ObstacleCube)
  return target;
}

size_t ObstacleCube::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.ObstacleCube)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .od.ObstacleTrajectory trajectory = 10;
  total_size += 1UL * this->_internal_trajectory_size();
  for (const auto& msg : this->trajectory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string camera = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_camera());
    }

    // optional .od.Vector3d Center = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *center_);
    }

    // optional .od.Vector3d shape = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *shape_);
    }

    // optional .od.Vector3d direction = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *direction_);
    }

    // optional .od.MotionInfo motionInfo = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *motioninfo_);
    }

    // optional int32 label = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_label());
    }

    // optional float typeConfidence = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float existenceConfidence = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional int32 trackId = 5;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_trackid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObstacleCube::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObstacleCube::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObstacleCube::GetClassData() const { return &_class_data_; }

void ObstacleCube::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObstacleCube *>(to)->MergeFrom(
      static_cast<const ObstacleCube &>(from));
}


void ObstacleCube::MergeFrom(const ObstacleCube& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.ObstacleCube)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  trajectory_.MergeFrom(from.trajectory_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_camera(from._internal_camera());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_center()->::od::Vector3d::MergeFrom(from._internal_center());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_shape()->::od::Vector3d::MergeFrom(from._internal_shape());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_direction()->::od::Vector3d::MergeFrom(from._internal_direction());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_motioninfo()->::od::MotionInfo::MergeFrom(from._internal_motioninfo());
    }
    if (cached_has_bits & 0x00000020u) {
      label_ = from.label_;
    }
    if (cached_has_bits & 0x00000040u) {
      typeconfidence_ = from.typeconfidence_;
    }
    if (cached_has_bits & 0x00000080u) {
      existenceconfidence_ = from.existenceconfidence_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_trackid(from._internal_trackid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObstacleCube::CopyFrom(const ObstacleCube& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.ObstacleCube)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleCube::IsInitialized() const {
  return true;
}

void ObstacleCube::InternalSwap(ObstacleCube* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  trajectory_.InternalSwap(&other->trajectory_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &camera_, lhs_arena,
      &other->camera_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObstacleCube, trackid_)
      + sizeof(ObstacleCube::trackid_)
      - PROTOBUF_FIELD_OFFSET(ObstacleCube, center_)>(
          reinterpret_cast<char*>(&center_),
          reinterpret_cast<char*>(&other->center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObstacleCube::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[9]);
}

// ===================================================================

class ObstacleTrajectory::_Internal {
 public:
  using HasBits = decltype(std::declval<ObstacleTrajectory>()._has_bits_);
  static void set_has_motionstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_confidence(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ObstacleTrajectory::ObstacleTrajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  points_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.ObstacleTrajectory)
}
ObstacleTrajectory::ObstacleTrajectory(const ObstacleTrajectory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      points_(from.points_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&motionstatus_, &from.motionstatus_,
    static_cast<size_t>(reinterpret_cast<char*>(&confidence_) -
    reinterpret_cast<char*>(&motionstatus_)) + sizeof(confidence_));
  // @@protoc_insertion_point(copy_constructor:od.ObstacleTrajectory)
}

inline void ObstacleTrajectory::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&motionstatus_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&confidence_) -
    reinterpret_cast<char*>(&motionstatus_)) + sizeof(confidence_));
}

ObstacleTrajectory::~ObstacleTrajectory() {
  // @@protoc_insertion_point(destructor:od.ObstacleTrajectory)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObstacleTrajectory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ObstacleTrajectory::ArenaDtor(void* object) {
  ObstacleTrajectory* _this = reinterpret_cast< ObstacleTrajectory* >(object);
  (void)_this;
}
void ObstacleTrajectory::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObstacleTrajectory::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObstacleTrajectory::Clear() {
// @@protoc_insertion_point(message_clear_start:od.ObstacleTrajectory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&motionstatus_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&confidence_) -
        reinterpret_cast<char*>(&motionstatus_)) + sizeof(confidence_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObstacleTrajectory::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .od.MotionStatus motionStatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_motionstatus(static_cast<::od::MotionStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // optional float confidence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_confidence(&has_bits);
          confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .od.ObstacleTrajectoryPoint points = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObstacleTrajectory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.ObstacleTrajectory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .od.MotionStatus motionStatus = 1;
  if (_internal_has_motionstatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_motionstatus(), target);
  }

  // optional float confidence = 2;
  if (_internal_has_confidence()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_confidence(), target);
  }

  // repeated .od.ObstacleTrajectoryPoint points = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_points_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_points(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.ObstacleTrajectory)
  return target;
}

size_t ObstacleTrajectory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.ObstacleTrajectory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .od.ObstacleTrajectoryPoint points = 3;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .od.MotionStatus motionStatus = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_motionstatus());
    }

    // optional float confidence = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObstacleTrajectory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObstacleTrajectory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObstacleTrajectory::GetClassData() const { return &_class_data_; }

void ObstacleTrajectory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObstacleTrajectory *>(to)->MergeFrom(
      static_cast<const ObstacleTrajectory &>(from));
}


void ObstacleTrajectory::MergeFrom(const ObstacleTrajectory& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.ObstacleTrajectory)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      motionstatus_ = from.motionstatus_;
    }
    if (cached_has_bits & 0x00000002u) {
      confidence_ = from.confidence_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObstacleTrajectory::CopyFrom(const ObstacleTrajectory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.ObstacleTrajectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleTrajectory::IsInitialized() const {
  return true;
}

void ObstacleTrajectory::InternalSwap(ObstacleTrajectory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  points_.InternalSwap(&other->points_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObstacleTrajectory, confidence_)
      + sizeof(ObstacleTrajectory::confidence_)
      - PROTOBUF_FIELD_OFFSET(ObstacleTrajectory, motionstatus_)>(
          reinterpret_cast<char*>(&motionstatus_),
          reinterpret_cast<char*>(&other->motionstatus_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObstacleTrajectory::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[10]);
}

// ===================================================================

class ObstacleTrajectoryPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<ObstacleTrajectoryPoint>()._has_bits_);
  static void set_has_deltatns(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::od::Vector3f& center(const ObstacleTrajectoryPoint* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::od::Vector3f& direction(const ObstacleTrajectoryPoint* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::od::Vector3f&
ObstacleTrajectoryPoint::_Internal::center(const ObstacleTrajectoryPoint* msg) {
  return *msg->center_;
}
const ::od::Vector3f&
ObstacleTrajectoryPoint::_Internal::direction(const ObstacleTrajectoryPoint* msg) {
  return *msg->direction_;
}
ObstacleTrajectoryPoint::ObstacleTrajectoryPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.ObstacleTrajectoryPoint)
}
ObstacleTrajectoryPoint::ObstacleTrajectoryPoint(const ObstacleTrajectoryPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_center()) {
    center_ = new ::od::Vector3f(*from.center_);
  } else {
    center_ = nullptr;
  }
  if (from._internal_has_direction()) {
    direction_ = new ::od::Vector3f(*from.direction_);
  } else {
    direction_ = nullptr;
  }
  deltatns_ = from.deltatns_;
  // @@protoc_insertion_point(copy_constructor:od.ObstacleTrajectoryPoint)
}

inline void ObstacleTrajectoryPoint::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&center_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&deltatns_) -
    reinterpret_cast<char*>(&center_)) + sizeof(deltatns_));
}

ObstacleTrajectoryPoint::~ObstacleTrajectoryPoint() {
  // @@protoc_insertion_point(destructor:od.ObstacleTrajectoryPoint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObstacleTrajectoryPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete center_;
  if (this != internal_default_instance()) delete direction_;
}

void ObstacleTrajectoryPoint::ArenaDtor(void* object) {
  ObstacleTrajectoryPoint* _this = reinterpret_cast< ObstacleTrajectoryPoint* >(object);
  (void)_this;
}
void ObstacleTrajectoryPoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObstacleTrajectoryPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObstacleTrajectoryPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:od.ObstacleTrajectoryPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(center_ != nullptr);
      center_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(direction_ != nullptr);
      direction_->Clear();
    }
  }
  deltatns_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObstacleTrajectoryPoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 deltaTNs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_deltatns(&has_bits);
          deltatns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3f center = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3f direction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_direction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObstacleTrajectoryPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.ObstacleTrajectoryPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint64 deltaTNs = 1;
  if (_internal_has_deltatns()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_deltatns(), target);
  }

  // optional .od.Vector3f center = 2;
  if (_internal_has_center()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::center(this), target, stream);
  }

  // optional .od.Vector3f direction = 3;
  if (_internal_has_direction()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::direction(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.ObstacleTrajectoryPoint)
  return target;
}

size_t ObstacleTrajectoryPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.ObstacleTrajectoryPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .od.Vector3f center = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *center_);
    }

    // optional .od.Vector3f direction = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *direction_);
    }

    // optional uint64 deltaTNs = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_deltatns());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObstacleTrajectoryPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObstacleTrajectoryPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObstacleTrajectoryPoint::GetClassData() const { return &_class_data_; }

void ObstacleTrajectoryPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObstacleTrajectoryPoint *>(to)->MergeFrom(
      static_cast<const ObstacleTrajectoryPoint &>(from));
}


void ObstacleTrajectoryPoint::MergeFrom(const ObstacleTrajectoryPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.ObstacleTrajectoryPoint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_center()->::od::Vector3f::MergeFrom(from._internal_center());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_direction()->::od::Vector3f::MergeFrom(from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      deltatns_ = from.deltatns_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObstacleTrajectoryPoint::CopyFrom(const ObstacleTrajectoryPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.ObstacleTrajectoryPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleTrajectoryPoint::IsInitialized() const {
  return true;
}

void ObstacleTrajectoryPoint::InternalSwap(ObstacleTrajectoryPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObstacleTrajectoryPoint, deltatns_)
      + sizeof(ObstacleTrajectoryPoint::deltatns_)
      - PROTOBUF_FIELD_OFFSET(ObstacleTrajectoryPoint, center_)>(
          reinterpret_cast<char*>(&center_),
          reinterpret_cast<char*>(&other->center_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObstacleTrajectoryPoint::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[11]);
}

// ===================================================================

class ObstacleRaw::_Internal {
 public:
  using HasBits = decltype(std::declval<ObstacleRaw>()._has_bits_);
  static void set_has_camera(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_typeconfidence(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_existenceconfidence(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::od::Bbox2D& box2d(const ObstacleRaw* msg);
  static void set_has_box2d(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::od::DirectionInfo& directioninfo(const ObstacleRaw* msg);
  static void set_has_directioninfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::od::PositionInfo& positioninfo(const ObstacleRaw* msg);
  static void set_has_positioninfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_staticstate(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_attrscore(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::od::Bbox2D&
ObstacleRaw::_Internal::box2d(const ObstacleRaw* msg) {
  return *msg->box2d_;
}
const ::od::DirectionInfo&
ObstacleRaw::_Internal::directioninfo(const ObstacleRaw* msg) {
  return *msg->directioninfo_;
}
const ::od::PositionInfo&
ObstacleRaw::_Internal::positioninfo(const ObstacleRaw* msg) {
  return *msg->positioninfo_;
}
ObstacleRaw::ObstacleRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  landmark_(arena),
  landmarkscores_(arena),
  landmark4_(arena),
  landmark4scores_(arena),
  landmark9_(arena),
  landmark9scores_(arena),
  box3d_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.ObstacleRaw)
}
ObstacleRaw::ObstacleRaw(const ObstacleRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      landmark_(from.landmark_),
      landmarkscores_(from.landmarkscores_),
      landmark4_(from.landmark4_),
      landmark4scores_(from.landmark4scores_),
      landmark9_(from.landmark9_),
      landmark9scores_(from.landmark9scores_),
      box3d_(from.box3d_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  camera_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_camera()) {
    camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_camera(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_box2d()) {
    box2d_ = new ::od::Bbox2D(*from.box2d_);
  } else {
    box2d_ = nullptr;
  }
  if (from._internal_has_directioninfo()) {
    directioninfo_ = new ::od::DirectionInfo(*from.directioninfo_);
  } else {
    directioninfo_ = nullptr;
  }
  if (from._internal_has_positioninfo()) {
    positioninfo_ = new ::od::PositionInfo(*from.positioninfo_);
  } else {
    positioninfo_ = nullptr;
  }
  ::memcpy(&label_, &from.label_,
    static_cast<size_t>(reinterpret_cast<char*>(&attrscore_) -
    reinterpret_cast<char*>(&label_)) + sizeof(attrscore_));
  // @@protoc_insertion_point(copy_constructor:od.ObstacleRaw)
}

inline void ObstacleRaw::SharedCtor() {
camera_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&box2d_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&attrscore_) -
    reinterpret_cast<char*>(&box2d_)) + sizeof(attrscore_));
}

ObstacleRaw::~ObstacleRaw() {
  // @@protoc_insertion_point(destructor:od.ObstacleRaw)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObstacleRaw::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  camera_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete box2d_;
  if (this != internal_default_instance()) delete directioninfo_;
  if (this != internal_default_instance()) delete positioninfo_;
}

void ObstacleRaw::ArenaDtor(void* object) {
  ObstacleRaw* _this = reinterpret_cast< ObstacleRaw* >(object);
  (void)_this;
}
void ObstacleRaw::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObstacleRaw::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObstacleRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:od.ObstacleRaw)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  landmark_.Clear();
  landmarkscores_.Clear();
  landmark4_.Clear();
  landmark4scores_.Clear();
  landmark9_.Clear();
  landmark9scores_.Clear();
  box3d_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      camera_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(box2d_ != nullptr);
      box2d_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(directioninfo_ != nullptr);
      directioninfo_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(positioninfo_ != nullptr);
      positioninfo_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&label_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&staticstate_) -
        reinterpret_cast<char*>(&label_)) + sizeof(staticstate_));
  }
  attrscore_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObstacleRaw::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string camera = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_camera();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "od.ObstacleRaw.camera"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_label(&has_bits);
          label_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float typeConfidence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_typeconfidence(&has_bits);
          typeconfidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float existenceConfidence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_existenceconfidence(&has_bits);
          existenceconfidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Bbox2D box2D = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_box2d(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.DirectionInfo directionInfo = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_directioninfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .od.Point2f landmark = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_landmark(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated float landmarkScores = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_landmarkscores(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 69) {
          _internal_add_landmarkscores(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .od.Point2f landmark4 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_landmark4(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated float landmark4Scores = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_landmark4scores(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 85) {
          _internal_add_landmark4scores(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .od.Point2f landmark9 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_landmark9(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated float landmark9Scores = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_landmark9scores(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 101) {
          _internal_add_landmark9scores(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .od.PositionInfo positionInfo = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_positioninfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float box3D = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_box3d(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 117) {
          _internal_add_box3d(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 staticState = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_staticstate(&has_bits);
          staticstate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float attrScore = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_attrscore(&has_bits);
          attrscore_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObstacleRaw::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.ObstacleRaw)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string camera = 1;
  if (_internal_has_camera()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_camera().data(), static_cast<int>(this->_internal_camera().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "od.ObstacleRaw.camera");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_camera(), target);
  }

  // optional int32 label = 2;
  if (_internal_has_label()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_label(), target);
  }

  // optional float typeConfidence = 3;
  if (_internal_has_typeconfidence()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_typeconfidence(), target);
  }

  // optional float existenceConfidence = 4;
  if (_internal_has_existenceconfidence()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_existenceconfidence(), target);
  }

  // optional .od.Bbox2D box2D = 5;
  if (_internal_has_box2d()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::box2d(this), target, stream);
  }

  // optional .od.DirectionInfo directionInfo = 6;
  if (_internal_has_directioninfo()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::directioninfo(this), target, stream);
  }

  // repeated .od.Point2f landmark = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_landmark_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_landmark(i), target, stream);
  }

  // repeated float landmarkScores = 8;
  if (this->_internal_landmarkscores_size() > 0) {
    target = stream->WriteFixedPacked(8, _internal_landmarkscores(), target);
  }

  // repeated .od.Point2f landmark4 = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_landmark4_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_landmark4(i), target, stream);
  }

  // repeated float landmark4Scores = 10;
  if (this->_internal_landmark4scores_size() > 0) {
    target = stream->WriteFixedPacked(10, _internal_landmark4scores(), target);
  }

  // repeated .od.Point2f landmark9 = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_landmark9_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_landmark9(i), target, stream);
  }

  // repeated float landmark9Scores = 12;
  if (this->_internal_landmark9scores_size() > 0) {
    target = stream->WriteFixedPacked(12, _internal_landmark9scores(), target);
  }

  // optional .od.PositionInfo positionInfo = 13;
  if (_internal_has_positioninfo()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::positioninfo(this), target, stream);
  }

  // repeated float box3D = 14;
  if (this->_internal_box3d_size() > 0) {
    target = stream->WriteFixedPacked(14, _internal_box3d(), target);
  }

  // optional int32 staticState = 15;
  if (_internal_has_staticstate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(15, this->_internal_staticstate(), target);
  }

  // optional float attrScore = 16;
  if (_internal_has_attrscore()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(16, this->_internal_attrscore(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.ObstacleRaw)
  return target;
}

size_t ObstacleRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.ObstacleRaw)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .od.Point2f landmark = 7;
  total_size += 1UL * this->_internal_landmark_size();
  for (const auto& msg : this->landmark_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated float landmarkScores = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_landmarkscores_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated .od.Point2f landmark4 = 9;
  total_size += 1UL * this->_internal_landmark4_size();
  for (const auto& msg : this->landmark4_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated float landmark4Scores = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_landmark4scores_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated .od.Point2f landmark9 = 11;
  total_size += 1UL * this->_internal_landmark9_size();
  for (const auto& msg : this->landmark9_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated float landmark9Scores = 12;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_landmark9scores_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float box3D = 14;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_box3d_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string camera = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_camera());
    }

    // optional .od.Bbox2D box2D = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *box2d_);
    }

    // optional .od.DirectionInfo directionInfo = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *directioninfo_);
    }

    // optional .od.PositionInfo positionInfo = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *positioninfo_);
    }

    // optional int32 label = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_label());
    }

    // optional float typeConfidence = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float existenceConfidence = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional int32 staticState = 15;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_staticstate());
    }

  }
  // optional float attrScore = 16;
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObstacleRaw::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObstacleRaw::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObstacleRaw::GetClassData() const { return &_class_data_; }

void ObstacleRaw::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObstacleRaw *>(to)->MergeFrom(
      static_cast<const ObstacleRaw &>(from));
}


void ObstacleRaw::MergeFrom(const ObstacleRaw& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.ObstacleRaw)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  landmark_.MergeFrom(from.landmark_);
  landmarkscores_.MergeFrom(from.landmarkscores_);
  landmark4_.MergeFrom(from.landmark4_);
  landmark4scores_.MergeFrom(from.landmark4scores_);
  landmark9_.MergeFrom(from.landmark9_);
  landmark9scores_.MergeFrom(from.landmark9scores_);
  box3d_.MergeFrom(from.box3d_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_camera(from._internal_camera());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_box2d()->::od::Bbox2D::MergeFrom(from._internal_box2d());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_directioninfo()->::od::DirectionInfo::MergeFrom(from._internal_directioninfo());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_positioninfo()->::od::PositionInfo::MergeFrom(from._internal_positioninfo());
    }
    if (cached_has_bits & 0x00000010u) {
      label_ = from.label_;
    }
    if (cached_has_bits & 0x00000020u) {
      typeconfidence_ = from.typeconfidence_;
    }
    if (cached_has_bits & 0x00000040u) {
      existenceconfidence_ = from.existenceconfidence_;
    }
    if (cached_has_bits & 0x00000080u) {
      staticstate_ = from.staticstate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_attrscore(from._internal_attrscore());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObstacleRaw::CopyFrom(const ObstacleRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.ObstacleRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleRaw::IsInitialized() const {
  return true;
}

void ObstacleRaw::InternalSwap(ObstacleRaw* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  landmark_.InternalSwap(&other->landmark_);
  landmarkscores_.InternalSwap(&other->landmarkscores_);
  landmark4_.InternalSwap(&other->landmark4_);
  landmark4scores_.InternalSwap(&other->landmark4scores_);
  landmark9_.InternalSwap(&other->landmark9_);
  landmark9scores_.InternalSwap(&other->landmark9scores_);
  box3d_.InternalSwap(&other->box3d_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &camera_, lhs_arena,
      &other->camera_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObstacleRaw, attrscore_)
      + sizeof(ObstacleRaw::attrscore_)
      - PROTOBUF_FIELD_OFFSET(ObstacleRaw, box2d_)>(
          reinterpret_cast<char*>(&box2d_),
          reinterpret_cast<char*>(&other->box2d_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObstacleRaw::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[12]);
}

// ===================================================================

class Bbox2D::_Internal {
 public:
  using HasBits = decltype(std::declval<Bbox2D>()._has_bits_);
  static void set_has_initialized(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_topleftx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_toplefty(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bottomrightx(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bottomrighty(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_confidence(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Bbox2D::Bbox2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.Bbox2D)
}
Bbox2D::Bbox2D(const Bbox2D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&initialized_, &from.initialized_,
    static_cast<size_t>(reinterpret_cast<char*>(&confidence_) -
    reinterpret_cast<char*>(&initialized_)) + sizeof(confidence_));
  // @@protoc_insertion_point(copy_constructor:od.Bbox2D)
}

inline void Bbox2D::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&initialized_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&confidence_) -
    reinterpret_cast<char*>(&initialized_)) + sizeof(confidence_));
}

Bbox2D::~Bbox2D() {
  // @@protoc_insertion_point(destructor:od.Bbox2D)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Bbox2D::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Bbox2D::ArenaDtor(void* object) {
  Bbox2D* _this = reinterpret_cast< Bbox2D* >(object);
  (void)_this;
}
void Bbox2D::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Bbox2D::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Bbox2D::Clear() {
// @@protoc_insertion_point(message_clear_start:od.Bbox2D)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&initialized_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&confidence_) -
        reinterpret_cast<char*>(&initialized_)) + sizeof(confidence_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bbox2D::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool initialized = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_initialized(&has_bits);
          initialized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float topLeftX = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_topleftx(&has_bits);
          topleftx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float topLeftY = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_toplefty(&has_bits);
          toplefty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float bottomRightX = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_bottomrightx(&has_bits);
          bottomrightx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float bottomRightY = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_bottomrighty(&has_bits);
          bottomrighty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float confidence = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_confidence(&has_bits);
          confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Bbox2D::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.Bbox2D)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool initialized = 1;
  if (_internal_has_initialized()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_initialized(), target);
  }

  // optional float topLeftX = 2;
  if (_internal_has_topleftx()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_topleftx(), target);
  }

  // optional float topLeftY = 3;
  if (_internal_has_toplefty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_toplefty(), target);
  }

  // optional float bottomRightX = 4;
  if (_internal_has_bottomrightx()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_bottomrightx(), target);
  }

  // optional float bottomRightY = 5;
  if (_internal_has_bottomrighty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_bottomrighty(), target);
  }

  // optional float confidence = 6;
  if (_internal_has_confidence()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_confidence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.Bbox2D)
  return target;
}

size_t Bbox2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.Bbox2D)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bool initialized = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional float topLeftX = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float topLeftY = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float bottomRightX = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float bottomRightY = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float confidence = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bbox2D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Bbox2D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bbox2D::GetClassData() const { return &_class_data_; }

void Bbox2D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Bbox2D *>(to)->MergeFrom(
      static_cast<const Bbox2D &>(from));
}


void Bbox2D::MergeFrom(const Bbox2D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.Bbox2D)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      initialized_ = from.initialized_;
    }
    if (cached_has_bits & 0x00000002u) {
      topleftx_ = from.topleftx_;
    }
    if (cached_has_bits & 0x00000004u) {
      toplefty_ = from.toplefty_;
    }
    if (cached_has_bits & 0x00000008u) {
      bottomrightx_ = from.bottomrightx_;
    }
    if (cached_has_bits & 0x00000010u) {
      bottomrighty_ = from.bottomrighty_;
    }
    if (cached_has_bits & 0x00000020u) {
      confidence_ = from.confidence_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bbox2D::CopyFrom(const Bbox2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.Bbox2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bbox2D::IsInitialized() const {
  return true;
}

void Bbox2D::InternalSwap(Bbox2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Bbox2D, confidence_)
      + sizeof(Bbox2D::confidence_)
      - PROTOBUF_FIELD_OFFSET(Bbox2D, initialized_)>(
          reinterpret_cast<char*>(&initialized_),
          reinterpret_cast<char*>(&other->initialized_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Bbox2D::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[13]);
}

// ===================================================================

class DirectionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DirectionInfo>()._has_bits_);
  static void set_has_isvalid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::od::Vector3f& directionypr(const DirectionInfo* msg);
  static void set_has_directionypr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::od::Matrix3f& directionypruncertainty(const DirectionInfo* msg);
  static void set_has_directionypruncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_yawuncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_yawrate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_yawrateuncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_surface(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_surfacescore(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::od::Vector3f&
DirectionInfo::_Internal::directionypr(const DirectionInfo* msg) {
  return *msg->directionypr_;
}
const ::od::Matrix3f&
DirectionInfo::_Internal::directionypruncertainty(const DirectionInfo* msg) {
  return *msg->directionypruncertainty_;
}
DirectionInfo::DirectionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.DirectionInfo)
}
DirectionInfo::DirectionInfo(const DirectionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_directionypr()) {
    directionypr_ = new ::od::Vector3f(*from.directionypr_);
  } else {
    directionypr_ = nullptr;
  }
  if (from._internal_has_directionypruncertainty()) {
    directionypruncertainty_ = new ::od::Matrix3f(*from.directionypruncertainty_);
  } else {
    directionypruncertainty_ = nullptr;
  }
  ::memcpy(&isvalid_, &from.isvalid_,
    static_cast<size_t>(reinterpret_cast<char*>(&surfacescore_) -
    reinterpret_cast<char*>(&isvalid_)) + sizeof(surfacescore_));
  // @@protoc_insertion_point(copy_constructor:od.DirectionInfo)
}

inline void DirectionInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&directionypr_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&surfacescore_) -
    reinterpret_cast<char*>(&directionypr_)) + sizeof(surfacescore_));
}

DirectionInfo::~DirectionInfo() {
  // @@protoc_insertion_point(destructor:od.DirectionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DirectionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete directionypr_;
  if (this != internal_default_instance()) delete directionypruncertainty_;
}

void DirectionInfo::ArenaDtor(void* object) {
  DirectionInfo* _this = reinterpret_cast< DirectionInfo* >(object);
  (void)_this;
}
void DirectionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DirectionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DirectionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:od.DirectionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(directionypr_ != nullptr);
      directionypr_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(directionypruncertainty_ != nullptr);
      directionypruncertainty_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&isvalid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&surface_) -
        reinterpret_cast<char*>(&isvalid_)) + sizeof(surface_));
  }
  surfacescore_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DirectionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool isValid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_isvalid(&has_bits);
          isvalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3f directionYpr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_directionypr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Matrix3f directionYprUncertainty = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_directionypruncertainty(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float yaw = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_yaw(&has_bits);
          yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float yawUncertainty = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_yawuncertainty(&has_bits);
          yawuncertainty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float yawRate = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_yawrate(&has_bits);
          yawrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float yawRateUncertainty = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_yawrateuncertainty(&has_bits);
          yawrateuncertainty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 surface = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_surface(&has_bits);
          surface_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float surfaceScore = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_surfacescore(&has_bits);
          surfacescore_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DirectionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.DirectionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool isValid = 1;
  if (_internal_has_isvalid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_isvalid(), target);
  }

  // optional .od.Vector3f directionYpr = 2;
  if (_internal_has_directionypr()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::directionypr(this), target, stream);
  }

  // optional .od.Matrix3f directionYprUncertainty = 3;
  if (_internal_has_directionypruncertainty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::directionypruncertainty(this), target, stream);
  }

  // optional float yaw = 4;
  if (_internal_has_yaw()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_yaw(), target);
  }

  // optional float yawUncertainty = 5;
  if (_internal_has_yawuncertainty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_yawuncertainty(), target);
  }

  // optional float yawRate = 6;
  if (_internal_has_yawrate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_yawrate(), target);
  }

  // optional float yawRateUncertainty = 7;
  if (_internal_has_yawrateuncertainty()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_yawrateuncertainty(), target);
  }

  // optional int32 surface = 8;
  if (_internal_has_surface()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_surface(), target);
  }

  // optional float surfaceScore = 9;
  if (_internal_has_surfacescore()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_surfacescore(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.DirectionInfo)
  return target;
}

size_t DirectionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.DirectionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .od.Vector3f directionYpr = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *directionypr_);
    }

    // optional .od.Matrix3f directionYprUncertainty = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *directionypruncertainty_);
    }

    // optional bool isValid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional float yaw = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float yawUncertainty = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float yawRate = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float yawRateUncertainty = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional int32 surface = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_surface());
    }

  }
  // optional float surfaceScore = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DirectionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DirectionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DirectionInfo::GetClassData() const { return &_class_data_; }

void DirectionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DirectionInfo *>(to)->MergeFrom(
      static_cast<const DirectionInfo &>(from));
}


void DirectionInfo::MergeFrom(const DirectionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.DirectionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_directionypr()->::od::Vector3f::MergeFrom(from._internal_directionypr());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_directionypruncertainty()->::od::Matrix3f::MergeFrom(from._internal_directionypruncertainty());
    }
    if (cached_has_bits & 0x00000004u) {
      isvalid_ = from.isvalid_;
    }
    if (cached_has_bits & 0x00000008u) {
      yaw_ = from.yaw_;
    }
    if (cached_has_bits & 0x00000010u) {
      yawuncertainty_ = from.yawuncertainty_;
    }
    if (cached_has_bits & 0x00000020u) {
      yawrate_ = from.yawrate_;
    }
    if (cached_has_bits & 0x00000040u) {
      yawrateuncertainty_ = from.yawrateuncertainty_;
    }
    if (cached_has_bits & 0x00000080u) {
      surface_ = from.surface_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_surfacescore(from._internal_surfacescore());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DirectionInfo::CopyFrom(const DirectionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.DirectionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectionInfo::IsInitialized() const {
  return true;
}

void DirectionInfo::InternalSwap(DirectionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DirectionInfo, surfacescore_)
      + sizeof(DirectionInfo::surfacescore_)
      - PROTOBUF_FIELD_OFFSET(DirectionInfo, directionypr_)>(
          reinterpret_cast<char*>(&directionypr_),
          reinterpret_cast<char*>(&other->directionypr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DirectionInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[14]);
}

// ===================================================================

class UssRange::_Internal {
 public:
  using HasBits = decltype(std::declval<UssRange>()._has_bits_);
  static void set_has_distanceid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_recvtimens(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_isvalid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::od::Vector3f& position(const UssRange* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::od::Vector3f&
UssRange::_Internal::position(const UssRange* msg) {
  return *msg->position_;
}
UssRange::UssRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.UssRange)
}
UssRange::UssRange(const UssRange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  distanceid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    distanceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_distanceid()) {
    distanceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_distanceid(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_position()) {
    position_ = new ::od::Vector3f(*from.position_);
  } else {
    position_ = nullptr;
  }
  ::memcpy(&recvtimens_, &from.recvtimens_,
    static_cast<size_t>(reinterpret_cast<char*>(&isvalid_) -
    reinterpret_cast<char*>(&recvtimens_)) + sizeof(isvalid_));
  // @@protoc_insertion_point(copy_constructor:od.UssRange)
}

inline void UssRange::SharedCtor() {
distanceid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  distanceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&position_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isvalid_) -
    reinterpret_cast<char*>(&position_)) + sizeof(isvalid_));
}

UssRange::~UssRange() {
  // @@protoc_insertion_point(destructor:od.UssRange)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UssRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  distanceid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete position_;
}

void UssRange::ArenaDtor(void* object) {
  UssRange* _this = reinterpret_cast< UssRange* >(object);
  (void)_this;
}
void UssRange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UssRange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UssRange::Clear() {
// @@protoc_insertion_point(message_clear_start:od.UssRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      distanceid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(position_ != nullptr);
      position_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&recvtimens_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isvalid_) -
        reinterpret_cast<char*>(&recvtimens_)) + sizeof(isvalid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UssRange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string distanceId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_distanceid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "od.UssRange.distanceId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 recvTimeNs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_recvtimens(&has_bits);
          recvtimens_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 distance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_distance(&has_bits);
          distance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool isValid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_isvalid(&has_bits);
          isvalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3f position = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UssRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.UssRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string distanceId = 1;
  if (_internal_has_distanceid()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_distanceid().data(), static_cast<int>(this->_internal_distanceid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "od.UssRange.distanceId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_distanceid(), target);
  }

  // optional uint64 recvTimeNs = 2;
  if (_internal_has_recvtimens()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_recvtimens(), target);
  }

  // optional uint32 distance = 3;
  if (_internal_has_distance()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_distance(), target);
  }

  // optional bool isValid = 4;
  if (_internal_has_isvalid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_isvalid(), target);
  }

  // optional .od.Vector3f position = 5;
  if (_internal_has_position()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::position(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.UssRange)
  return target;
}

size_t UssRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.UssRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string distanceId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_distanceid());
    }

    // optional .od.Vector3f position = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional uint64 recvTimeNs = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_recvtimens());
    }

    // optional uint32 distance = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_distance());
    }

    // optional bool isValid = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UssRange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UssRange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UssRange::GetClassData() const { return &_class_data_; }

void UssRange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UssRange *>(to)->MergeFrom(
      static_cast<const UssRange &>(from));
}


void UssRange::MergeFrom(const UssRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.UssRange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_distanceid(from._internal_distanceid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_position()->::od::Vector3f::MergeFrom(from._internal_position());
    }
    if (cached_has_bits & 0x00000004u) {
      recvtimens_ = from.recvtimens_;
    }
    if (cached_has_bits & 0x00000008u) {
      distance_ = from.distance_;
    }
    if (cached_has_bits & 0x00000010u) {
      isvalid_ = from.isvalid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UssRange::CopyFrom(const UssRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.UssRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UssRange::IsInitialized() const {
  return true;
}

void UssRange::InternalSwap(UssRange* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &distanceid_, lhs_arena,
      &other->distanceid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UssRange, isvalid_)
      + sizeof(UssRange::isvalid_)
      - PROTOBUF_FIELD_OFFSET(UssRange, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UssRange::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[15]);
}

// ===================================================================

class PositionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PositionInfo>()._has_bits_);
  static void set_has_isvalid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::od::Vector3f& position(const PositionInfo* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::od::Vector3f&
PositionInfo::_Internal::position(const PositionInfo* msg) {
  return *msg->position_;
}
PositionInfo::PositionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.PositionInfo)
}
PositionInfo::PositionInfo(const PositionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    position_ = new ::od::Vector3f(*from.position_);
  } else {
    position_ = nullptr;
  }
  isvalid_ = from.isvalid_;
  // @@protoc_insertion_point(copy_constructor:od.PositionInfo)
}

inline void PositionInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&position_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isvalid_) -
    reinterpret_cast<char*>(&position_)) + sizeof(isvalid_));
}

PositionInfo::~PositionInfo() {
  // @@protoc_insertion_point(destructor:od.PositionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PositionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete position_;
}

void PositionInfo::ArenaDtor(void* object) {
  PositionInfo* _this = reinterpret_cast< PositionInfo* >(object);
  (void)_this;
}
void PositionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PositionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PositionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:od.PositionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(position_ != nullptr);
    position_->Clear();
  }
  isvalid_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PositionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool isValid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_isvalid(&has_bits);
          isvalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.Vector3f position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PositionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.PositionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool isValid = 1;
  if (_internal_has_isvalid()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_isvalid(), target);
  }

  // optional .od.Vector3f position = 2;
  if (_internal_has_position()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::position(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.PositionInfo)
  return target;
}

size_t PositionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.PositionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .od.Vector3f position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional bool isValid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PositionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PositionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PositionInfo::GetClassData() const { return &_class_data_; }

void PositionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PositionInfo *>(to)->MergeFrom(
      static_cast<const PositionInfo &>(from));
}


void PositionInfo::MergeFrom(const PositionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.PositionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_position()->::od::Vector3f::MergeFrom(from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      isvalid_ = from.isvalid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PositionInfo::CopyFrom(const PositionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.PositionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PositionInfo::IsInitialized() const {
  return true;
}

void PositionInfo::InternalSwap(PositionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionInfo, isvalid_)
      + sizeof(PositionInfo::isvalid_)
      - PROTOBUF_FIELD_OFFSET(PositionInfo, position_)>(
          reinterpret_cast<char*>(&position_),
          reinterpret_cast<char*>(&other->position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PositionInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[16]);
}

// ===================================================================

class FSLine::_Internal {
 public:
};

FSLine::FSLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  fsline_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.FSLine)
}
FSLine::FSLine(const FSLine& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      fsline_(from.fsline_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:od.FSLine)
}

inline void FSLine::SharedCtor() {
}

FSLine::~FSLine() {
  // @@protoc_insertion_point(destructor:od.FSLine)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FSLine::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FSLine::ArenaDtor(void* object) {
  FSLine* _this = reinterpret_cast< FSLine* >(object);
  (void)_this;
}
void FSLine::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FSLine::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FSLine::Clear() {
// @@protoc_insertion_point(message_clear_start:od.FSLine)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fsline_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FSLine::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .od.FSLinesimple fsLine = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fsline(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FSLine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.FSLine)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .od.FSLinesimple fsLine = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fsline_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_fsline(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.FSLine)
  return target;
}

size_t FSLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.FSLine)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .od.FSLinesimple fsLine = 1;
  total_size += 1UL * this->_internal_fsline_size();
  for (const auto& msg : this->fsline_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FSLine::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FSLine::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FSLine::GetClassData() const { return &_class_data_; }

void FSLine::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FSLine *>(to)->MergeFrom(
      static_cast<const FSLine &>(from));
}


void FSLine::MergeFrom(const FSLine& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.FSLine)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fsline_.MergeFrom(from.fsline_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FSLine::CopyFrom(const FSLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.FSLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FSLine::IsInitialized() const {
  return true;
}

void FSLine::InternalSwap(FSLine* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  fsline_.InternalSwap(&other->fsline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FSLine::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[17]);
}

// ===================================================================

class FSLinesimple::_Internal {
 public:
  using HasBits = decltype(std::declval<FSLinesimple>()._has_bits_);
  static const ::od::Header& header(const FSLinesimple* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_frametimestampns(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::od::Header&
FSLinesimple::_Internal::header(const FSLinesimple* msg) {
  return *msg->header_;
}
FSLinesimple::FSLinesimple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  fslinepoints_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.FSLinesimple)
}
FSLinesimple::FSLinesimple(const FSLinesimple& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      fslinepoints_(from.fslinepoints_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::od::Header(*from.header_);
  } else {
    header_ = nullptr;
  }
  frametimestampns_ = from.frametimestampns_;
  // @@protoc_insertion_point(copy_constructor:od.FSLinesimple)
}

inline void FSLinesimple::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&header_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frametimestampns_) -
    reinterpret_cast<char*>(&header_)) + sizeof(frametimestampns_));
}

FSLinesimple::~FSLinesimple() {
  // @@protoc_insertion_point(destructor:od.FSLinesimple)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FSLinesimple::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete header_;
}

void FSLinesimple::ArenaDtor(void* object) {
  FSLinesimple* _this = reinterpret_cast< FSLinesimple* >(object);
  (void)_this;
}
void FSLinesimple::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FSLinesimple::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FSLinesimple::Clear() {
// @@protoc_insertion_point(message_clear_start:od.FSLinesimple)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  fslinepoints_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(header_ != nullptr);
    header_->Clear();
  }
  frametimestampns_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FSLinesimple::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .od.Header header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 frameTimestampNs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_frametimestampns(&has_bits);
          frametimestampns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .od.FSLinePoint fsLinepoints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fslinepoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FSLinesimple::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.FSLinesimple)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .od.Header header = 1;
  if (_internal_has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // optional uint64 frameTimestampNs = 2;
  if (_internal_has_frametimestampns()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_frametimestampns(), target);
  }

  // repeated .od.FSLinePoint fsLinepoints = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fslinepoints_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_fslinepoints(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.FSLinesimple)
  return target;
}

size_t FSLinesimple::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.FSLinesimple)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .od.FSLinePoint fsLinepoints = 3;
  total_size += 1UL * this->_internal_fslinepoints_size();
  for (const auto& msg : this->fslinepoints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .od.Header header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional uint64 frameTimestampNs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_frametimestampns());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FSLinesimple::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FSLinesimple::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FSLinesimple::GetClassData() const { return &_class_data_; }

void FSLinesimple::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FSLinesimple *>(to)->MergeFrom(
      static_cast<const FSLinesimple &>(from));
}


void FSLinesimple::MergeFrom(const FSLinesimple& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.FSLinesimple)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  fslinepoints_.MergeFrom(from.fslinepoints_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_header()->::od::Header::MergeFrom(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      frametimestampns_ = from.frametimestampns_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FSLinesimple::CopyFrom(const FSLinesimple& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.FSLinesimple)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FSLinesimple::IsInitialized() const {
  return true;
}

void FSLinesimple::InternalSwap(FSLinesimple* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fslinepoints_.InternalSwap(&other->fslinepoints_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FSLinesimple, frametimestampns_)
      + sizeof(FSLinesimple::frametimestampns_)
      - PROTOBUF_FIELD_OFFSET(FSLinesimple, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FSLinesimple::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[18]);
}

// ===================================================================

class FSLinePoint::_Internal {
 public:
  using HasBits = decltype(std::declval<FSLinePoint>()._has_bits_);
  static const ::od::Point2f& coordinate(const FSLinePoint* msg);
  static void set_has_coordinate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pointlabel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::od::Point2f&
FSLinePoint::_Internal::coordinate(const FSLinePoint* msg) {
  return *msg->coordinate_;
}
FSLinePoint::FSLinePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:od.FSLinePoint)
}
FSLinePoint::FSLinePoint(const FSLinePoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_coordinate()) {
    coordinate_ = new ::od::Point2f(*from.coordinate_);
  } else {
    coordinate_ = nullptr;
  }
  pointlabel_ = from.pointlabel_;
  // @@protoc_insertion_point(copy_constructor:od.FSLinePoint)
}

inline void FSLinePoint::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&coordinate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pointlabel_) -
    reinterpret_cast<char*>(&coordinate_)) + sizeof(pointlabel_));
}

FSLinePoint::~FSLinePoint() {
  // @@protoc_insertion_point(destructor:od.FSLinePoint)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FSLinePoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete coordinate_;
}

void FSLinePoint::ArenaDtor(void* object) {
  FSLinePoint* _this = reinterpret_cast< FSLinePoint* >(object);
  (void)_this;
}
void FSLinePoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FSLinePoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FSLinePoint::Clear() {
// @@protoc_insertion_point(message_clear_start:od.FSLinePoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(coordinate_ != nullptr);
    coordinate_->Clear();
  }
  pointlabel_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FSLinePoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .od.Point2f coordinate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_coordinate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .od.SpaceLabel pointLabel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pointlabel(static_cast<::od::SpaceLabel>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FSLinePoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:od.FSLinePoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .od.Point2f coordinate = 1;
  if (_internal_has_coordinate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::coordinate(this), target, stream);
  }

  // optional .od.SpaceLabel pointLabel = 2;
  if (_internal_has_pointlabel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_pointlabel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:od.FSLinePoint)
  return target;
}

size_t FSLinePoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:od.FSLinePoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .od.Point2f coordinate = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *coordinate_);
    }

    // optional .od.SpaceLabel pointLabel = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_pointlabel());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FSLinePoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FSLinePoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FSLinePoint::GetClassData() const { return &_class_data_; }

void FSLinePoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FSLinePoint *>(to)->MergeFrom(
      static_cast<const FSLinePoint &>(from));
}


void FSLinePoint::MergeFrom(const FSLinePoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:od.FSLinePoint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_coordinate()->::od::Point2f::MergeFrom(from._internal_coordinate());
    }
    if (cached_has_bits & 0x00000002u) {
      pointlabel_ = from.pointlabel_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FSLinePoint::CopyFrom(const FSLinePoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:od.FSLinePoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FSLinePoint::IsInitialized() const {
  return true;
}

void FSLinePoint::InternalSwap(FSLinePoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FSLinePoint, pointlabel_)
      + sizeof(FSLinePoint::pointlabel_)
      - PROTOBUF_FIELD_OFFSET(FSLinePoint, coordinate_)>(
          reinterpret_cast<char*>(&coordinate_),
          reinterpret_cast<char*>(&other->coordinate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FSLinePoint::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_od_2eproto_getter, &descriptor_table_od_2eproto_once,
      file_level_metadata_od_2eproto[19]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace od
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::od::Obstacles* Arena::CreateMaybeMessage< ::od::Obstacles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::Obstacles >(arena);
}
template<> PROTOBUF_NOINLINE ::od::Header* Arena::CreateMaybeMessage< ::od::Header >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::Header >(arena);
}
template<> PROTOBUF_NOINLINE ::od::Time* Arena::CreateMaybeMessage< ::od::Time >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::Time >(arena);
}
template<> PROTOBUF_NOINLINE ::od::ObstacleCylindrical* Arena::CreateMaybeMessage< ::od::ObstacleCylindrical >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::ObstacleCylindrical >(arena);
}
template<> PROTOBUF_NOINLINE ::od::Vector3d* Arena::CreateMaybeMessage< ::od::Vector3d >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::Vector3d >(arena);
}
template<> PROTOBUF_NOINLINE ::od::MotionInfo* Arena::CreateMaybeMessage< ::od::MotionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::MotionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::od::Point2f* Arena::CreateMaybeMessage< ::od::Point2f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::Point2f >(arena);
}
template<> PROTOBUF_NOINLINE ::od::Vector3f* Arena::CreateMaybeMessage< ::od::Vector3f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::Vector3f >(arena);
}
template<> PROTOBUF_NOINLINE ::od::Matrix3f* Arena::CreateMaybeMessage< ::od::Matrix3f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::Matrix3f >(arena);
}
template<> PROTOBUF_NOINLINE ::od::ObstacleCube* Arena::CreateMaybeMessage< ::od::ObstacleCube >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::ObstacleCube >(arena);
}
template<> PROTOBUF_NOINLINE ::od::ObstacleTrajectory* Arena::CreateMaybeMessage< ::od::ObstacleTrajectory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::ObstacleTrajectory >(arena);
}
template<> PROTOBUF_NOINLINE ::od::ObstacleTrajectoryPoint* Arena::CreateMaybeMessage< ::od::ObstacleTrajectoryPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::ObstacleTrajectoryPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::od::ObstacleRaw* Arena::CreateMaybeMessage< ::od::ObstacleRaw >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::ObstacleRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::od::Bbox2D* Arena::CreateMaybeMessage< ::od::Bbox2D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::Bbox2D >(arena);
}
template<> PROTOBUF_NOINLINE ::od::DirectionInfo* Arena::CreateMaybeMessage< ::od::DirectionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::DirectionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::od::UssRange* Arena::CreateMaybeMessage< ::od::UssRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::UssRange >(arena);
}
template<> PROTOBUF_NOINLINE ::od::PositionInfo* Arena::CreateMaybeMessage< ::od::PositionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::PositionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::od::FSLine* Arena::CreateMaybeMessage< ::od::FSLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::FSLine >(arena);
}
template<> PROTOBUF_NOINLINE ::od::FSLinesimple* Arena::CreateMaybeMessage< ::od::FSLinesimple >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::FSLinesimple >(arena);
}
template<> PROTOBUF_NOINLINE ::od::FSLinePoint* Arena::CreateMaybeMessage< ::od::FSLinePoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::od::FSLinePoint >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
