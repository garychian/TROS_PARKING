// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rd.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rd_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rd_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rd_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rd_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rd_2eproto;
namespace rd {
class ApproxBoxPoints;
struct ApproxBoxPointsDefaultTypeInternal;
extern ApproxBoxPointsDefaultTypeInternal _ApproxBoxPoints_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class Data_Row;
struct Data_RowDefaultTypeInternal;
extern Data_RowDefaultTypeInternal _Data_Row_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Point2f;
struct Point2fDefaultTypeInternal;
extern Point2fDefaultTypeInternal _Point2f_default_instance_;
class QuadParkingSlot;
struct QuadParkingSlotDefaultTypeInternal;
extern QuadParkingSlotDefaultTypeInternal _QuadParkingSlot_default_instance_;
class QuadParkingSlots;
struct QuadParkingSlotsDefaultTypeInternal;
extern QuadParkingSlotsDefaultTypeInternal _QuadParkingSlots_default_instance_;
class SApaPSInfo;
struct SApaPSInfoDefaultTypeInternal;
extern SApaPSInfoDefaultTypeInternal _SApaPSInfo_default_instance_;
class SApaPSRect;
struct SApaPSRectDefaultTypeInternal;
extern SApaPSRectDefaultTypeInternal _SApaPSRect_default_instance_;
class SApaPoint_I;
struct SApaPoint_IDefaultTypeInternal;
extern SApaPoint_IDefaultTypeInternal _SApaPoint_I_default_instance_;
class Time;
struct TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
}  // namespace rd
PROTOBUF_NAMESPACE_OPEN
template<> ::rd::ApproxBoxPoints* Arena::CreateMaybeMessage<::rd::ApproxBoxPoints>(Arena*);
template<> ::rd::Data* Arena::CreateMaybeMessage<::rd::Data>(Arena*);
template<> ::rd::Data_Row* Arena::CreateMaybeMessage<::rd::Data_Row>(Arena*);
template<> ::rd::Header* Arena::CreateMaybeMessage<::rd::Header>(Arena*);
template<> ::rd::Image* Arena::CreateMaybeMessage<::rd::Image>(Arena*);
template<> ::rd::Point2f* Arena::CreateMaybeMessage<::rd::Point2f>(Arena*);
template<> ::rd::QuadParkingSlot* Arena::CreateMaybeMessage<::rd::QuadParkingSlot>(Arena*);
template<> ::rd::QuadParkingSlots* Arena::CreateMaybeMessage<::rd::QuadParkingSlots>(Arena*);
template<> ::rd::SApaPSInfo* Arena::CreateMaybeMessage<::rd::SApaPSInfo>(Arena*);
template<> ::rd::SApaPSRect* Arena::CreateMaybeMessage<::rd::SApaPSRect>(Arena*);
template<> ::rd::SApaPoint_I* Arena::CreateMaybeMessage<::rd::SApaPoint_I>(Arena*);
template<> ::rd::Time* Arena::CreateMaybeMessage<::rd::Time>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rd {

enum Pstype : int {
  PARALLEL_PARKING = 0,
  VERTICAL_PARKING = 1,
  DIAGONAL_PARKING_1 = 2,
  Pstype_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Pstype_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Pstype_IsValid(int value);
constexpr Pstype Pstype_MIN = PARALLEL_PARKING;
constexpr Pstype Pstype_MAX = DIAGONAL_PARKING_1;
constexpr int Pstype_ARRAYSIZE = Pstype_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Pstype_descriptor();
template<typename T>
inline const std::string& Pstype_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Pstype>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Pstype_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Pstype_descriptor(), enum_t_value);
}
inline bool Pstype_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Pstype* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Pstype>(
    Pstype_descriptor(), name, value);
}
enum Memtype : int {
  host = 0,
  cambriconVgu = 1,
  horizonIon = 2,
  Memtype_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Memtype_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Memtype_IsValid(int value);
constexpr Memtype Memtype_MIN = host;
constexpr Memtype Memtype_MAX = horizonIon;
constexpr int Memtype_ARRAYSIZE = Memtype_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Memtype_descriptor();
template<typename T>
inline const std::string& Memtype_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Memtype>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Memtype_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Memtype_descriptor(), enum_t_value);
}
inline bool Memtype_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Memtype* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Memtype>(
    Memtype_descriptor(), name, value);
}
// ===================================================================

class SApaPoint_I final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.SApaPoint_I) */ {
 public:
  inline SApaPoint_I() : SApaPoint_I(nullptr) {}
  ~SApaPoint_I() override;
  explicit constexpr SApaPoint_I(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SApaPoint_I(const SApaPoint_I& from);
  SApaPoint_I(SApaPoint_I&& from) noexcept
    : SApaPoint_I() {
    *this = ::std::move(from);
  }

  inline SApaPoint_I& operator=(const SApaPoint_I& from) {
    CopyFrom(from);
    return *this;
  }
  inline SApaPoint_I& operator=(SApaPoint_I&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SApaPoint_I& default_instance() {
    return *internal_default_instance();
  }
  static inline const SApaPoint_I* internal_default_instance() {
    return reinterpret_cast<const SApaPoint_I*>(
               &_SApaPoint_I_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SApaPoint_I& a, SApaPoint_I& b) {
    a.Swap(&b);
  }
  inline void Swap(SApaPoint_I* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SApaPoint_I* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SApaPoint_I* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SApaPoint_I>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SApaPoint_I& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SApaPoint_I& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SApaPoint_I* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.SApaPoint_I";
  }
  protected:
  explicit SApaPoint_I(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rd.SApaPoint_I)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t x_;
  int32_t y_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class SApaPSRect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.SApaPSRect) */ {
 public:
  inline SApaPSRect() : SApaPSRect(nullptr) {}
  ~SApaPSRect() override;
  explicit constexpr SApaPSRect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SApaPSRect(const SApaPSRect& from);
  SApaPSRect(SApaPSRect&& from) noexcept
    : SApaPSRect() {
    *this = ::std::move(from);
  }

  inline SApaPSRect& operator=(const SApaPSRect& from) {
    CopyFrom(from);
    return *this;
  }
  inline SApaPSRect& operator=(SApaPSRect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SApaPSRect& default_instance() {
    return *internal_default_instance();
  }
  static inline const SApaPSRect* internal_default_instance() {
    return reinterpret_cast<const SApaPSRect*>(
               &_SApaPSRect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SApaPSRect& a, SApaPSRect& b) {
    a.Swap(&b);
  }
  inline void Swap(SApaPSRect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SApaPSRect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SApaPSRect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SApaPSRect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SApaPSRect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SApaPSRect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SApaPSRect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.SApaPSRect";
  }
  protected:
  explicit SApaPSRect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtFieldNumber = 1,
    kPstypeFieldNumber = 2,
    kLabelFieldNumber = 3,
    kISlotTypeFieldNumber = 4,
    kISceneTypeFieldNumber = 5,
  };
  // repeated .rd.SApaPoint_I pt = 1;
  int pt_size() const;
  private:
  int _internal_pt_size() const;
  public:
  void clear_pt();
  ::rd::SApaPoint_I* mutable_pt(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPoint_I >*
      mutable_pt();
  private:
  const ::rd::SApaPoint_I& _internal_pt(int index) const;
  ::rd::SApaPoint_I* _internal_add_pt();
  public:
  const ::rd::SApaPoint_I& pt(int index) const;
  ::rd::SApaPoint_I* add_pt();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPoint_I >&
      pt() const;

  // optional .rd.Pstype pstype = 2;
  bool has_pstype() const;
  private:
  bool _internal_has_pstype() const;
  public:
  void clear_pstype();
  ::rd::Pstype pstype() const;
  void set_pstype(::rd::Pstype value);
  private:
  ::rd::Pstype _internal_pstype() const;
  void _internal_set_pstype(::rd::Pstype value);
  public:

  // optional int32 label = 3;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  int32_t label() const;
  void set_label(int32_t value);
  private:
  int32_t _internal_label() const;
  void _internal_set_label(int32_t value);
  public:

  // optional int32 iSlotType = 4;
  bool has_islottype() const;
  private:
  bool _internal_has_islottype() const;
  public:
  void clear_islottype();
  int32_t islottype() const;
  void set_islottype(int32_t value);
  private:
  int32_t _internal_islottype() const;
  void _internal_set_islottype(int32_t value);
  public:

  // optional int32 iSceneType = 5;
  bool has_iscenetype() const;
  private:
  bool _internal_has_iscenetype() const;
  public:
  void clear_iscenetype();
  int32_t iscenetype() const;
  void set_iscenetype(int32_t value);
  private:
  int32_t _internal_iscenetype() const;
  void _internal_set_iscenetype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rd.SApaPSRect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPoint_I > pt_;
  int pstype_;
  int32_t label_;
  int32_t islottype_;
  int32_t iscenetype_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit constexpr Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Image& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncodingFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kDataFieldNumber = 8,
    kOriHeightFieldNumber = 2,
    kOriWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kWidthFieldNumber = 5,
    kPhyAddrFieldNumber = 9,
    kStepFieldNumber = 7,
    kMemtypeFieldNumber = 11,
    kVirAddrFieldNumber = 10,
  };
  // optional string encoding = 6;
  bool has_encoding() const;
  private:
  bool _internal_has_encoding() const;
  public:
  void clear_encoding();
  const std::string& encoding() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoding(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoding();
  PROTOBUF_NODISCARD std::string* release_encoding();
  void set_allocated_encoding(std::string* encoding);
  private:
  const std::string& _internal_encoding() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoding(const std::string& value);
  std::string* _internal_mutable_encoding();
  public:

  // optional .rd.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::rd::Header& header() const;
  PROTOBUF_NODISCARD ::rd::Header* release_header();
  ::rd::Header* mutable_header();
  void set_allocated_header(::rd::Header* header);
  private:
  const ::rd::Header& _internal_header() const;
  ::rd::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::rd::Header* header);
  ::rd::Header* unsafe_arena_release_header();

  // optional .rd.Data data = 8;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::rd::Data& data() const;
  PROTOBUF_NODISCARD ::rd::Data* release_data();
  ::rd::Data* mutable_data();
  void set_allocated_data(::rd::Data* data);
  private:
  const ::rd::Data& _internal_data() const;
  ::rd::Data* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::rd::Data* data);
  ::rd::Data* unsafe_arena_release_data();

  // optional uint32 oriHeight = 2;
  bool has_oriheight() const;
  private:
  bool _internal_has_oriheight() const;
  public:
  void clear_oriheight();
  uint32_t oriheight() const;
  void set_oriheight(uint32_t value);
  private:
  uint32_t _internal_oriheight() const;
  void _internal_set_oriheight(uint32_t value);
  public:

  // optional uint32 oriWidth = 3;
  bool has_oriwidth() const;
  private:
  bool _internal_has_oriwidth() const;
  public:
  void clear_oriwidth();
  uint32_t oriwidth() const;
  void set_oriwidth(uint32_t value);
  private:
  uint32_t _internal_oriwidth() const;
  void _internal_set_oriwidth(uint32_t value);
  public:

  // optional uint32 height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional uint32 width = 5;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint64 phyAddr = 9;
  bool has_phyaddr() const;
  private:
  bool _internal_has_phyaddr() const;
  public:
  void clear_phyaddr();
  uint64_t phyaddr() const;
  void set_phyaddr(uint64_t value);
  private:
  uint64_t _internal_phyaddr() const;
  void _internal_set_phyaddr(uint64_t value);
  public:

  // optional uint32 step = 7;
  bool has_step() const;
  private:
  bool _internal_has_step() const;
  public:
  void clear_step();
  uint32_t step() const;
  void set_step(uint32_t value);
  private:
  uint32_t _internal_step() const;
  void _internal_set_step(uint32_t value);
  public:

  // optional .rd.Memtype memtype = 11;
  bool has_memtype() const;
  private:
  bool _internal_has_memtype() const;
  public:
  void clear_memtype();
  ::rd::Memtype memtype() const;
  void set_memtype(::rd::Memtype value);
  private:
  ::rd::Memtype _internal_memtype() const;
  void _internal_set_memtype(::rd::Memtype value);
  public:

  // optional uint64 virAddr = 10;
  bool has_viraddr() const;
  private:
  bool _internal_has_viraddr() const;
  public:
  void clear_viraddr();
  uint64_t viraddr() const;
  void set_viraddr(uint64_t value);
  private:
  uint64_t _internal_viraddr() const;
  void _internal_set_viraddr(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rd.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoding_;
  ::rd::Header* header_;
  ::rd::Data* data_;
  uint32_t oriheight_;
  uint32_t oriwidth_;
  uint32_t height_;
  uint32_t width_;
  uint64_t phyaddr_;
  uint32_t step_;
  int memtype_;
  uint64_t viraddr_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class SApaPSInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.SApaPSInfo) */ {
 public:
  inline SApaPSInfo() : SApaPSInfo(nullptr) {}
  ~SApaPSInfo() override;
  explicit constexpr SApaPSInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SApaPSInfo(const SApaPSInfo& from);
  SApaPSInfo(SApaPSInfo&& from) noexcept
    : SApaPSInfo() {
    *this = ::std::move(from);
  }

  inline SApaPSInfo& operator=(const SApaPSInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SApaPSInfo& operator=(SApaPSInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SApaPSInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SApaPSInfo* internal_default_instance() {
    return reinterpret_cast<const SApaPSInfo*>(
               &_SApaPSInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SApaPSInfo& a, SApaPSInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SApaPSInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SApaPSInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SApaPSInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SApaPSInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SApaPSInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SApaPSInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SApaPSInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.SApaPSInfo";
  }
  protected:
  explicit SApaPSInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldoutRectFieldNumber = 1,
    kUllFrameIdFieldNumber = 2,
  };
  // repeated .rd.SApaPSRect WorldoutRect = 1;
  int worldoutrect_size() const;
  private:
  int _internal_worldoutrect_size() const;
  public:
  void clear_worldoutrect();
  ::rd::SApaPSRect* mutable_worldoutrect(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPSRect >*
      mutable_worldoutrect();
  private:
  const ::rd::SApaPSRect& _internal_worldoutrect(int index) const;
  ::rd::SApaPSRect* _internal_add_worldoutrect();
  public:
  const ::rd::SApaPSRect& worldoutrect(int index) const;
  ::rd::SApaPSRect* add_worldoutrect();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPSRect >&
      worldoutrect() const;

  // optional int64 ullFrameId = 2;
  bool has_ullframeid() const;
  private:
  bool _internal_has_ullframeid() const;
  public:
  void clear_ullframeid();
  int64_t ullframeid() const;
  void set_ullframeid(int64_t value);
  private:
  int64_t _internal_ullframeid() const;
  void _internal_set_ullframeid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rd.SApaPSInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPSRect > worldoutrect_;
  int64_t ullframeid_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class QuadParkingSlots final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.QuadParkingSlots) */ {
 public:
  inline QuadParkingSlots() : QuadParkingSlots(nullptr) {}
  ~QuadParkingSlots() override;
  explicit constexpr QuadParkingSlots(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuadParkingSlots(const QuadParkingSlots& from);
  QuadParkingSlots(QuadParkingSlots&& from) noexcept
    : QuadParkingSlots() {
    *this = ::std::move(from);
  }

  inline QuadParkingSlots& operator=(const QuadParkingSlots& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuadParkingSlots& operator=(QuadParkingSlots&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuadParkingSlots& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuadParkingSlots* internal_default_instance() {
    return reinterpret_cast<const QuadParkingSlots*>(
               &_QuadParkingSlots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QuadParkingSlots& a, QuadParkingSlots& b) {
    a.Swap(&b);
  }
  inline void Swap(QuadParkingSlots* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuadParkingSlots* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuadParkingSlots* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuadParkingSlots>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuadParkingSlots& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QuadParkingSlots& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuadParkingSlots* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.QuadParkingSlots";
  }
  protected:
  explicit QuadParkingSlots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuadParkingSlotListFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kFrameTimeStampNsFieldNumber = 2,
    kSensorIdFieldNumber = 3,
  };
  // repeated .rd.QuadParkingSlot quadParkingSlotList = 4;
  int quadparkingslotlist_size() const;
  private:
  int _internal_quadparkingslotlist_size() const;
  public:
  void clear_quadparkingslotlist();
  ::rd::QuadParkingSlot* mutable_quadparkingslotlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::QuadParkingSlot >*
      mutable_quadparkingslotlist();
  private:
  const ::rd::QuadParkingSlot& _internal_quadparkingslotlist(int index) const;
  ::rd::QuadParkingSlot* _internal_add_quadparkingslotlist();
  public:
  const ::rd::QuadParkingSlot& quadparkingslotlist(int index) const;
  ::rd::QuadParkingSlot* add_quadparkingslotlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::QuadParkingSlot >&
      quadparkingslotlist() const;

  // optional .rd.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::rd::Header& header() const;
  PROTOBUF_NODISCARD ::rd::Header* release_header();
  ::rd::Header* mutable_header();
  void set_allocated_header(::rd::Header* header);
  private:
  const ::rd::Header& _internal_header() const;
  ::rd::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::rd::Header* header);
  ::rd::Header* unsafe_arena_release_header();

  // optional uint64 frameTimeStampNs = 2;
  bool has_frametimestampns() const;
  private:
  bool _internal_has_frametimestampns() const;
  public:
  void clear_frametimestampns();
  uint64_t frametimestampns() const;
  void set_frametimestampns(uint64_t value);
  private:
  uint64_t _internal_frametimestampns() const;
  void _internal_set_frametimestampns(uint64_t value);
  public:

  // optional int32 sensorId = 3;
  bool has_sensorid() const;
  private:
  bool _internal_has_sensorid() const;
  public:
  void clear_sensorid();
  int32_t sensorid() const;
  void set_sensorid(int32_t value);
  private:
  int32_t _internal_sensorid() const;
  void _internal_set_sensorid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rd.QuadParkingSlots)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::QuadParkingSlot > quadparkingslotlist_;
  ::rd::Header* header_;
  uint64_t frametimestampns_;
  int32_t sensorid_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit constexpr Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Header& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameIdFieldNumber = 3,
    kTimestampNsFieldNumber = 2,
    kSeqFieldNumber = 1,
  };
  // optional string frameId = 3;
  bool has_frameid() const;
  private:
  bool _internal_has_frameid() const;
  public:
  void clear_frameid();
  const std::string& frameid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frameid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frameid();
  PROTOBUF_NODISCARD std::string* release_frameid();
  void set_allocated_frameid(std::string* frameid);
  private:
  const std::string& _internal_frameid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frameid(const std::string& value);
  std::string* _internal_mutable_frameid();
  public:

  // optional .rd.Time timestampNs = 2;
  bool has_timestampns() const;
  private:
  bool _internal_has_timestampns() const;
  public:
  void clear_timestampns();
  const ::rd::Time& timestampns() const;
  PROTOBUF_NODISCARD ::rd::Time* release_timestampns();
  ::rd::Time* mutable_timestampns();
  void set_allocated_timestampns(::rd::Time* timestampns);
  private:
  const ::rd::Time& _internal_timestampns() const;
  ::rd::Time* _internal_mutable_timestampns();
  public:
  void unsafe_arena_set_allocated_timestampns(
      ::rd::Time* timestampns);
  ::rd::Time* unsafe_arena_release_timestampns();

  // optional uint32 seq = 1;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  uint32_t seq() const;
  void set_seq(uint32_t value);
  private:
  uint32_t _internal_seq() const;
  void _internal_set_seq(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:rd.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frameid_;
  ::rd::Time* timestampns_;
  uint32_t seq_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class Time final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.Time) */ {
 public:
  inline Time() : Time(nullptr) {}
  ~Time() override;
  explicit constexpr Time(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Time(const Time& from);
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  inline Time& operator=(Time&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Time& default_instance() {
    return *internal_default_instance();
  }
  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }
  inline void Swap(Time* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Time* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Time* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Time>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Time& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Time& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Time* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.Time";
  }
  protected:
  explicit Time(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNanoSecFieldNumber = 1,
  };
  // optional uint64 nanoSec = 1;
  bool has_nanosec() const;
  private:
  bool _internal_has_nanosec() const;
  public:
  void clear_nanosec();
  uint64_t nanosec() const;
  void set_nanosec(uint64_t value);
  private:
  uint64_t _internal_nanosec() const;
  void _internal_set_nanosec(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:rd.Time)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t nanosec_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class QuadParkingSlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.QuadParkingSlot) */ {
 public:
  inline QuadParkingSlot() : QuadParkingSlot(nullptr) {}
  ~QuadParkingSlot() override;
  explicit constexpr QuadParkingSlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuadParkingSlot(const QuadParkingSlot& from);
  QuadParkingSlot(QuadParkingSlot&& from) noexcept
    : QuadParkingSlot() {
    *this = ::std::move(from);
  }

  inline QuadParkingSlot& operator=(const QuadParkingSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuadParkingSlot& operator=(QuadParkingSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuadParkingSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuadParkingSlot* internal_default_instance() {
    return reinterpret_cast<const QuadParkingSlot*>(
               &_QuadParkingSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(QuadParkingSlot& a, QuadParkingSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(QuadParkingSlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuadParkingSlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuadParkingSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuadParkingSlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuadParkingSlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QuadParkingSlot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuadParkingSlot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.QuadParkingSlot";
  }
  protected:
  explicit QuadParkingSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTlFieldNumber = 1,
    kTrFieldNumber = 2,
    kBlFieldNumber = 3,
    kBrFieldNumber = 4,
    kDirInFieldNumber = 13,
    kDirWidthFieldNumber = 14,
    kDirLengthFieldNumber = 15,
    kCenterFieldNumber = 16,
    kPTlFieldNumber = 22,
    kPTrFieldNumber = 23,
    kPBlFieldNumber = 24,
    kPBrFieldNumber = 25,
    kConfidenceFieldNumber = 5,
    kLabelFieldNumber = 6,
    kSlotTypeFieldNumber = 8,
    kSTlFieldNumber = 9,
    kSTrFieldNumber = 10,
    kSBlFieldNumber = 11,
    kSBrFieldNumber = 12,
    kFilteredFieldNumber = 7,
    kOppModifyFieldNumber = 17,
    kIsCompleteFieldNumber = 18,
    kIsVisitedFieldNumber = 21,
    kWidthFieldNumber = 19,
    kLengthFieldNumber = 20,
  };
  // optional .rd.Point2f tl = 1;
  bool has_tl() const;
  private:
  bool _internal_has_tl() const;
  public:
  void clear_tl();
  const ::rd::Point2f& tl() const;
  PROTOBUF_NODISCARD ::rd::Point2f* release_tl();
  ::rd::Point2f* mutable_tl();
  void set_allocated_tl(::rd::Point2f* tl);
  private:
  const ::rd::Point2f& _internal_tl() const;
  ::rd::Point2f* _internal_mutable_tl();
  public:
  void unsafe_arena_set_allocated_tl(
      ::rd::Point2f* tl);
  ::rd::Point2f* unsafe_arena_release_tl();

  // optional .rd.Point2f tr = 2;
  bool has_tr() const;
  private:
  bool _internal_has_tr() const;
  public:
  void clear_tr();
  const ::rd::Point2f& tr() const;
  PROTOBUF_NODISCARD ::rd::Point2f* release_tr();
  ::rd::Point2f* mutable_tr();
  void set_allocated_tr(::rd::Point2f* tr);
  private:
  const ::rd::Point2f& _internal_tr() const;
  ::rd::Point2f* _internal_mutable_tr();
  public:
  void unsafe_arena_set_allocated_tr(
      ::rd::Point2f* tr);
  ::rd::Point2f* unsafe_arena_release_tr();

  // optional .rd.Point2f bl = 3;
  bool has_bl() const;
  private:
  bool _internal_has_bl() const;
  public:
  void clear_bl();
  const ::rd::Point2f& bl() const;
  PROTOBUF_NODISCARD ::rd::Point2f* release_bl();
  ::rd::Point2f* mutable_bl();
  void set_allocated_bl(::rd::Point2f* bl);
  private:
  const ::rd::Point2f& _internal_bl() const;
  ::rd::Point2f* _internal_mutable_bl();
  public:
  void unsafe_arena_set_allocated_bl(
      ::rd::Point2f* bl);
  ::rd::Point2f* unsafe_arena_release_bl();

  // optional .rd.Point2f br = 4;
  bool has_br() const;
  private:
  bool _internal_has_br() const;
  public:
  void clear_br();
  const ::rd::Point2f& br() const;
  PROTOBUF_NODISCARD ::rd::Point2f* release_br();
  ::rd::Point2f* mutable_br();
  void set_allocated_br(::rd::Point2f* br);
  private:
  const ::rd::Point2f& _internal_br() const;
  ::rd::Point2f* _internal_mutable_br();
  public:
  void unsafe_arena_set_allocated_br(
      ::rd::Point2f* br);
  ::rd::Point2f* unsafe_arena_release_br();

  // optional .rd.Point2f dirIn = 13;
  bool has_dirin() const;
  private:
  bool _internal_has_dirin() const;
  public:
  void clear_dirin();
  const ::rd::Point2f& dirin() const;
  PROTOBUF_NODISCARD ::rd::Point2f* release_dirin();
  ::rd::Point2f* mutable_dirin();
  void set_allocated_dirin(::rd::Point2f* dirin);
  private:
  const ::rd::Point2f& _internal_dirin() const;
  ::rd::Point2f* _internal_mutable_dirin();
  public:
  void unsafe_arena_set_allocated_dirin(
      ::rd::Point2f* dirin);
  ::rd::Point2f* unsafe_arena_release_dirin();

  // optional .rd.Point2f dirWidth = 14;
  bool has_dirwidth() const;
  private:
  bool _internal_has_dirwidth() const;
  public:
  void clear_dirwidth();
  const ::rd::Point2f& dirwidth() const;
  PROTOBUF_NODISCARD ::rd::Point2f* release_dirwidth();
  ::rd::Point2f* mutable_dirwidth();
  void set_allocated_dirwidth(::rd::Point2f* dirwidth);
  private:
  const ::rd::Point2f& _internal_dirwidth() const;
  ::rd::Point2f* _internal_mutable_dirwidth();
  public:
  void unsafe_arena_set_allocated_dirwidth(
      ::rd::Point2f* dirwidth);
  ::rd::Point2f* unsafe_arena_release_dirwidth();

  // optional .rd.Point2f dirLength = 15;
  bool has_dirlength() const;
  private:
  bool _internal_has_dirlength() const;
  public:
  void clear_dirlength();
  const ::rd::Point2f& dirlength() const;
  PROTOBUF_NODISCARD ::rd::Point2f* release_dirlength();
  ::rd::Point2f* mutable_dirlength();
  void set_allocated_dirlength(::rd::Point2f* dirlength);
  private:
  const ::rd::Point2f& _internal_dirlength() const;
  ::rd::Point2f* _internal_mutable_dirlength();
  public:
  void unsafe_arena_set_allocated_dirlength(
      ::rd::Point2f* dirlength);
  ::rd::Point2f* unsafe_arena_release_dirlength();

  // optional .rd.Point2f center = 16;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::rd::Point2f& center() const;
  PROTOBUF_NODISCARD ::rd::Point2f* release_center();
  ::rd::Point2f* mutable_center();
  void set_allocated_center(::rd::Point2f* center);
  private:
  const ::rd::Point2f& _internal_center() const;
  ::rd::Point2f* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::rd::Point2f* center);
  ::rd::Point2f* unsafe_arena_release_center();

  // optional .rd.ApproxBoxPoints pTl = 22;
  bool has_ptl() const;
  private:
  bool _internal_has_ptl() const;
  public:
  void clear_ptl();
  const ::rd::ApproxBoxPoints& ptl() const;
  PROTOBUF_NODISCARD ::rd::ApproxBoxPoints* release_ptl();
  ::rd::ApproxBoxPoints* mutable_ptl();
  void set_allocated_ptl(::rd::ApproxBoxPoints* ptl);
  private:
  const ::rd::ApproxBoxPoints& _internal_ptl() const;
  ::rd::ApproxBoxPoints* _internal_mutable_ptl();
  public:
  void unsafe_arena_set_allocated_ptl(
      ::rd::ApproxBoxPoints* ptl);
  ::rd::ApproxBoxPoints* unsafe_arena_release_ptl();

  // optional .rd.ApproxBoxPoints pTr = 23;
  bool has_ptr() const;
  private:
  bool _internal_has_ptr() const;
  public:
  void clear_ptr();
  const ::rd::ApproxBoxPoints& ptr() const;
  PROTOBUF_NODISCARD ::rd::ApproxBoxPoints* release_ptr();
  ::rd::ApproxBoxPoints* mutable_ptr();
  void set_allocated_ptr(::rd::ApproxBoxPoints* ptr);
  private:
  const ::rd::ApproxBoxPoints& _internal_ptr() const;
  ::rd::ApproxBoxPoints* _internal_mutable_ptr();
  public:
  void unsafe_arena_set_allocated_ptr(
      ::rd::ApproxBoxPoints* ptr);
  ::rd::ApproxBoxPoints* unsafe_arena_release_ptr();

  // optional .rd.ApproxBoxPoints pBl = 24;
  bool has_pbl() const;
  private:
  bool _internal_has_pbl() const;
  public:
  void clear_pbl();
  const ::rd::ApproxBoxPoints& pbl() const;
  PROTOBUF_NODISCARD ::rd::ApproxBoxPoints* release_pbl();
  ::rd::ApproxBoxPoints* mutable_pbl();
  void set_allocated_pbl(::rd::ApproxBoxPoints* pbl);
  private:
  const ::rd::ApproxBoxPoints& _internal_pbl() const;
  ::rd::ApproxBoxPoints* _internal_mutable_pbl();
  public:
  void unsafe_arena_set_allocated_pbl(
      ::rd::ApproxBoxPoints* pbl);
  ::rd::ApproxBoxPoints* unsafe_arena_release_pbl();

  // optional .rd.ApproxBoxPoints pBr = 25;
  bool has_pbr() const;
  private:
  bool _internal_has_pbr() const;
  public:
  void clear_pbr();
  const ::rd::ApproxBoxPoints& pbr() const;
  PROTOBUF_NODISCARD ::rd::ApproxBoxPoints* release_pbr();
  ::rd::ApproxBoxPoints* mutable_pbr();
  void set_allocated_pbr(::rd::ApproxBoxPoints* pbr);
  private:
  const ::rd::ApproxBoxPoints& _internal_pbr() const;
  ::rd::ApproxBoxPoints* _internal_mutable_pbr();
  public:
  void unsafe_arena_set_allocated_pbr(
      ::rd::ApproxBoxPoints* pbr);
  ::rd::ApproxBoxPoints* unsafe_arena_release_pbr();

  // optional float confidence = 5;
  bool has_confidence() const;
  private:
  bool _internal_has_confidence() const;
  public:
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // optional uint32 label = 6;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  uint32_t label() const;
  void set_label(uint32_t value);
  private:
  uint32_t _internal_label() const;
  void _internal_set_label(uint32_t value);
  public:

  // optional int32 slotType = 8;
  bool has_slottype() const;
  private:
  bool _internal_has_slottype() const;
  public:
  void clear_slottype();
  int32_t slottype() const;
  void set_slottype(int32_t value);
  private:
  int32_t _internal_slottype() const;
  void _internal_set_slottype(int32_t value);
  public:

  // optional float sTl = 9;
  bool has_stl() const;
  private:
  bool _internal_has_stl() const;
  public:
  void clear_stl();
  float stl() const;
  void set_stl(float value);
  private:
  float _internal_stl() const;
  void _internal_set_stl(float value);
  public:

  // optional float sTr = 10;
  bool has_str() const;
  private:
  bool _internal_has_str() const;
  public:
  void clear_str();
  float str() const;
  void set_str(float value);
  private:
  float _internal_str() const;
  void _internal_set_str(float value);
  public:

  // optional float sBl = 11;
  bool has_sbl() const;
  private:
  bool _internal_has_sbl() const;
  public:
  void clear_sbl();
  float sbl() const;
  void set_sbl(float value);
  private:
  float _internal_sbl() const;
  void _internal_set_sbl(float value);
  public:

  // optional float sBr = 12;
  bool has_sbr() const;
  private:
  bool _internal_has_sbr() const;
  public:
  void clear_sbr();
  float sbr() const;
  void set_sbr(float value);
  private:
  float _internal_sbr() const;
  void _internal_set_sbr(float value);
  public:

  // optional bool filtered = 7;
  bool has_filtered() const;
  private:
  bool _internal_has_filtered() const;
  public:
  void clear_filtered();
  bool filtered() const;
  void set_filtered(bool value);
  private:
  bool _internal_filtered() const;
  void _internal_set_filtered(bool value);
  public:

  // optional bool oppModify = 17;
  bool has_oppmodify() const;
  private:
  bool _internal_has_oppmodify() const;
  public:
  void clear_oppmodify();
  bool oppmodify() const;
  void set_oppmodify(bool value);
  private:
  bool _internal_oppmodify() const;
  void _internal_set_oppmodify(bool value);
  public:

  // optional bool isComplete = 18;
  bool has_iscomplete() const;
  private:
  bool _internal_has_iscomplete() const;
  public:
  void clear_iscomplete();
  bool iscomplete() const;
  void set_iscomplete(bool value);
  private:
  bool _internal_iscomplete() const;
  void _internal_set_iscomplete(bool value);
  public:

  // optional bool isVisited = 21;
  bool has_isvisited() const;
  private:
  bool _internal_has_isvisited() const;
  public:
  void clear_isvisited();
  bool isvisited() const;
  void set_isvisited(bool value);
  private:
  bool _internal_isvisited() const;
  void _internal_set_isvisited(bool value);
  public:

  // optional float width = 19;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // optional float length = 20;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // @@protoc_insertion_point(class_scope:rd.QuadParkingSlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rd::Point2f* tl_;
  ::rd::Point2f* tr_;
  ::rd::Point2f* bl_;
  ::rd::Point2f* br_;
  ::rd::Point2f* dirin_;
  ::rd::Point2f* dirwidth_;
  ::rd::Point2f* dirlength_;
  ::rd::Point2f* center_;
  ::rd::ApproxBoxPoints* ptl_;
  ::rd::ApproxBoxPoints* ptr_;
  ::rd::ApproxBoxPoints* pbl_;
  ::rd::ApproxBoxPoints* pbr_;
  float confidence_;
  uint32_t label_;
  int32_t slottype_;
  float stl_;
  float str_;
  float sbl_;
  float sbr_;
  bool filtered_;
  bool oppmodify_;
  bool iscomplete_;
  bool isvisited_;
  float width_;
  float length_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class Point2f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.Point2f) */ {
 public:
  inline Point2f() : Point2f(nullptr) {}
  ~Point2f() override;
  explicit constexpr Point2f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point2f(const Point2f& from);
  Point2f(Point2f&& from) noexcept
    : Point2f() {
    *this = ::std::move(from);
  }

  inline Point2f& operator=(const Point2f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point2f& operator=(Point2f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point2f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point2f* internal_default_instance() {
    return reinterpret_cast<const Point2f*>(
               &_Point2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Point2f& a, Point2f& b) {
    a.Swap(&b);
  }
  inline void Swap(Point2f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point2f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point2f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point2f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point2f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Point2f& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.Point2f";
  }
  protected:
  explicit Point2f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:rd.Point2f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class ApproxBoxPoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.ApproxBoxPoints) */ {
 public:
  inline ApproxBoxPoints() : ApproxBoxPoints(nullptr) {}
  ~ApproxBoxPoints() override;
  explicit constexpr ApproxBoxPoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApproxBoxPoints(const ApproxBoxPoints& from);
  ApproxBoxPoints(ApproxBoxPoints&& from) noexcept
    : ApproxBoxPoints() {
    *this = ::std::move(from);
  }

  inline ApproxBoxPoints& operator=(const ApproxBoxPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApproxBoxPoints& operator=(ApproxBoxPoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApproxBoxPoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApproxBoxPoints* internal_default_instance() {
    return reinterpret_cast<const ApproxBoxPoints*>(
               &_ApproxBoxPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ApproxBoxPoints& a, ApproxBoxPoints& b) {
    a.Swap(&b);
  }
  inline void Swap(ApproxBoxPoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApproxBoxPoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApproxBoxPoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApproxBoxPoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApproxBoxPoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApproxBoxPoints& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApproxBoxPoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.ApproxBoxPoints";
  }
  protected:
  explicit ApproxBoxPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kBorderDistFieldNumber = 2,
    kPointScoreFieldNumber = 3,
    kLineLenFieldNumber = 4,
    kLineScoreFieldNumber = 5,
    kHasBorderPointFieldNumber = 6,
  };
  // optional .rd.Point2f point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::rd::Point2f& point() const;
  PROTOBUF_NODISCARD ::rd::Point2f* release_point();
  ::rd::Point2f* mutable_point();
  void set_allocated_point(::rd::Point2f* point);
  private:
  const ::rd::Point2f& _internal_point() const;
  ::rd::Point2f* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::rd::Point2f* point);
  ::rd::Point2f* unsafe_arena_release_point();

  // optional float borderDist = 2;
  bool has_borderdist() const;
  private:
  bool _internal_has_borderdist() const;
  public:
  void clear_borderdist();
  float borderdist() const;
  void set_borderdist(float value);
  private:
  float _internal_borderdist() const;
  void _internal_set_borderdist(float value);
  public:

  // optional float pointScore = 3;
  bool has_pointscore() const;
  private:
  bool _internal_has_pointscore() const;
  public:
  void clear_pointscore();
  float pointscore() const;
  void set_pointscore(float value);
  private:
  float _internal_pointscore() const;
  void _internal_set_pointscore(float value);
  public:

  // optional float lineLen = 4;
  bool has_linelen() const;
  private:
  bool _internal_has_linelen() const;
  public:
  void clear_linelen();
  float linelen() const;
  void set_linelen(float value);
  private:
  float _internal_linelen() const;
  void _internal_set_linelen(float value);
  public:

  // optional float lineScore = 5;
  bool has_linescore() const;
  private:
  bool _internal_has_linescore() const;
  public:
  void clear_linescore();
  float linescore() const;
  void set_linescore(float value);
  private:
  float _internal_linescore() const;
  void _internal_set_linescore(float value);
  public:

  // optional bool hasBorderPoint = 6;
  bool has_hasborderpoint() const;
  private:
  bool _internal_has_hasborderpoint() const;
  public:
  void clear_hasborderpoint();
  bool hasborderpoint() const;
  void set_hasborderpoint(bool value);
  private:
  bool _internal_hasborderpoint() const;
  void _internal_set_hasborderpoint(bool value);
  public:

  // @@protoc_insertion_point(class_scope:rd.ApproxBoxPoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::rd::Point2f* point_;
  float borderdist_;
  float pointscore_;
  float linelen_;
  float linescore_;
  bool hasborderpoint_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class Data_Row final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.Data.Row) */ {
 public:
  inline Data_Row() : Data_Row(nullptr) {}
  ~Data_Row() override;
  explicit constexpr Data_Row(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data_Row(const Data_Row& from);
  Data_Row(Data_Row&& from) noexcept
    : Data_Row() {
    *this = ::std::move(from);
  }

  inline Data_Row& operator=(const Data_Row& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data_Row& operator=(Data_Row&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data_Row& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data_Row* internal_default_instance() {
    return reinterpret_cast<const Data_Row*>(
               &_Data_Row_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Data_Row& a, Data_Row& b) {
    a.Swap(&b);
  }
  inline void Swap(Data_Row* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data_Row* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data_Row* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data_Row>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Data_Row& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Data_Row& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data_Row* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.Data.Row";
  }
  protected:
  explicit Data_Row(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated int32 value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  int32_t _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_value() const;
  void _internal_add_value(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_value();
  public:
  int32_t value(int index) const;
  void set_value(int index, int32_t value);
  void add_value(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:rd.Data.Row)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > value_;
  mutable std::atomic<int> _value_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rd_2eproto;
};
// -------------------------------------------------------------------

class Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rd.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  explicit constexpr Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Data& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rd.Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Data_Row Row;

  // accessors -------------------------------------------------------

  enum : int {
    kPtFieldNumber = 1,
  };
  // repeated .rd.Data.Row pt = 1;
  int pt_size() const;
  private:
  int _internal_pt_size() const;
  public:
  void clear_pt();
  ::rd::Data_Row* mutable_pt(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::Data_Row >*
      mutable_pt();
  private:
  const ::rd::Data_Row& _internal_pt(int index) const;
  ::rd::Data_Row* _internal_add_pt();
  public:
  const ::rd::Data_Row& pt(int index) const;
  ::rd::Data_Row* add_pt();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::Data_Row >&
      pt() const;

  // @@protoc_insertion_point(class_scope:rd.Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::Data_Row > pt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rd_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SApaPoint_I

// optional int32 x = 1;
inline bool SApaPoint_I::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SApaPoint_I::has_x() const {
  return _internal_has_x();
}
inline void SApaPoint_I::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SApaPoint_I::_internal_x() const {
  return x_;
}
inline int32_t SApaPoint_I::x() const {
  // @@protoc_insertion_point(field_get:rd.SApaPoint_I.x)
  return _internal_x();
}
inline void SApaPoint_I::_internal_set_x(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void SApaPoint_I::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:rd.SApaPoint_I.x)
}

// optional int32 y = 2;
inline bool SApaPoint_I::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SApaPoint_I::has_y() const {
  return _internal_has_y();
}
inline void SApaPoint_I::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t SApaPoint_I::_internal_y() const {
  return y_;
}
inline int32_t SApaPoint_I::y() const {
  // @@protoc_insertion_point(field_get:rd.SApaPoint_I.y)
  return _internal_y();
}
inline void SApaPoint_I::_internal_set_y(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void SApaPoint_I::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:rd.SApaPoint_I.y)
}

// -------------------------------------------------------------------

// SApaPSRect

// repeated .rd.SApaPoint_I pt = 1;
inline int SApaPSRect::_internal_pt_size() const {
  return pt_.size();
}
inline int SApaPSRect::pt_size() const {
  return _internal_pt_size();
}
inline void SApaPSRect::clear_pt() {
  pt_.Clear();
}
inline ::rd::SApaPoint_I* SApaPSRect::mutable_pt(int index) {
  // @@protoc_insertion_point(field_mutable:rd.SApaPSRect.pt)
  return pt_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPoint_I >*
SApaPSRect::mutable_pt() {
  // @@protoc_insertion_point(field_mutable_list:rd.SApaPSRect.pt)
  return &pt_;
}
inline const ::rd::SApaPoint_I& SApaPSRect::_internal_pt(int index) const {
  return pt_.Get(index);
}
inline const ::rd::SApaPoint_I& SApaPSRect::pt(int index) const {
  // @@protoc_insertion_point(field_get:rd.SApaPSRect.pt)
  return _internal_pt(index);
}
inline ::rd::SApaPoint_I* SApaPSRect::_internal_add_pt() {
  return pt_.Add();
}
inline ::rd::SApaPoint_I* SApaPSRect::add_pt() {
  ::rd::SApaPoint_I* _add = _internal_add_pt();
  // @@protoc_insertion_point(field_add:rd.SApaPSRect.pt)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPoint_I >&
SApaPSRect::pt() const {
  // @@protoc_insertion_point(field_list:rd.SApaPSRect.pt)
  return pt_;
}

// optional .rd.Pstype pstype = 2;
inline bool SApaPSRect::_internal_has_pstype() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SApaPSRect::has_pstype() const {
  return _internal_has_pstype();
}
inline void SApaPSRect::clear_pstype() {
  pstype_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::rd::Pstype SApaPSRect::_internal_pstype() const {
  return static_cast< ::rd::Pstype >(pstype_);
}
inline ::rd::Pstype SApaPSRect::pstype() const {
  // @@protoc_insertion_point(field_get:rd.SApaPSRect.pstype)
  return _internal_pstype();
}
inline void SApaPSRect::_internal_set_pstype(::rd::Pstype value) {
  _has_bits_[0] |= 0x00000001u;
  pstype_ = value;
}
inline void SApaPSRect::set_pstype(::rd::Pstype value) {
  _internal_set_pstype(value);
  // @@protoc_insertion_point(field_set:rd.SApaPSRect.pstype)
}

// optional int32 label = 3;
inline bool SApaPSRect::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SApaPSRect::has_label() const {
  return _internal_has_label();
}
inline void SApaPSRect::clear_label() {
  label_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t SApaPSRect::_internal_label() const {
  return label_;
}
inline int32_t SApaPSRect::label() const {
  // @@protoc_insertion_point(field_get:rd.SApaPSRect.label)
  return _internal_label();
}
inline void SApaPSRect::_internal_set_label(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  label_ = value;
}
inline void SApaPSRect::set_label(int32_t value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:rd.SApaPSRect.label)
}

// optional int32 iSlotType = 4;
inline bool SApaPSRect::_internal_has_islottype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SApaPSRect::has_islottype() const {
  return _internal_has_islottype();
}
inline void SApaPSRect::clear_islottype() {
  islottype_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t SApaPSRect::_internal_islottype() const {
  return islottype_;
}
inline int32_t SApaPSRect::islottype() const {
  // @@protoc_insertion_point(field_get:rd.SApaPSRect.iSlotType)
  return _internal_islottype();
}
inline void SApaPSRect::_internal_set_islottype(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  islottype_ = value;
}
inline void SApaPSRect::set_islottype(int32_t value) {
  _internal_set_islottype(value);
  // @@protoc_insertion_point(field_set:rd.SApaPSRect.iSlotType)
}

// optional int32 iSceneType = 5;
inline bool SApaPSRect::_internal_has_iscenetype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SApaPSRect::has_iscenetype() const {
  return _internal_has_iscenetype();
}
inline void SApaPSRect::clear_iscenetype() {
  iscenetype_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t SApaPSRect::_internal_iscenetype() const {
  return iscenetype_;
}
inline int32_t SApaPSRect::iscenetype() const {
  // @@protoc_insertion_point(field_get:rd.SApaPSRect.iSceneType)
  return _internal_iscenetype();
}
inline void SApaPSRect::_internal_set_iscenetype(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  iscenetype_ = value;
}
inline void SApaPSRect::set_iscenetype(int32_t value) {
  _internal_set_iscenetype(value);
  // @@protoc_insertion_point(field_set:rd.SApaPSRect.iSceneType)
}

// -------------------------------------------------------------------

// Image

// optional .rd.Header header = 1;
inline bool Image::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool Image::has_header() const {
  return _internal_has_header();
}
inline void Image::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rd::Header& Image::_internal_header() const {
  const ::rd::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Header&>(
      ::rd::_Header_default_instance_);
}
inline const ::rd::Header& Image::header() const {
  // @@protoc_insertion_point(field_get:rd.Image.header)
  return _internal_header();
}
inline void Image::unsafe_arena_set_allocated_header(
    ::rd::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.Image.header)
}
inline ::rd::Header* Image::release_header() {
  _has_bits_[0] &= ~0x00000002u;
  ::rd::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Header* Image::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:rd.Image.header)
  _has_bits_[0] &= ~0x00000002u;
  ::rd::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::rd::Header* Image::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000002u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::rd::Header* Image::mutable_header() {
  ::rd::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:rd.Image.header)
  return _msg;
}
inline void Image::set_allocated_header(::rd::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Header>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:rd.Image.header)
}

// optional uint32 oriHeight = 2;
inline bool Image::_internal_has_oriheight() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Image::has_oriheight() const {
  return _internal_has_oriheight();
}
inline void Image::clear_oriheight() {
  oriheight_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Image::_internal_oriheight() const {
  return oriheight_;
}
inline uint32_t Image::oriheight() const {
  // @@protoc_insertion_point(field_get:rd.Image.oriHeight)
  return _internal_oriheight();
}
inline void Image::_internal_set_oriheight(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  oriheight_ = value;
}
inline void Image::set_oriheight(uint32_t value) {
  _internal_set_oriheight(value);
  // @@protoc_insertion_point(field_set:rd.Image.oriHeight)
}

// optional uint32 oriWidth = 3;
inline bool Image::_internal_has_oriwidth() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Image::has_oriwidth() const {
  return _internal_has_oriwidth();
}
inline void Image::clear_oriwidth() {
  oriwidth_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Image::_internal_oriwidth() const {
  return oriwidth_;
}
inline uint32_t Image::oriwidth() const {
  // @@protoc_insertion_point(field_get:rd.Image.oriWidth)
  return _internal_oriwidth();
}
inline void Image::_internal_set_oriwidth(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  oriwidth_ = value;
}
inline void Image::set_oriwidth(uint32_t value) {
  _internal_set_oriwidth(value);
  // @@protoc_insertion_point(field_set:rd.Image.oriWidth)
}

// optional uint32 height = 4;
inline bool Image::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Image::has_height() const {
  return _internal_has_height();
}
inline void Image::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t Image::_internal_height() const {
  return height_;
}
inline uint32_t Image::height() const {
  // @@protoc_insertion_point(field_get:rd.Image.height)
  return _internal_height();
}
inline void Image::_internal_set_height(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  height_ = value;
}
inline void Image::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:rd.Image.height)
}

// optional uint32 width = 5;
inline bool Image::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Image::has_width() const {
  return _internal_has_width();
}
inline void Image::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t Image::_internal_width() const {
  return width_;
}
inline uint32_t Image::width() const {
  // @@protoc_insertion_point(field_get:rd.Image.width)
  return _internal_width();
}
inline void Image::_internal_set_width(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  width_ = value;
}
inline void Image::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:rd.Image.width)
}

// optional string encoding = 6;
inline bool Image::_internal_has_encoding() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Image::has_encoding() const {
  return _internal_has_encoding();
}
inline void Image::clear_encoding() {
  encoding_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Image::encoding() const {
  // @@protoc_insertion_point(field_get:rd.Image.encoding)
  return _internal_encoding();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_encoding(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 encoding_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rd.Image.encoding)
}
inline std::string* Image::mutable_encoding() {
  std::string* _s = _internal_mutable_encoding();
  // @@protoc_insertion_point(field_mutable:rd.Image.encoding)
  return _s;
}
inline const std::string& Image::_internal_encoding() const {
  return encoding_.Get();
}
inline void Image::_internal_set_encoding(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encoding_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_encoding() {
  _has_bits_[0] |= 0x00000001u;
  return encoding_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Image::release_encoding() {
  // @@protoc_insertion_point(field_release:rd.Image.encoding)
  if (!_internal_has_encoding()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = encoding_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoding_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encoding_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image::set_allocated_encoding(std::string* encoding) {
  if (encoding != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encoding_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoding,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoding_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encoding_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rd.Image.encoding)
}

// optional uint32 step = 7;
inline bool Image::_internal_has_step() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Image::has_step() const {
  return _internal_has_step();
}
inline void Image::clear_step() {
  step_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t Image::_internal_step() const {
  return step_;
}
inline uint32_t Image::step() const {
  // @@protoc_insertion_point(field_get:rd.Image.step)
  return _internal_step();
}
inline void Image::_internal_set_step(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  step_ = value;
}
inline void Image::set_step(uint32_t value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:rd.Image.step)
}

// optional .rd.Data data = 8;
inline bool Image::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || data_ != nullptr);
  return value;
}
inline bool Image::has_data() const {
  return _internal_has_data();
}
inline void Image::clear_data() {
  if (data_ != nullptr) data_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::rd::Data& Image::_internal_data() const {
  const ::rd::Data* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Data&>(
      ::rd::_Data_default_instance_);
}
inline const ::rd::Data& Image::data() const {
  // @@protoc_insertion_point(field_get:rd.Image.data)
  return _internal_data();
}
inline void Image::unsafe_arena_set_allocated_data(
    ::rd::Data* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.Image.data)
}
inline ::rd::Data* Image::release_data() {
  _has_bits_[0] &= ~0x00000004u;
  ::rd::Data* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Data* Image::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:rd.Image.data)
  _has_bits_[0] &= ~0x00000004u;
  ::rd::Data* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::rd::Data* Image::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000004u;
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Data>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::rd::Data* Image::mutable_data() {
  ::rd::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:rd.Image.data)
  return _msg;
}
inline void Image::set_allocated_data(::rd::Data* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Data>::GetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:rd.Image.data)
}

// optional uint64 phyAddr = 9;
inline bool Image::_internal_has_phyaddr() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Image::has_phyaddr() const {
  return _internal_has_phyaddr();
}
inline void Image::clear_phyaddr() {
  phyaddr_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline uint64_t Image::_internal_phyaddr() const {
  return phyaddr_;
}
inline uint64_t Image::phyaddr() const {
  // @@protoc_insertion_point(field_get:rd.Image.phyAddr)
  return _internal_phyaddr();
}
inline void Image::_internal_set_phyaddr(uint64_t value) {
  _has_bits_[0] |= 0x00000080u;
  phyaddr_ = value;
}
inline void Image::set_phyaddr(uint64_t value) {
  _internal_set_phyaddr(value);
  // @@protoc_insertion_point(field_set:rd.Image.phyAddr)
}

// optional uint64 virAddr = 10;
inline bool Image::_internal_has_viraddr() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Image::has_viraddr() const {
  return _internal_has_viraddr();
}
inline void Image::clear_viraddr() {
  viraddr_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline uint64_t Image::_internal_viraddr() const {
  return viraddr_;
}
inline uint64_t Image::viraddr() const {
  // @@protoc_insertion_point(field_get:rd.Image.virAddr)
  return _internal_viraddr();
}
inline void Image::_internal_set_viraddr(uint64_t value) {
  _has_bits_[0] |= 0x00000400u;
  viraddr_ = value;
}
inline void Image::set_viraddr(uint64_t value) {
  _internal_set_viraddr(value);
  // @@protoc_insertion_point(field_set:rd.Image.virAddr)
}

// optional .rd.Memtype memtype = 11;
inline bool Image::_internal_has_memtype() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Image::has_memtype() const {
  return _internal_has_memtype();
}
inline void Image::clear_memtype() {
  memtype_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::rd::Memtype Image::_internal_memtype() const {
  return static_cast< ::rd::Memtype >(memtype_);
}
inline ::rd::Memtype Image::memtype() const {
  // @@protoc_insertion_point(field_get:rd.Image.memtype)
  return _internal_memtype();
}
inline void Image::_internal_set_memtype(::rd::Memtype value) {
  _has_bits_[0] |= 0x00000200u;
  memtype_ = value;
}
inline void Image::set_memtype(::rd::Memtype value) {
  _internal_set_memtype(value);
  // @@protoc_insertion_point(field_set:rd.Image.memtype)
}

// -------------------------------------------------------------------

// SApaPSInfo

// repeated .rd.SApaPSRect WorldoutRect = 1;
inline int SApaPSInfo::_internal_worldoutrect_size() const {
  return worldoutrect_.size();
}
inline int SApaPSInfo::worldoutrect_size() const {
  return _internal_worldoutrect_size();
}
inline void SApaPSInfo::clear_worldoutrect() {
  worldoutrect_.Clear();
}
inline ::rd::SApaPSRect* SApaPSInfo::mutable_worldoutrect(int index) {
  // @@protoc_insertion_point(field_mutable:rd.SApaPSInfo.WorldoutRect)
  return worldoutrect_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPSRect >*
SApaPSInfo::mutable_worldoutrect() {
  // @@protoc_insertion_point(field_mutable_list:rd.SApaPSInfo.WorldoutRect)
  return &worldoutrect_;
}
inline const ::rd::SApaPSRect& SApaPSInfo::_internal_worldoutrect(int index) const {
  return worldoutrect_.Get(index);
}
inline const ::rd::SApaPSRect& SApaPSInfo::worldoutrect(int index) const {
  // @@protoc_insertion_point(field_get:rd.SApaPSInfo.WorldoutRect)
  return _internal_worldoutrect(index);
}
inline ::rd::SApaPSRect* SApaPSInfo::_internal_add_worldoutrect() {
  return worldoutrect_.Add();
}
inline ::rd::SApaPSRect* SApaPSInfo::add_worldoutrect() {
  ::rd::SApaPSRect* _add = _internal_add_worldoutrect();
  // @@protoc_insertion_point(field_add:rd.SApaPSInfo.WorldoutRect)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::SApaPSRect >&
SApaPSInfo::worldoutrect() const {
  // @@protoc_insertion_point(field_list:rd.SApaPSInfo.WorldoutRect)
  return worldoutrect_;
}

// optional int64 ullFrameId = 2;
inline bool SApaPSInfo::_internal_has_ullframeid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SApaPSInfo::has_ullframeid() const {
  return _internal_has_ullframeid();
}
inline void SApaPSInfo::clear_ullframeid() {
  ullframeid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t SApaPSInfo::_internal_ullframeid() const {
  return ullframeid_;
}
inline int64_t SApaPSInfo::ullframeid() const {
  // @@protoc_insertion_point(field_get:rd.SApaPSInfo.ullFrameId)
  return _internal_ullframeid();
}
inline void SApaPSInfo::_internal_set_ullframeid(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  ullframeid_ = value;
}
inline void SApaPSInfo::set_ullframeid(int64_t value) {
  _internal_set_ullframeid(value);
  // @@protoc_insertion_point(field_set:rd.SApaPSInfo.ullFrameId)
}

// -------------------------------------------------------------------

// QuadParkingSlots

// optional .rd.Header header = 1;
inline bool QuadParkingSlots::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool QuadParkingSlots::has_header() const {
  return _internal_has_header();
}
inline void QuadParkingSlots::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rd::Header& QuadParkingSlots::_internal_header() const {
  const ::rd::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Header&>(
      ::rd::_Header_default_instance_);
}
inline const ::rd::Header& QuadParkingSlots::header() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlots.header)
  return _internal_header();
}
inline void QuadParkingSlots::unsafe_arena_set_allocated_header(
    ::rd::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlots.header)
}
inline ::rd::Header* QuadParkingSlots::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::rd::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Header* QuadParkingSlots::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlots.header)
  _has_bits_[0] &= ~0x00000001u;
  ::rd::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::rd::Header* QuadParkingSlots::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::rd::Header* QuadParkingSlots::mutable_header() {
  ::rd::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlots.header)
  return _msg;
}
inline void QuadParkingSlots::set_allocated_header(::rd::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Header>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlots.header)
}

// optional uint64 frameTimeStampNs = 2;
inline bool QuadParkingSlots::_internal_has_frametimestampns() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QuadParkingSlots::has_frametimestampns() const {
  return _internal_has_frametimestampns();
}
inline void QuadParkingSlots::clear_frametimestampns() {
  frametimestampns_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t QuadParkingSlots::_internal_frametimestampns() const {
  return frametimestampns_;
}
inline uint64_t QuadParkingSlots::frametimestampns() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlots.frameTimeStampNs)
  return _internal_frametimestampns();
}
inline void QuadParkingSlots::_internal_set_frametimestampns(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  frametimestampns_ = value;
}
inline void QuadParkingSlots::set_frametimestampns(uint64_t value) {
  _internal_set_frametimestampns(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlots.frameTimeStampNs)
}

// optional int32 sensorId = 3;
inline bool QuadParkingSlots::_internal_has_sensorid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QuadParkingSlots::has_sensorid() const {
  return _internal_has_sensorid();
}
inline void QuadParkingSlots::clear_sensorid() {
  sensorid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t QuadParkingSlots::_internal_sensorid() const {
  return sensorid_;
}
inline int32_t QuadParkingSlots::sensorid() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlots.sensorId)
  return _internal_sensorid();
}
inline void QuadParkingSlots::_internal_set_sensorid(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  sensorid_ = value;
}
inline void QuadParkingSlots::set_sensorid(int32_t value) {
  _internal_set_sensorid(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlots.sensorId)
}

// repeated .rd.QuadParkingSlot quadParkingSlotList = 4;
inline int QuadParkingSlots::_internal_quadparkingslotlist_size() const {
  return quadparkingslotlist_.size();
}
inline int QuadParkingSlots::quadparkingslotlist_size() const {
  return _internal_quadparkingslotlist_size();
}
inline void QuadParkingSlots::clear_quadparkingslotlist() {
  quadparkingslotlist_.Clear();
}
inline ::rd::QuadParkingSlot* QuadParkingSlots::mutable_quadparkingslotlist(int index) {
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlots.quadParkingSlotList)
  return quadparkingslotlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::QuadParkingSlot >*
QuadParkingSlots::mutable_quadparkingslotlist() {
  // @@protoc_insertion_point(field_mutable_list:rd.QuadParkingSlots.quadParkingSlotList)
  return &quadparkingslotlist_;
}
inline const ::rd::QuadParkingSlot& QuadParkingSlots::_internal_quadparkingslotlist(int index) const {
  return quadparkingslotlist_.Get(index);
}
inline const ::rd::QuadParkingSlot& QuadParkingSlots::quadparkingslotlist(int index) const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlots.quadParkingSlotList)
  return _internal_quadparkingslotlist(index);
}
inline ::rd::QuadParkingSlot* QuadParkingSlots::_internal_add_quadparkingslotlist() {
  return quadparkingslotlist_.Add();
}
inline ::rd::QuadParkingSlot* QuadParkingSlots::add_quadparkingslotlist() {
  ::rd::QuadParkingSlot* _add = _internal_add_quadparkingslotlist();
  // @@protoc_insertion_point(field_add:rd.QuadParkingSlots.quadParkingSlotList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::QuadParkingSlot >&
QuadParkingSlots::quadparkingslotlist() const {
  // @@protoc_insertion_point(field_list:rd.QuadParkingSlots.quadParkingSlotList)
  return quadparkingslotlist_;
}

// -------------------------------------------------------------------

// Header

// optional uint32 seq = 1;
inline bool Header::_internal_has_seq() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Header::has_seq() const {
  return _internal_has_seq();
}
inline void Header::clear_seq() {
  seq_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Header::_internal_seq() const {
  return seq_;
}
inline uint32_t Header::seq() const {
  // @@protoc_insertion_point(field_get:rd.Header.seq)
  return _internal_seq();
}
inline void Header::_internal_set_seq(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  seq_ = value;
}
inline void Header::set_seq(uint32_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:rd.Header.seq)
}

// optional .rd.Time timestampNs = 2;
inline bool Header::_internal_has_timestampns() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || timestampns_ != nullptr);
  return value;
}
inline bool Header::has_timestampns() const {
  return _internal_has_timestampns();
}
inline void Header::clear_timestampns() {
  if (timestampns_ != nullptr) timestampns_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rd::Time& Header::_internal_timestampns() const {
  const ::rd::Time* p = timestampns_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Time&>(
      ::rd::_Time_default_instance_);
}
inline const ::rd::Time& Header::timestampns() const {
  // @@protoc_insertion_point(field_get:rd.Header.timestampNs)
  return _internal_timestampns();
}
inline void Header::unsafe_arena_set_allocated_timestampns(
    ::rd::Time* timestampns) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestampns_);
  }
  timestampns_ = timestampns;
  if (timestampns) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.Header.timestampNs)
}
inline ::rd::Time* Header::release_timestampns() {
  _has_bits_[0] &= ~0x00000002u;
  ::rd::Time* temp = timestampns_;
  timestampns_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Time* Header::unsafe_arena_release_timestampns() {
  // @@protoc_insertion_point(field_release:rd.Header.timestampNs)
  _has_bits_[0] &= ~0x00000002u;
  ::rd::Time* temp = timestampns_;
  timestampns_ = nullptr;
  return temp;
}
inline ::rd::Time* Header::_internal_mutable_timestampns() {
  _has_bits_[0] |= 0x00000002u;
  if (timestampns_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Time>(GetArenaForAllocation());
    timestampns_ = p;
  }
  return timestampns_;
}
inline ::rd::Time* Header::mutable_timestampns() {
  ::rd::Time* _msg = _internal_mutable_timestampns();
  // @@protoc_insertion_point(field_mutable:rd.Header.timestampNs)
  return _msg;
}
inline void Header::set_allocated_timestampns(::rd::Time* timestampns) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete timestampns_;
  }
  if (timestampns) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Time>::GetOwningArena(timestampns);
    if (message_arena != submessage_arena) {
      timestampns = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestampns, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  timestampns_ = timestampns;
  // @@protoc_insertion_point(field_set_allocated:rd.Header.timestampNs)
}

// optional string frameId = 3;
inline bool Header::_internal_has_frameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Header::has_frameid() const {
  return _internal_has_frameid();
}
inline void Header::clear_frameid() {
  frameid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Header::frameid() const {
  // @@protoc_insertion_point(field_get:rd.Header.frameId)
  return _internal_frameid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_frameid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 frameid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rd.Header.frameId)
}
inline std::string* Header::mutable_frameid() {
  std::string* _s = _internal_mutable_frameid();
  // @@protoc_insertion_point(field_mutable:rd.Header.frameId)
  return _s;
}
inline const std::string& Header::_internal_frameid() const {
  return frameid_.Get();
}
inline void Header::_internal_set_frameid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  frameid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_frameid() {
  _has_bits_[0] |= 0x00000001u;
  return frameid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Header::release_frameid() {
  // @@protoc_insertion_point(field_release:rd.Header.frameId)
  if (!_internal_has_frameid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = frameid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (frameid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    frameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Header::set_allocated_frameid(std::string* frameid) {
  if (frameid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  frameid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frameid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (frameid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    frameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rd.Header.frameId)
}

// -------------------------------------------------------------------

// Time

// optional uint64 nanoSec = 1;
inline bool Time::_internal_has_nanosec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Time::has_nanosec() const {
  return _internal_has_nanosec();
}
inline void Time::clear_nanosec() {
  nanosec_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Time::_internal_nanosec() const {
  return nanosec_;
}
inline uint64_t Time::nanosec() const {
  // @@protoc_insertion_point(field_get:rd.Time.nanoSec)
  return _internal_nanosec();
}
inline void Time::_internal_set_nanosec(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  nanosec_ = value;
}
inline void Time::set_nanosec(uint64_t value) {
  _internal_set_nanosec(value);
  // @@protoc_insertion_point(field_set:rd.Time.nanoSec)
}

// -------------------------------------------------------------------

// QuadParkingSlot

// optional .rd.Point2f tl = 1;
inline bool QuadParkingSlot::_internal_has_tl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || tl_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_tl() const {
  return _internal_has_tl();
}
inline void QuadParkingSlot::clear_tl() {
  if (tl_ != nullptr) tl_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rd::Point2f& QuadParkingSlot::_internal_tl() const {
  const ::rd::Point2f* p = tl_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Point2f&>(
      ::rd::_Point2f_default_instance_);
}
inline const ::rd::Point2f& QuadParkingSlot::tl() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.tl)
  return _internal_tl();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_tl(
    ::rd::Point2f* tl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tl_);
  }
  tl_ = tl;
  if (tl) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.tl)
}
inline ::rd::Point2f* QuadParkingSlot::release_tl() {
  _has_bits_[0] &= ~0x00000001u;
  ::rd::Point2f* temp = tl_;
  tl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::unsafe_arena_release_tl() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.tl)
  _has_bits_[0] &= ~0x00000001u;
  ::rd::Point2f* temp = tl_;
  tl_ = nullptr;
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::_internal_mutable_tl() {
  _has_bits_[0] |= 0x00000001u;
  if (tl_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Point2f>(GetArenaForAllocation());
    tl_ = p;
  }
  return tl_;
}
inline ::rd::Point2f* QuadParkingSlot::mutable_tl() {
  ::rd::Point2f* _msg = _internal_mutable_tl();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.tl)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_tl(::rd::Point2f* tl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tl_;
  }
  if (tl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Point2f>::GetOwningArena(tl);
    if (message_arena != submessage_arena) {
      tl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tl, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tl_ = tl;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.tl)
}

// optional .rd.Point2f tr = 2;
inline bool QuadParkingSlot::_internal_has_tr() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || tr_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_tr() const {
  return _internal_has_tr();
}
inline void QuadParkingSlot::clear_tr() {
  if (tr_ != nullptr) tr_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::rd::Point2f& QuadParkingSlot::_internal_tr() const {
  const ::rd::Point2f* p = tr_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Point2f&>(
      ::rd::_Point2f_default_instance_);
}
inline const ::rd::Point2f& QuadParkingSlot::tr() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.tr)
  return _internal_tr();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_tr(
    ::rd::Point2f* tr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tr_);
  }
  tr_ = tr;
  if (tr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.tr)
}
inline ::rd::Point2f* QuadParkingSlot::release_tr() {
  _has_bits_[0] &= ~0x00000002u;
  ::rd::Point2f* temp = tr_;
  tr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::unsafe_arena_release_tr() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.tr)
  _has_bits_[0] &= ~0x00000002u;
  ::rd::Point2f* temp = tr_;
  tr_ = nullptr;
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::_internal_mutable_tr() {
  _has_bits_[0] |= 0x00000002u;
  if (tr_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Point2f>(GetArenaForAllocation());
    tr_ = p;
  }
  return tr_;
}
inline ::rd::Point2f* QuadParkingSlot::mutable_tr() {
  ::rd::Point2f* _msg = _internal_mutable_tr();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.tr)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_tr(::rd::Point2f* tr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tr_;
  }
  if (tr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Point2f>::GetOwningArena(tr);
    if (message_arena != submessage_arena) {
      tr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tr_ = tr;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.tr)
}

// optional .rd.Point2f bl = 3;
inline bool QuadParkingSlot::_internal_has_bl() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || bl_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_bl() const {
  return _internal_has_bl();
}
inline void QuadParkingSlot::clear_bl() {
  if (bl_ != nullptr) bl_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::rd::Point2f& QuadParkingSlot::_internal_bl() const {
  const ::rd::Point2f* p = bl_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Point2f&>(
      ::rd::_Point2f_default_instance_);
}
inline const ::rd::Point2f& QuadParkingSlot::bl() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.bl)
  return _internal_bl();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_bl(
    ::rd::Point2f* bl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bl_);
  }
  bl_ = bl;
  if (bl) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.bl)
}
inline ::rd::Point2f* QuadParkingSlot::release_bl() {
  _has_bits_[0] &= ~0x00000004u;
  ::rd::Point2f* temp = bl_;
  bl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::unsafe_arena_release_bl() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.bl)
  _has_bits_[0] &= ~0x00000004u;
  ::rd::Point2f* temp = bl_;
  bl_ = nullptr;
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::_internal_mutable_bl() {
  _has_bits_[0] |= 0x00000004u;
  if (bl_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Point2f>(GetArenaForAllocation());
    bl_ = p;
  }
  return bl_;
}
inline ::rd::Point2f* QuadParkingSlot::mutable_bl() {
  ::rd::Point2f* _msg = _internal_mutable_bl();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.bl)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_bl(::rd::Point2f* bl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bl_;
  }
  if (bl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Point2f>::GetOwningArena(bl);
    if (message_arena != submessage_arena) {
      bl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bl, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  bl_ = bl;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.bl)
}

// optional .rd.Point2f br = 4;
inline bool QuadParkingSlot::_internal_has_br() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || br_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_br() const {
  return _internal_has_br();
}
inline void QuadParkingSlot::clear_br() {
  if (br_ != nullptr) br_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::rd::Point2f& QuadParkingSlot::_internal_br() const {
  const ::rd::Point2f* p = br_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Point2f&>(
      ::rd::_Point2f_default_instance_);
}
inline const ::rd::Point2f& QuadParkingSlot::br() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.br)
  return _internal_br();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_br(
    ::rd::Point2f* br) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(br_);
  }
  br_ = br;
  if (br) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.br)
}
inline ::rd::Point2f* QuadParkingSlot::release_br() {
  _has_bits_[0] &= ~0x00000008u;
  ::rd::Point2f* temp = br_;
  br_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::unsafe_arena_release_br() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.br)
  _has_bits_[0] &= ~0x00000008u;
  ::rd::Point2f* temp = br_;
  br_ = nullptr;
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::_internal_mutable_br() {
  _has_bits_[0] |= 0x00000008u;
  if (br_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Point2f>(GetArenaForAllocation());
    br_ = p;
  }
  return br_;
}
inline ::rd::Point2f* QuadParkingSlot::mutable_br() {
  ::rd::Point2f* _msg = _internal_mutable_br();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.br)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_br(::rd::Point2f* br) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete br_;
  }
  if (br) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Point2f>::GetOwningArena(br);
    if (message_arena != submessage_arena) {
      br = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, br, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  br_ = br;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.br)
}

// optional float confidence = 5;
inline bool QuadParkingSlot::_internal_has_confidence() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_confidence() const {
  return _internal_has_confidence();
}
inline void QuadParkingSlot::clear_confidence() {
  confidence_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float QuadParkingSlot::_internal_confidence() const {
  return confidence_;
}
inline float QuadParkingSlot::confidence() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.confidence)
  return _internal_confidence();
}
inline void QuadParkingSlot::_internal_set_confidence(float value) {
  _has_bits_[0] |= 0x00001000u;
  confidence_ = value;
}
inline void QuadParkingSlot::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.confidence)
}

// optional uint32 label = 6;
inline bool QuadParkingSlot::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_label() const {
  return _internal_has_label();
}
inline void QuadParkingSlot::clear_label() {
  label_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline uint32_t QuadParkingSlot::_internal_label() const {
  return label_;
}
inline uint32_t QuadParkingSlot::label() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.label)
  return _internal_label();
}
inline void QuadParkingSlot::_internal_set_label(uint32_t value) {
  _has_bits_[0] |= 0x00002000u;
  label_ = value;
}
inline void QuadParkingSlot::set_label(uint32_t value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.label)
}

// optional bool filtered = 7;
inline bool QuadParkingSlot::_internal_has_filtered() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_filtered() const {
  return _internal_has_filtered();
}
inline void QuadParkingSlot::clear_filtered() {
  filtered_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool QuadParkingSlot::_internal_filtered() const {
  return filtered_;
}
inline bool QuadParkingSlot::filtered() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.filtered)
  return _internal_filtered();
}
inline void QuadParkingSlot::_internal_set_filtered(bool value) {
  _has_bits_[0] |= 0x00080000u;
  filtered_ = value;
}
inline void QuadParkingSlot::set_filtered(bool value) {
  _internal_set_filtered(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.filtered)
}

// optional int32 slotType = 8;
inline bool QuadParkingSlot::_internal_has_slottype() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_slottype() const {
  return _internal_has_slottype();
}
inline void QuadParkingSlot::clear_slottype() {
  slottype_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline int32_t QuadParkingSlot::_internal_slottype() const {
  return slottype_;
}
inline int32_t QuadParkingSlot::slottype() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.slotType)
  return _internal_slottype();
}
inline void QuadParkingSlot::_internal_set_slottype(int32_t value) {
  _has_bits_[0] |= 0x00004000u;
  slottype_ = value;
}
inline void QuadParkingSlot::set_slottype(int32_t value) {
  _internal_set_slottype(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.slotType)
}

// optional float sTl = 9;
inline bool QuadParkingSlot::_internal_has_stl() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_stl() const {
  return _internal_has_stl();
}
inline void QuadParkingSlot::clear_stl() {
  stl_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float QuadParkingSlot::_internal_stl() const {
  return stl_;
}
inline float QuadParkingSlot::stl() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.sTl)
  return _internal_stl();
}
inline void QuadParkingSlot::_internal_set_stl(float value) {
  _has_bits_[0] |= 0x00008000u;
  stl_ = value;
}
inline void QuadParkingSlot::set_stl(float value) {
  _internal_set_stl(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.sTl)
}

// optional float sTr = 10;
inline bool QuadParkingSlot::_internal_has_str() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_str() const {
  return _internal_has_str();
}
inline void QuadParkingSlot::clear_str() {
  str_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline float QuadParkingSlot::_internal_str() const {
  return str_;
}
inline float QuadParkingSlot::str() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.sTr)
  return _internal_str();
}
inline void QuadParkingSlot::_internal_set_str(float value) {
  _has_bits_[0] |= 0x00010000u;
  str_ = value;
}
inline void QuadParkingSlot::set_str(float value) {
  _internal_set_str(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.sTr)
}

// optional float sBl = 11;
inline bool QuadParkingSlot::_internal_has_sbl() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_sbl() const {
  return _internal_has_sbl();
}
inline void QuadParkingSlot::clear_sbl() {
  sbl_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline float QuadParkingSlot::_internal_sbl() const {
  return sbl_;
}
inline float QuadParkingSlot::sbl() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.sBl)
  return _internal_sbl();
}
inline void QuadParkingSlot::_internal_set_sbl(float value) {
  _has_bits_[0] |= 0x00020000u;
  sbl_ = value;
}
inline void QuadParkingSlot::set_sbl(float value) {
  _internal_set_sbl(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.sBl)
}

// optional float sBr = 12;
inline bool QuadParkingSlot::_internal_has_sbr() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_sbr() const {
  return _internal_has_sbr();
}
inline void QuadParkingSlot::clear_sbr() {
  sbr_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline float QuadParkingSlot::_internal_sbr() const {
  return sbr_;
}
inline float QuadParkingSlot::sbr() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.sBr)
  return _internal_sbr();
}
inline void QuadParkingSlot::_internal_set_sbr(float value) {
  _has_bits_[0] |= 0x00040000u;
  sbr_ = value;
}
inline void QuadParkingSlot::set_sbr(float value) {
  _internal_set_sbr(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.sBr)
}

// optional .rd.Point2f dirIn = 13;
inline bool QuadParkingSlot::_internal_has_dirin() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || dirin_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_dirin() const {
  return _internal_has_dirin();
}
inline void QuadParkingSlot::clear_dirin() {
  if (dirin_ != nullptr) dirin_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::rd::Point2f& QuadParkingSlot::_internal_dirin() const {
  const ::rd::Point2f* p = dirin_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Point2f&>(
      ::rd::_Point2f_default_instance_);
}
inline const ::rd::Point2f& QuadParkingSlot::dirin() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.dirIn)
  return _internal_dirin();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_dirin(
    ::rd::Point2f* dirin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dirin_);
  }
  dirin_ = dirin;
  if (dirin) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.dirIn)
}
inline ::rd::Point2f* QuadParkingSlot::release_dirin() {
  _has_bits_[0] &= ~0x00000010u;
  ::rd::Point2f* temp = dirin_;
  dirin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::unsafe_arena_release_dirin() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.dirIn)
  _has_bits_[0] &= ~0x00000010u;
  ::rd::Point2f* temp = dirin_;
  dirin_ = nullptr;
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::_internal_mutable_dirin() {
  _has_bits_[0] |= 0x00000010u;
  if (dirin_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Point2f>(GetArenaForAllocation());
    dirin_ = p;
  }
  return dirin_;
}
inline ::rd::Point2f* QuadParkingSlot::mutable_dirin() {
  ::rd::Point2f* _msg = _internal_mutable_dirin();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.dirIn)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_dirin(::rd::Point2f* dirin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dirin_;
  }
  if (dirin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Point2f>::GetOwningArena(dirin);
    if (message_arena != submessage_arena) {
      dirin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  dirin_ = dirin;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.dirIn)
}

// optional .rd.Point2f dirWidth = 14;
inline bool QuadParkingSlot::_internal_has_dirwidth() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || dirwidth_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_dirwidth() const {
  return _internal_has_dirwidth();
}
inline void QuadParkingSlot::clear_dirwidth() {
  if (dirwidth_ != nullptr) dirwidth_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::rd::Point2f& QuadParkingSlot::_internal_dirwidth() const {
  const ::rd::Point2f* p = dirwidth_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Point2f&>(
      ::rd::_Point2f_default_instance_);
}
inline const ::rd::Point2f& QuadParkingSlot::dirwidth() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.dirWidth)
  return _internal_dirwidth();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_dirwidth(
    ::rd::Point2f* dirwidth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dirwidth_);
  }
  dirwidth_ = dirwidth;
  if (dirwidth) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.dirWidth)
}
inline ::rd::Point2f* QuadParkingSlot::release_dirwidth() {
  _has_bits_[0] &= ~0x00000020u;
  ::rd::Point2f* temp = dirwidth_;
  dirwidth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::unsafe_arena_release_dirwidth() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.dirWidth)
  _has_bits_[0] &= ~0x00000020u;
  ::rd::Point2f* temp = dirwidth_;
  dirwidth_ = nullptr;
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::_internal_mutable_dirwidth() {
  _has_bits_[0] |= 0x00000020u;
  if (dirwidth_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Point2f>(GetArenaForAllocation());
    dirwidth_ = p;
  }
  return dirwidth_;
}
inline ::rd::Point2f* QuadParkingSlot::mutable_dirwidth() {
  ::rd::Point2f* _msg = _internal_mutable_dirwidth();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.dirWidth)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_dirwidth(::rd::Point2f* dirwidth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dirwidth_;
  }
  if (dirwidth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Point2f>::GetOwningArena(dirwidth);
    if (message_arena != submessage_arena) {
      dirwidth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirwidth, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  dirwidth_ = dirwidth;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.dirWidth)
}

// optional .rd.Point2f dirLength = 15;
inline bool QuadParkingSlot::_internal_has_dirlength() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || dirlength_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_dirlength() const {
  return _internal_has_dirlength();
}
inline void QuadParkingSlot::clear_dirlength() {
  if (dirlength_ != nullptr) dirlength_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::rd::Point2f& QuadParkingSlot::_internal_dirlength() const {
  const ::rd::Point2f* p = dirlength_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Point2f&>(
      ::rd::_Point2f_default_instance_);
}
inline const ::rd::Point2f& QuadParkingSlot::dirlength() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.dirLength)
  return _internal_dirlength();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_dirlength(
    ::rd::Point2f* dirlength) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dirlength_);
  }
  dirlength_ = dirlength;
  if (dirlength) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.dirLength)
}
inline ::rd::Point2f* QuadParkingSlot::release_dirlength() {
  _has_bits_[0] &= ~0x00000040u;
  ::rd::Point2f* temp = dirlength_;
  dirlength_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::unsafe_arena_release_dirlength() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.dirLength)
  _has_bits_[0] &= ~0x00000040u;
  ::rd::Point2f* temp = dirlength_;
  dirlength_ = nullptr;
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::_internal_mutable_dirlength() {
  _has_bits_[0] |= 0x00000040u;
  if (dirlength_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Point2f>(GetArenaForAllocation());
    dirlength_ = p;
  }
  return dirlength_;
}
inline ::rd::Point2f* QuadParkingSlot::mutable_dirlength() {
  ::rd::Point2f* _msg = _internal_mutable_dirlength();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.dirLength)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_dirlength(::rd::Point2f* dirlength) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dirlength_;
  }
  if (dirlength) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Point2f>::GetOwningArena(dirlength);
    if (message_arena != submessage_arena) {
      dirlength = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dirlength, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  dirlength_ = dirlength;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.dirLength)
}

// optional .rd.Point2f center = 16;
inline bool QuadParkingSlot::_internal_has_center() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || center_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_center() const {
  return _internal_has_center();
}
inline void QuadParkingSlot::clear_center() {
  if (center_ != nullptr) center_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::rd::Point2f& QuadParkingSlot::_internal_center() const {
  const ::rd::Point2f* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Point2f&>(
      ::rd::_Point2f_default_instance_);
}
inline const ::rd::Point2f& QuadParkingSlot::center() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.center)
  return _internal_center();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_center(
    ::rd::Point2f* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.center)
}
inline ::rd::Point2f* QuadParkingSlot::release_center() {
  _has_bits_[0] &= ~0x00000080u;
  ::rd::Point2f* temp = center_;
  center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.center)
  _has_bits_[0] &= ~0x00000080u;
  ::rd::Point2f* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::rd::Point2f* QuadParkingSlot::_internal_mutable_center() {
  _has_bits_[0] |= 0x00000080u;
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Point2f>(GetArenaForAllocation());
    center_ = p;
  }
  return center_;
}
inline ::rd::Point2f* QuadParkingSlot::mutable_center() {
  ::rd::Point2f* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.center)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_center(::rd::Point2f* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Point2f>::GetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.center)
}

// optional bool oppModify = 17;
inline bool QuadParkingSlot::_internal_has_oppmodify() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_oppmodify() const {
  return _internal_has_oppmodify();
}
inline void QuadParkingSlot::clear_oppmodify() {
  oppmodify_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool QuadParkingSlot::_internal_oppmodify() const {
  return oppmodify_;
}
inline bool QuadParkingSlot::oppmodify() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.oppModify)
  return _internal_oppmodify();
}
inline void QuadParkingSlot::_internal_set_oppmodify(bool value) {
  _has_bits_[0] |= 0x00100000u;
  oppmodify_ = value;
}
inline void QuadParkingSlot::set_oppmodify(bool value) {
  _internal_set_oppmodify(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.oppModify)
}

// optional bool isComplete = 18;
inline bool QuadParkingSlot::_internal_has_iscomplete() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_iscomplete() const {
  return _internal_has_iscomplete();
}
inline void QuadParkingSlot::clear_iscomplete() {
  iscomplete_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool QuadParkingSlot::_internal_iscomplete() const {
  return iscomplete_;
}
inline bool QuadParkingSlot::iscomplete() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.isComplete)
  return _internal_iscomplete();
}
inline void QuadParkingSlot::_internal_set_iscomplete(bool value) {
  _has_bits_[0] |= 0x00200000u;
  iscomplete_ = value;
}
inline void QuadParkingSlot::set_iscomplete(bool value) {
  _internal_set_iscomplete(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.isComplete)
}

// optional float width = 19;
inline bool QuadParkingSlot::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_width() const {
  return _internal_has_width();
}
inline void QuadParkingSlot::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline float QuadParkingSlot::_internal_width() const {
  return width_;
}
inline float QuadParkingSlot::width() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.width)
  return _internal_width();
}
inline void QuadParkingSlot::_internal_set_width(float value) {
  _has_bits_[0] |= 0x00800000u;
  width_ = value;
}
inline void QuadParkingSlot::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.width)
}

// optional float length = 20;
inline bool QuadParkingSlot::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_length() const {
  return _internal_has_length();
}
inline void QuadParkingSlot::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline float QuadParkingSlot::_internal_length() const {
  return length_;
}
inline float QuadParkingSlot::length() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.length)
  return _internal_length();
}
inline void QuadParkingSlot::_internal_set_length(float value) {
  _has_bits_[0] |= 0x01000000u;
  length_ = value;
}
inline void QuadParkingSlot::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.length)
}

// optional bool isVisited = 21;
inline bool QuadParkingSlot::_internal_has_isvisited() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool QuadParkingSlot::has_isvisited() const {
  return _internal_has_isvisited();
}
inline void QuadParkingSlot::clear_isvisited() {
  isvisited_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool QuadParkingSlot::_internal_isvisited() const {
  return isvisited_;
}
inline bool QuadParkingSlot::isvisited() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.isVisited)
  return _internal_isvisited();
}
inline void QuadParkingSlot::_internal_set_isvisited(bool value) {
  _has_bits_[0] |= 0x00400000u;
  isvisited_ = value;
}
inline void QuadParkingSlot::set_isvisited(bool value) {
  _internal_set_isvisited(value);
  // @@protoc_insertion_point(field_set:rd.QuadParkingSlot.isVisited)
}

// optional .rd.ApproxBoxPoints pTl = 22;
inline bool QuadParkingSlot::_internal_has_ptl() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || ptl_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_ptl() const {
  return _internal_has_ptl();
}
inline void QuadParkingSlot::clear_ptl() {
  if (ptl_ != nullptr) ptl_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::rd::ApproxBoxPoints& QuadParkingSlot::_internal_ptl() const {
  const ::rd::ApproxBoxPoints* p = ptl_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::ApproxBoxPoints&>(
      ::rd::_ApproxBoxPoints_default_instance_);
}
inline const ::rd::ApproxBoxPoints& QuadParkingSlot::ptl() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.pTl)
  return _internal_ptl();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_ptl(
    ::rd::ApproxBoxPoints* ptl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ptl_);
  }
  ptl_ = ptl;
  if (ptl) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.pTl)
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::release_ptl() {
  _has_bits_[0] &= ~0x00000100u;
  ::rd::ApproxBoxPoints* temp = ptl_;
  ptl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::unsafe_arena_release_ptl() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.pTl)
  _has_bits_[0] &= ~0x00000100u;
  ::rd::ApproxBoxPoints* temp = ptl_;
  ptl_ = nullptr;
  return temp;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::_internal_mutable_ptl() {
  _has_bits_[0] |= 0x00000100u;
  if (ptl_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::ApproxBoxPoints>(GetArenaForAllocation());
    ptl_ = p;
  }
  return ptl_;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::mutable_ptl() {
  ::rd::ApproxBoxPoints* _msg = _internal_mutable_ptl();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.pTl)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_ptl(::rd::ApproxBoxPoints* ptl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ptl_;
  }
  if (ptl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::ApproxBoxPoints>::GetOwningArena(ptl);
    if (message_arena != submessage_arena) {
      ptl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptl, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  ptl_ = ptl;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.pTl)
}

// optional .rd.ApproxBoxPoints pTr = 23;
inline bool QuadParkingSlot::_internal_has_ptr() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || ptr_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_ptr() const {
  return _internal_has_ptr();
}
inline void QuadParkingSlot::clear_ptr() {
  if (ptr_ != nullptr) ptr_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::rd::ApproxBoxPoints& QuadParkingSlot::_internal_ptr() const {
  const ::rd::ApproxBoxPoints* p = ptr_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::ApproxBoxPoints&>(
      ::rd::_ApproxBoxPoints_default_instance_);
}
inline const ::rd::ApproxBoxPoints& QuadParkingSlot::ptr() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.pTr)
  return _internal_ptr();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_ptr(
    ::rd::ApproxBoxPoints* ptr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ptr_);
  }
  ptr_ = ptr;
  if (ptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.pTr)
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::release_ptr() {
  _has_bits_[0] &= ~0x00000200u;
  ::rd::ApproxBoxPoints* temp = ptr_;
  ptr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::unsafe_arena_release_ptr() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.pTr)
  _has_bits_[0] &= ~0x00000200u;
  ::rd::ApproxBoxPoints* temp = ptr_;
  ptr_ = nullptr;
  return temp;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::_internal_mutable_ptr() {
  _has_bits_[0] |= 0x00000200u;
  if (ptr_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::ApproxBoxPoints>(GetArenaForAllocation());
    ptr_ = p;
  }
  return ptr_;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::mutable_ptr() {
  ::rd::ApproxBoxPoints* _msg = _internal_mutable_ptr();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.pTr)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_ptr(::rd::ApproxBoxPoints* ptr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ptr_;
  }
  if (ptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::ApproxBoxPoints>::GetOwningArena(ptr);
    if (message_arena != submessage_arena) {
      ptr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  ptr_ = ptr;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.pTr)
}

// optional .rd.ApproxBoxPoints pBl = 24;
inline bool QuadParkingSlot::_internal_has_pbl() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || pbl_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_pbl() const {
  return _internal_has_pbl();
}
inline void QuadParkingSlot::clear_pbl() {
  if (pbl_ != nullptr) pbl_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::rd::ApproxBoxPoints& QuadParkingSlot::_internal_pbl() const {
  const ::rd::ApproxBoxPoints* p = pbl_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::ApproxBoxPoints&>(
      ::rd::_ApproxBoxPoints_default_instance_);
}
inline const ::rd::ApproxBoxPoints& QuadParkingSlot::pbl() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.pBl)
  return _internal_pbl();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_pbl(
    ::rd::ApproxBoxPoints* pbl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pbl_);
  }
  pbl_ = pbl;
  if (pbl) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.pBl)
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::release_pbl() {
  _has_bits_[0] &= ~0x00000400u;
  ::rd::ApproxBoxPoints* temp = pbl_;
  pbl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::unsafe_arena_release_pbl() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.pBl)
  _has_bits_[0] &= ~0x00000400u;
  ::rd::ApproxBoxPoints* temp = pbl_;
  pbl_ = nullptr;
  return temp;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::_internal_mutable_pbl() {
  _has_bits_[0] |= 0x00000400u;
  if (pbl_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::ApproxBoxPoints>(GetArenaForAllocation());
    pbl_ = p;
  }
  return pbl_;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::mutable_pbl() {
  ::rd::ApproxBoxPoints* _msg = _internal_mutable_pbl();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.pBl)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_pbl(::rd::ApproxBoxPoints* pbl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pbl_;
  }
  if (pbl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::ApproxBoxPoints>::GetOwningArena(pbl);
    if (message_arena != submessage_arena) {
      pbl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pbl, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  pbl_ = pbl;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.pBl)
}

// optional .rd.ApproxBoxPoints pBr = 25;
inline bool QuadParkingSlot::_internal_has_pbr() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || pbr_ != nullptr);
  return value;
}
inline bool QuadParkingSlot::has_pbr() const {
  return _internal_has_pbr();
}
inline void QuadParkingSlot::clear_pbr() {
  if (pbr_ != nullptr) pbr_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::rd::ApproxBoxPoints& QuadParkingSlot::_internal_pbr() const {
  const ::rd::ApproxBoxPoints* p = pbr_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::ApproxBoxPoints&>(
      ::rd::_ApproxBoxPoints_default_instance_);
}
inline const ::rd::ApproxBoxPoints& QuadParkingSlot::pbr() const {
  // @@protoc_insertion_point(field_get:rd.QuadParkingSlot.pBr)
  return _internal_pbr();
}
inline void QuadParkingSlot::unsafe_arena_set_allocated_pbr(
    ::rd::ApproxBoxPoints* pbr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pbr_);
  }
  pbr_ = pbr;
  if (pbr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.QuadParkingSlot.pBr)
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::release_pbr() {
  _has_bits_[0] &= ~0x00000800u;
  ::rd::ApproxBoxPoints* temp = pbr_;
  pbr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::unsafe_arena_release_pbr() {
  // @@protoc_insertion_point(field_release:rd.QuadParkingSlot.pBr)
  _has_bits_[0] &= ~0x00000800u;
  ::rd::ApproxBoxPoints* temp = pbr_;
  pbr_ = nullptr;
  return temp;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::_internal_mutable_pbr() {
  _has_bits_[0] |= 0x00000800u;
  if (pbr_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::ApproxBoxPoints>(GetArenaForAllocation());
    pbr_ = p;
  }
  return pbr_;
}
inline ::rd::ApproxBoxPoints* QuadParkingSlot::mutable_pbr() {
  ::rd::ApproxBoxPoints* _msg = _internal_mutable_pbr();
  // @@protoc_insertion_point(field_mutable:rd.QuadParkingSlot.pBr)
  return _msg;
}
inline void QuadParkingSlot::set_allocated_pbr(::rd::ApproxBoxPoints* pbr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pbr_;
  }
  if (pbr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::ApproxBoxPoints>::GetOwningArena(pbr);
    if (message_arena != submessage_arena) {
      pbr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pbr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  pbr_ = pbr;
  // @@protoc_insertion_point(field_set_allocated:rd.QuadParkingSlot.pBr)
}

// -------------------------------------------------------------------

// Point2f

// optional float x = 1;
inline bool Point2f::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Point2f::has_x() const {
  return _internal_has_x();
}
inline void Point2f::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Point2f::_internal_x() const {
  return x_;
}
inline float Point2f::x() const {
  // @@protoc_insertion_point(field_get:rd.Point2f.x)
  return _internal_x();
}
inline void Point2f::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Point2f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:rd.Point2f.x)
}

// optional float y = 2;
inline bool Point2f::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Point2f::has_y() const {
  return _internal_has_y();
}
inline void Point2f::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Point2f::_internal_y() const {
  return y_;
}
inline float Point2f::y() const {
  // @@protoc_insertion_point(field_get:rd.Point2f.y)
  return _internal_y();
}
inline void Point2f::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Point2f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:rd.Point2f.y)
}

// -------------------------------------------------------------------

// ApproxBoxPoints

// optional .rd.Point2f point = 1;
inline bool ApproxBoxPoints::_internal_has_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || point_ != nullptr);
  return value;
}
inline bool ApproxBoxPoints::has_point() const {
  return _internal_has_point();
}
inline void ApproxBoxPoints::clear_point() {
  if (point_ != nullptr) point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::rd::Point2f& ApproxBoxPoints::_internal_point() const {
  const ::rd::Point2f* p = point_;
  return p != nullptr ? *p : reinterpret_cast<const ::rd::Point2f&>(
      ::rd::_Point2f_default_instance_);
}
inline const ::rd::Point2f& ApproxBoxPoints::point() const {
  // @@protoc_insertion_point(field_get:rd.ApproxBoxPoints.point)
  return _internal_point();
}
inline void ApproxBoxPoints::unsafe_arena_set_allocated_point(
    ::rd::Point2f* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rd.ApproxBoxPoints.point)
}
inline ::rd::Point2f* ApproxBoxPoints::release_point() {
  _has_bits_[0] &= ~0x00000001u;
  ::rd::Point2f* temp = point_;
  point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::rd::Point2f* ApproxBoxPoints::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:rd.ApproxBoxPoints.point)
  _has_bits_[0] &= ~0x00000001u;
  ::rd::Point2f* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::rd::Point2f* ApproxBoxPoints::_internal_mutable_point() {
  _has_bits_[0] |= 0x00000001u;
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::rd::Point2f>(GetArenaForAllocation());
    point_ = p;
  }
  return point_;
}
inline ::rd::Point2f* ApproxBoxPoints::mutable_point() {
  ::rd::Point2f* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:rd.ApproxBoxPoints.point)
  return _msg;
}
inline void ApproxBoxPoints::set_allocated_point(::rd::Point2f* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::rd::Point2f>::GetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:rd.ApproxBoxPoints.point)
}

// optional float borderDist = 2;
inline bool ApproxBoxPoints::_internal_has_borderdist() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApproxBoxPoints::has_borderdist() const {
  return _internal_has_borderdist();
}
inline void ApproxBoxPoints::clear_borderdist() {
  borderdist_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ApproxBoxPoints::_internal_borderdist() const {
  return borderdist_;
}
inline float ApproxBoxPoints::borderdist() const {
  // @@protoc_insertion_point(field_get:rd.ApproxBoxPoints.borderDist)
  return _internal_borderdist();
}
inline void ApproxBoxPoints::_internal_set_borderdist(float value) {
  _has_bits_[0] |= 0x00000002u;
  borderdist_ = value;
}
inline void ApproxBoxPoints::set_borderdist(float value) {
  _internal_set_borderdist(value);
  // @@protoc_insertion_point(field_set:rd.ApproxBoxPoints.borderDist)
}

// optional float pointScore = 3;
inline bool ApproxBoxPoints::_internal_has_pointscore() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ApproxBoxPoints::has_pointscore() const {
  return _internal_has_pointscore();
}
inline void ApproxBoxPoints::clear_pointscore() {
  pointscore_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ApproxBoxPoints::_internal_pointscore() const {
  return pointscore_;
}
inline float ApproxBoxPoints::pointscore() const {
  // @@protoc_insertion_point(field_get:rd.ApproxBoxPoints.pointScore)
  return _internal_pointscore();
}
inline void ApproxBoxPoints::_internal_set_pointscore(float value) {
  _has_bits_[0] |= 0x00000004u;
  pointscore_ = value;
}
inline void ApproxBoxPoints::set_pointscore(float value) {
  _internal_set_pointscore(value);
  // @@protoc_insertion_point(field_set:rd.ApproxBoxPoints.pointScore)
}

// optional float lineLen = 4;
inline bool ApproxBoxPoints::_internal_has_linelen() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApproxBoxPoints::has_linelen() const {
  return _internal_has_linelen();
}
inline void ApproxBoxPoints::clear_linelen() {
  linelen_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ApproxBoxPoints::_internal_linelen() const {
  return linelen_;
}
inline float ApproxBoxPoints::linelen() const {
  // @@protoc_insertion_point(field_get:rd.ApproxBoxPoints.lineLen)
  return _internal_linelen();
}
inline void ApproxBoxPoints::_internal_set_linelen(float value) {
  _has_bits_[0] |= 0x00000008u;
  linelen_ = value;
}
inline void ApproxBoxPoints::set_linelen(float value) {
  _internal_set_linelen(value);
  // @@protoc_insertion_point(field_set:rd.ApproxBoxPoints.lineLen)
}

// optional float lineScore = 5;
inline bool ApproxBoxPoints::_internal_has_linescore() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ApproxBoxPoints::has_linescore() const {
  return _internal_has_linescore();
}
inline void ApproxBoxPoints::clear_linescore() {
  linescore_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float ApproxBoxPoints::_internal_linescore() const {
  return linescore_;
}
inline float ApproxBoxPoints::linescore() const {
  // @@protoc_insertion_point(field_get:rd.ApproxBoxPoints.lineScore)
  return _internal_linescore();
}
inline void ApproxBoxPoints::_internal_set_linescore(float value) {
  _has_bits_[0] |= 0x00000010u;
  linescore_ = value;
}
inline void ApproxBoxPoints::set_linescore(float value) {
  _internal_set_linescore(value);
  // @@protoc_insertion_point(field_set:rd.ApproxBoxPoints.lineScore)
}

// optional bool hasBorderPoint = 6;
inline bool ApproxBoxPoints::_internal_has_hasborderpoint() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ApproxBoxPoints::has_hasborderpoint() const {
  return _internal_has_hasborderpoint();
}
inline void ApproxBoxPoints::clear_hasborderpoint() {
  hasborderpoint_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ApproxBoxPoints::_internal_hasborderpoint() const {
  return hasborderpoint_;
}
inline bool ApproxBoxPoints::hasborderpoint() const {
  // @@protoc_insertion_point(field_get:rd.ApproxBoxPoints.hasBorderPoint)
  return _internal_hasborderpoint();
}
inline void ApproxBoxPoints::_internal_set_hasborderpoint(bool value) {
  _has_bits_[0] |= 0x00000020u;
  hasborderpoint_ = value;
}
inline void ApproxBoxPoints::set_hasborderpoint(bool value) {
  _internal_set_hasborderpoint(value);
  // @@protoc_insertion_point(field_set:rd.ApproxBoxPoints.hasBorderPoint)
}

// -------------------------------------------------------------------

// Data_Row

// repeated int32 value = 1;
inline int Data_Row::_internal_value_size() const {
  return value_.size();
}
inline int Data_Row::value_size() const {
  return _internal_value_size();
}
inline void Data_Row::clear_value() {
  value_.Clear();
}
inline int32_t Data_Row::_internal_value(int index) const {
  return value_.Get(index);
}
inline int32_t Data_Row::value(int index) const {
  // @@protoc_insertion_point(field_get:rd.Data.Row.value)
  return _internal_value(index);
}
inline void Data_Row::set_value(int index, int32_t value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:rd.Data.Row.value)
}
inline void Data_Row::_internal_add_value(int32_t value) {
  value_.Add(value);
}
inline void Data_Row::add_value(int32_t value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:rd.Data.Row.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Data_Row::_internal_value() const {
  return value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Data_Row::value() const {
  // @@protoc_insertion_point(field_list:rd.Data.Row.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Data_Row::_internal_mutable_value() {
  return &value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Data_Row::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:rd.Data.Row.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// Data

// repeated .rd.Data.Row pt = 1;
inline int Data::_internal_pt_size() const {
  return pt_.size();
}
inline int Data::pt_size() const {
  return _internal_pt_size();
}
inline void Data::clear_pt() {
  pt_.Clear();
}
inline ::rd::Data_Row* Data::mutable_pt(int index) {
  // @@protoc_insertion_point(field_mutable:rd.Data.pt)
  return pt_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::Data_Row >*
Data::mutable_pt() {
  // @@protoc_insertion_point(field_mutable_list:rd.Data.pt)
  return &pt_;
}
inline const ::rd::Data_Row& Data::_internal_pt(int index) const {
  return pt_.Get(index);
}
inline const ::rd::Data_Row& Data::pt(int index) const {
  // @@protoc_insertion_point(field_get:rd.Data.pt)
  return _internal_pt(index);
}
inline ::rd::Data_Row* Data::_internal_add_pt() {
  return pt_.Add();
}
inline ::rd::Data_Row* Data::add_pt() {
  ::rd::Data_Row* _add = _internal_add_pt();
  // @@protoc_insertion_point(field_add:rd.Data.pt)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::rd::Data_Row >&
Data::pt() const {
  // @@protoc_insertion_point(field_list:rd.Data.pt)
  return pt_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rd

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::rd::Pstype> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rd::Pstype>() {
  return ::rd::Pstype_descriptor();
}
template <> struct is_proto_enum< ::rd::Memtype> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rd::Memtype>() {
  return ::rd::Memtype_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rd_2eproto
