// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: od.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_od_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_od_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_od_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_od_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_od_2eproto;
namespace od {
class Bbox2D;
struct Bbox2DDefaultTypeInternal;
extern Bbox2DDefaultTypeInternal _Bbox2D_default_instance_;
class DirectionInfo;
struct DirectionInfoDefaultTypeInternal;
extern DirectionInfoDefaultTypeInternal _DirectionInfo_default_instance_;
class FSLine;
struct FSLineDefaultTypeInternal;
extern FSLineDefaultTypeInternal _FSLine_default_instance_;
class FSLinePoint;
struct FSLinePointDefaultTypeInternal;
extern FSLinePointDefaultTypeInternal _FSLinePoint_default_instance_;
class FSLinesimple;
struct FSLinesimpleDefaultTypeInternal;
extern FSLinesimpleDefaultTypeInternal _FSLinesimple_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Matrix3f;
struct Matrix3fDefaultTypeInternal;
extern Matrix3fDefaultTypeInternal _Matrix3f_default_instance_;
class MotionInfo;
struct MotionInfoDefaultTypeInternal;
extern MotionInfoDefaultTypeInternal _MotionInfo_default_instance_;
class ObstacleCube;
struct ObstacleCubeDefaultTypeInternal;
extern ObstacleCubeDefaultTypeInternal _ObstacleCube_default_instance_;
class ObstacleCylindrical;
struct ObstacleCylindricalDefaultTypeInternal;
extern ObstacleCylindricalDefaultTypeInternal _ObstacleCylindrical_default_instance_;
class ObstacleRaw;
struct ObstacleRawDefaultTypeInternal;
extern ObstacleRawDefaultTypeInternal _ObstacleRaw_default_instance_;
class ObstacleTrajectory;
struct ObstacleTrajectoryDefaultTypeInternal;
extern ObstacleTrajectoryDefaultTypeInternal _ObstacleTrajectory_default_instance_;
class ObstacleTrajectoryPoint;
struct ObstacleTrajectoryPointDefaultTypeInternal;
extern ObstacleTrajectoryPointDefaultTypeInternal _ObstacleTrajectoryPoint_default_instance_;
class Obstacles;
struct ObstaclesDefaultTypeInternal;
extern ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
class Point2f;
struct Point2fDefaultTypeInternal;
extern Point2fDefaultTypeInternal _Point2f_default_instance_;
class PositionInfo;
struct PositionInfoDefaultTypeInternal;
extern PositionInfoDefaultTypeInternal _PositionInfo_default_instance_;
class Time;
struct TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
class UssRange;
struct UssRangeDefaultTypeInternal;
extern UssRangeDefaultTypeInternal _UssRange_default_instance_;
class Vector3d;
struct Vector3dDefaultTypeInternal;
extern Vector3dDefaultTypeInternal _Vector3d_default_instance_;
class Vector3f;
struct Vector3fDefaultTypeInternal;
extern Vector3fDefaultTypeInternal _Vector3f_default_instance_;
}  // namespace od
PROTOBUF_NAMESPACE_OPEN
template<> ::od::Bbox2D* Arena::CreateMaybeMessage<::od::Bbox2D>(Arena*);
template<> ::od::DirectionInfo* Arena::CreateMaybeMessage<::od::DirectionInfo>(Arena*);
template<> ::od::FSLine* Arena::CreateMaybeMessage<::od::FSLine>(Arena*);
template<> ::od::FSLinePoint* Arena::CreateMaybeMessage<::od::FSLinePoint>(Arena*);
template<> ::od::FSLinesimple* Arena::CreateMaybeMessage<::od::FSLinesimple>(Arena*);
template<> ::od::Header* Arena::CreateMaybeMessage<::od::Header>(Arena*);
template<> ::od::Matrix3f* Arena::CreateMaybeMessage<::od::Matrix3f>(Arena*);
template<> ::od::MotionInfo* Arena::CreateMaybeMessage<::od::MotionInfo>(Arena*);
template<> ::od::ObstacleCube* Arena::CreateMaybeMessage<::od::ObstacleCube>(Arena*);
template<> ::od::ObstacleCylindrical* Arena::CreateMaybeMessage<::od::ObstacleCylindrical>(Arena*);
template<> ::od::ObstacleRaw* Arena::CreateMaybeMessage<::od::ObstacleRaw>(Arena*);
template<> ::od::ObstacleTrajectory* Arena::CreateMaybeMessage<::od::ObstacleTrajectory>(Arena*);
template<> ::od::ObstacleTrajectoryPoint* Arena::CreateMaybeMessage<::od::ObstacleTrajectoryPoint>(Arena*);
template<> ::od::Obstacles* Arena::CreateMaybeMessage<::od::Obstacles>(Arena*);
template<> ::od::Point2f* Arena::CreateMaybeMessage<::od::Point2f>(Arena*);
template<> ::od::PositionInfo* Arena::CreateMaybeMessage<::od::PositionInfo>(Arena*);
template<> ::od::Time* Arena::CreateMaybeMessage<::od::Time>(Arena*);
template<> ::od::UssRange* Arena::CreateMaybeMessage<::od::UssRange>(Arena*);
template<> ::od::Vector3d* Arena::CreateMaybeMessage<::od::Vector3d>(Arena*);
template<> ::od::Vector3f* Arena::CreateMaybeMessage<::od::Vector3f>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace od {

enum MotionStatus : int {
  Unknown = 0,
  Moving = 1,
  Still = 2,
  MotionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MotionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MotionStatus_IsValid(int value);
constexpr MotionStatus MotionStatus_MIN = Unknown;
constexpr MotionStatus MotionStatus_MAX = Still;
constexpr int MotionStatus_ARRAYSIZE = MotionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionStatus_descriptor();
template<typename T>
inline const std::string& MotionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionStatus_descriptor(), enum_t_value);
}
inline bool MotionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionStatus>(
    MotionStatus_descriptor(), name, value);
}
enum SpaceLabel : int {
  vehicle = 0,
  pedestrian = 1,
  RoadEdge = 2,
  Wall = 3,
  TrafficCone = 4,
  Other = 5,
  SpaceLabel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpaceLabel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpaceLabel_IsValid(int value);
constexpr SpaceLabel SpaceLabel_MIN = vehicle;
constexpr SpaceLabel SpaceLabel_MAX = Other;
constexpr int SpaceLabel_ARRAYSIZE = SpaceLabel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpaceLabel_descriptor();
template<typename T>
inline const std::string& SpaceLabel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpaceLabel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpaceLabel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpaceLabel_descriptor(), enum_t_value);
}
inline bool SpaceLabel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpaceLabel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpaceLabel>(
    SpaceLabel_descriptor(), name, value);
}
// ===================================================================

class Obstacles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.Obstacles) */ {
 public:
  inline Obstacles() : Obstacles(nullptr) {}
  ~Obstacles() override;
  explicit constexpr Obstacles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Obstacles(const Obstacles& from);
  Obstacles(Obstacles&& from) noexcept
    : Obstacles() {
    *this = ::std::move(from);
  }

  inline Obstacles& operator=(const Obstacles& from) {
    CopyFrom(from);
    return *this;
  }
  inline Obstacles& operator=(Obstacles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Obstacles& default_instance() {
    return *internal_default_instance();
  }
  static inline const Obstacles* internal_default_instance() {
    return reinterpret_cast<const Obstacles*>(
               &_Obstacles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Obstacles& a, Obstacles& b) {
    a.Swap(&b);
  }
  inline void Swap(Obstacles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Obstacles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Obstacles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Obstacles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Obstacles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Obstacles& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.Obstacles";
  }
  protected:
  explicit Obstacles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCylindricalObstalcesFieldNumber = 2,
    kCubeObstaclesFieldNumber = 3,
    kRawObjectsFieldNumber = 4,
    kRangeUnitArrayFieldNumber = 5,
    kHeaderFieldNumber = 1,
  };
  // repeated .od.ObstacleCylindrical cylindricalObstalces = 2;
  int cylindricalobstalces_size() const;
  private:
  int _internal_cylindricalobstalces_size() const;
  public:
  void clear_cylindricalobstalces();
  ::od::ObstacleCylindrical* mutable_cylindricalobstalces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCylindrical >*
      mutable_cylindricalobstalces();
  private:
  const ::od::ObstacleCylindrical& _internal_cylindricalobstalces(int index) const;
  ::od::ObstacleCylindrical* _internal_add_cylindricalobstalces();
  public:
  const ::od::ObstacleCylindrical& cylindricalobstalces(int index) const;
  ::od::ObstacleCylindrical* add_cylindricalobstalces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCylindrical >&
      cylindricalobstalces() const;

  // repeated .od.ObstacleCube cubeObstacles = 3;
  int cubeobstacles_size() const;
  private:
  int _internal_cubeobstacles_size() const;
  public:
  void clear_cubeobstacles();
  ::od::ObstacleCube* mutable_cubeobstacles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCube >*
      mutable_cubeobstacles();
  private:
  const ::od::ObstacleCube& _internal_cubeobstacles(int index) const;
  ::od::ObstacleCube* _internal_add_cubeobstacles();
  public:
  const ::od::ObstacleCube& cubeobstacles(int index) const;
  ::od::ObstacleCube* add_cubeobstacles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCube >&
      cubeobstacles() const;

  // repeated .od.ObstacleRaw rawObjects = 4;
  int rawobjects_size() const;
  private:
  int _internal_rawobjects_size() const;
  public:
  void clear_rawobjects();
  ::od::ObstacleRaw* mutable_rawobjects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleRaw >*
      mutable_rawobjects();
  private:
  const ::od::ObstacleRaw& _internal_rawobjects(int index) const;
  ::od::ObstacleRaw* _internal_add_rawobjects();
  public:
  const ::od::ObstacleRaw& rawobjects(int index) const;
  ::od::ObstacleRaw* add_rawobjects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleRaw >&
      rawobjects() const;

  // repeated .od.UssRange rangeUnitArray = 5;
  int rangeunitarray_size() const;
  private:
  int _internal_rangeunitarray_size() const;
  public:
  void clear_rangeunitarray();
  ::od::UssRange* mutable_rangeunitarray(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::UssRange >*
      mutable_rangeunitarray();
  private:
  const ::od::UssRange& _internal_rangeunitarray(int index) const;
  ::od::UssRange* _internal_add_rangeunitarray();
  public:
  const ::od::UssRange& rangeunitarray(int index) const;
  ::od::UssRange* add_rangeunitarray();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::UssRange >&
      rangeunitarray() const;

  // optional .od.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::od::Header& header() const;
  PROTOBUF_NODISCARD ::od::Header* release_header();
  ::od::Header* mutable_header();
  void set_allocated_header(::od::Header* header);
  private:
  const ::od::Header& _internal_header() const;
  ::od::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::od::Header* header);
  ::od::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:od.Obstacles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCylindrical > cylindricalobstalces_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCube > cubeobstacles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleRaw > rawobjects_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::UssRange > rangeunitarray_;
  ::od::Header* header_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit constexpr Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Header& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameIdFieldNumber = 3,
    kTimestampNsFieldNumber = 2,
    kSeqFieldNumber = 1,
  };
  // optional string frameId = 3;
  bool has_frameid() const;
  private:
  bool _internal_has_frameid() const;
  public:
  void clear_frameid();
  const std::string& frameid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frameid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frameid();
  PROTOBUF_NODISCARD std::string* release_frameid();
  void set_allocated_frameid(std::string* frameid);
  private:
  const std::string& _internal_frameid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frameid(const std::string& value);
  std::string* _internal_mutable_frameid();
  public:

  // optional .od.Time timestampNs = 2;
  bool has_timestampns() const;
  private:
  bool _internal_has_timestampns() const;
  public:
  void clear_timestampns();
  const ::od::Time& timestampns() const;
  PROTOBUF_NODISCARD ::od::Time* release_timestampns();
  ::od::Time* mutable_timestampns();
  void set_allocated_timestampns(::od::Time* timestampns);
  private:
  const ::od::Time& _internal_timestampns() const;
  ::od::Time* _internal_mutable_timestampns();
  public:
  void unsafe_arena_set_allocated_timestampns(
      ::od::Time* timestampns);
  ::od::Time* unsafe_arena_release_timestampns();

  // optional uint32 seq = 1;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  uint32_t seq() const;
  void set_seq(uint32_t value);
  private:
  uint32_t _internal_seq() const;
  void _internal_set_seq(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:od.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frameid_;
  ::od::Time* timestampns_;
  uint32_t seq_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class Time final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.Time) */ {
 public:
  inline Time() : Time(nullptr) {}
  ~Time() override;
  explicit constexpr Time(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Time(const Time& from);
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  inline Time& operator=(Time&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Time& default_instance() {
    return *internal_default_instance();
  }
  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }
  inline void Swap(Time* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Time* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Time* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Time>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Time& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Time& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Time* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.Time";
  }
  protected:
  explicit Time(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNanoSecFieldNumber = 1,
  };
  // optional uint64 nanoSec = 1;
  bool has_nanosec() const;
  private:
  bool _internal_has_nanosec() const;
  public:
  void clear_nanosec();
  uint64_t nanosec() const;
  void set_nanosec(uint64_t value);
  private:
  uint64_t _internal_nanosec() const;
  void _internal_set_nanosec(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:od.Time)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t nanosec_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class ObstacleCylindrical final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.ObstacleCylindrical) */ {
 public:
  inline ObstacleCylindrical() : ObstacleCylindrical(nullptr) {}
  ~ObstacleCylindrical() override;
  explicit constexpr ObstacleCylindrical(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleCylindrical(const ObstacleCylindrical& from);
  ObstacleCylindrical(ObstacleCylindrical&& from) noexcept
    : ObstacleCylindrical() {
    *this = ::std::move(from);
  }

  inline ObstacleCylindrical& operator=(const ObstacleCylindrical& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleCylindrical& operator=(ObstacleCylindrical&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleCylindrical& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleCylindrical* internal_default_instance() {
    return reinterpret_cast<const ObstacleCylindrical*>(
               &_ObstacleCylindrical_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObstacleCylindrical& a, ObstacleCylindrical& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleCylindrical* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleCylindrical* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleCylindrical* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleCylindrical>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleCylindrical& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleCylindrical& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleCylindrical* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.ObstacleCylindrical";
  }
  protected:
  explicit ObstacleCylindrical(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryFieldNumber = 11,
    kCameraFieldNumber = 1,
    kCenterFieldNumber = 6,
    kDirectionFieldNumber = 9,
    kMotionInfoFieldNumber = 10,
    kLabelFieldNumber = 2,
    kTypeConfidenceFieldNumber = 3,
    kExistenceConfidenceFieldNumber = 4,
    kTrackIdFieldNumber = 5,
    kRadiusFieldNumber = 7,
    kHeightFieldNumber = 8,
    kStaticStateFieldNumber = 12,
    kAttrScoreFieldNumber = 13,
  };
  // repeated .od.ObstacleTrajectory trajectory = 11;
  int trajectory_size() const;
  private:
  int _internal_trajectory_size() const;
  public:
  void clear_trajectory();
  ::od::ObstacleTrajectory* mutable_trajectory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory >*
      mutable_trajectory();
  private:
  const ::od::ObstacleTrajectory& _internal_trajectory(int index) const;
  ::od::ObstacleTrajectory* _internal_add_trajectory();
  public:
  const ::od::ObstacleTrajectory& trajectory(int index) const;
  ::od::ObstacleTrajectory* add_trajectory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory >&
      trajectory() const;

  // optional string camera = 1;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const std::string& camera() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera();
  PROTOBUF_NODISCARD std::string* release_camera();
  void set_allocated_camera(std::string* camera);
  private:
  const std::string& _internal_camera() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera(const std::string& value);
  std::string* _internal_mutable_camera();
  public:

  // optional .od.Vector3d Center = 6;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::od::Vector3d& center() const;
  PROTOBUF_NODISCARD ::od::Vector3d* release_center();
  ::od::Vector3d* mutable_center();
  void set_allocated_center(::od::Vector3d* center);
  private:
  const ::od::Vector3d& _internal_center() const;
  ::od::Vector3d* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::od::Vector3d* center);
  ::od::Vector3d* unsafe_arena_release_center();

  // optional .od.Vector3d direction = 9;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::od::Vector3d& direction() const;
  PROTOBUF_NODISCARD ::od::Vector3d* release_direction();
  ::od::Vector3d* mutable_direction();
  void set_allocated_direction(::od::Vector3d* direction);
  private:
  const ::od::Vector3d& _internal_direction() const;
  ::od::Vector3d* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::od::Vector3d* direction);
  ::od::Vector3d* unsafe_arena_release_direction();

  // optional .od.MotionInfo motionInfo = 10;
  bool has_motioninfo() const;
  private:
  bool _internal_has_motioninfo() const;
  public:
  void clear_motioninfo();
  const ::od::MotionInfo& motioninfo() const;
  PROTOBUF_NODISCARD ::od::MotionInfo* release_motioninfo();
  ::od::MotionInfo* mutable_motioninfo();
  void set_allocated_motioninfo(::od::MotionInfo* motioninfo);
  private:
  const ::od::MotionInfo& _internal_motioninfo() const;
  ::od::MotionInfo* _internal_mutable_motioninfo();
  public:
  void unsafe_arena_set_allocated_motioninfo(
      ::od::MotionInfo* motioninfo);
  ::od::MotionInfo* unsafe_arena_release_motioninfo();

  // optional int32 label = 2;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  int32_t label() const;
  void set_label(int32_t value);
  private:
  int32_t _internal_label() const;
  void _internal_set_label(int32_t value);
  public:

  // optional float typeConfidence = 3;
  bool has_typeconfidence() const;
  private:
  bool _internal_has_typeconfidence() const;
  public:
  void clear_typeconfidence();
  float typeconfidence() const;
  void set_typeconfidence(float value);
  private:
  float _internal_typeconfidence() const;
  void _internal_set_typeconfidence(float value);
  public:

  // optional float existenceConfidence = 4;
  bool has_existenceconfidence() const;
  private:
  bool _internal_has_existenceconfidence() const;
  public:
  void clear_existenceconfidence();
  float existenceconfidence() const;
  void set_existenceconfidence(float value);
  private:
  float _internal_existenceconfidence() const;
  void _internal_set_existenceconfidence(float value);
  public:

  // optional int32 trackId = 5;
  bool has_trackid() const;
  private:
  bool _internal_has_trackid() const;
  public:
  void clear_trackid();
  int32_t trackid() const;
  void set_trackid(int32_t value);
  private:
  int32_t _internal_trackid() const;
  void _internal_set_trackid(int32_t value);
  public:

  // optional float radius = 7;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // optional float height = 8;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // optional int32 staticState = 12;
  bool has_staticstate() const;
  private:
  bool _internal_has_staticstate() const;
  public:
  void clear_staticstate();
  int32_t staticstate() const;
  void set_staticstate(int32_t value);
  private:
  int32_t _internal_staticstate() const;
  void _internal_set_staticstate(int32_t value);
  public:

  // optional float attrScore = 13;
  bool has_attrscore() const;
  private:
  bool _internal_has_attrscore() const;
  public:
  void clear_attrscore();
  float attrscore() const;
  void set_attrscore(float value);
  private:
  float _internal_attrscore() const;
  void _internal_set_attrscore(float value);
  public:

  // @@protoc_insertion_point(class_scope:od.ObstacleCylindrical)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory > trajectory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_;
  ::od::Vector3d* center_;
  ::od::Vector3d* direction_;
  ::od::MotionInfo* motioninfo_;
  int32_t label_;
  float typeconfidence_;
  float existenceconfidence_;
  int32_t trackid_;
  float radius_;
  float height_;
  int32_t staticstate_;
  float attrscore_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class Vector3d final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.Vector3d) */ {
 public:
  inline Vector3d() : Vector3d(nullptr) {}
  ~Vector3d() override;
  explicit constexpr Vector3d(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3d(const Vector3d& from);
  Vector3d(Vector3d&& from) noexcept
    : Vector3d() {
    *this = ::std::move(from);
  }

  inline Vector3d& operator=(const Vector3d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3d& operator=(Vector3d&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3d& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3d* internal_default_instance() {
    return reinterpret_cast<const Vector3d*>(
               &_Vector3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Vector3d& a, Vector3d& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3d* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3d* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3d>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3d& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector3d& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3d* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.Vector3d";
  }
  protected:
  explicit Vector3d(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:od.Vector3d)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class MotionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.MotionInfo) */ {
 public:
  inline MotionInfo() : MotionInfo(nullptr) {}
  ~MotionInfo() override;
  explicit constexpr MotionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionInfo(const MotionInfo& from);
  MotionInfo(MotionInfo&& from) noexcept
    : MotionInfo() {
    *this = ::std::move(from);
  }

  inline MotionInfo& operator=(const MotionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionInfo& operator=(MotionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionInfo* internal_default_instance() {
    return reinterpret_cast<const MotionInfo*>(
               &_MotionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MotionInfo& a, MotionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MotionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MotionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MotionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MotionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.MotionInfo";
  }
  protected:
  explicit MotionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 3,
    kCenterUncertaintyFieldNumber = 4,
    kVelocityFieldNumber = 5,
    kVelocityUncertaintyFieldNumber = 6,
    kAccelerationFieldNumber = 7,
    kAccelerationUncertaintyFieldNumber = 8,
    kJerkFieldNumber = 9,
    kJerkUncertaintyFieldNumber = 10,
    kIsValidFieldNumber = 1,
    kMotionStatusFieldNumber = 2,
    kVelocityHeadingFieldNumber = 11,
    kVelocityHeadingUncertaintyFieldNumber = 12,
    kVelocityHeadingRateFieldNumber = 13,
    kVelocityHeadingRateUncertaintyFieldNumber = 14,
  };
  // optional .od.Vector3d center = 3;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::od::Vector3d& center() const;
  PROTOBUF_NODISCARD ::od::Vector3d* release_center();
  ::od::Vector3d* mutable_center();
  void set_allocated_center(::od::Vector3d* center);
  private:
  const ::od::Vector3d& _internal_center() const;
  ::od::Vector3d* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::od::Vector3d* center);
  ::od::Vector3d* unsafe_arena_release_center();

  // optional .od.Matrix3f centerUncertainty = 4;
  bool has_centeruncertainty() const;
  private:
  bool _internal_has_centeruncertainty() const;
  public:
  void clear_centeruncertainty();
  const ::od::Matrix3f& centeruncertainty() const;
  PROTOBUF_NODISCARD ::od::Matrix3f* release_centeruncertainty();
  ::od::Matrix3f* mutable_centeruncertainty();
  void set_allocated_centeruncertainty(::od::Matrix3f* centeruncertainty);
  private:
  const ::od::Matrix3f& _internal_centeruncertainty() const;
  ::od::Matrix3f* _internal_mutable_centeruncertainty();
  public:
  void unsafe_arena_set_allocated_centeruncertainty(
      ::od::Matrix3f* centeruncertainty);
  ::od::Matrix3f* unsafe_arena_release_centeruncertainty();

  // optional .od.Vector3d velocity = 5;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::od::Vector3d& velocity() const;
  PROTOBUF_NODISCARD ::od::Vector3d* release_velocity();
  ::od::Vector3d* mutable_velocity();
  void set_allocated_velocity(::od::Vector3d* velocity);
  private:
  const ::od::Vector3d& _internal_velocity() const;
  ::od::Vector3d* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::od::Vector3d* velocity);
  ::od::Vector3d* unsafe_arena_release_velocity();

  // optional .od.Matrix3f velocityUncertainty = 6;
  bool has_velocityuncertainty() const;
  private:
  bool _internal_has_velocityuncertainty() const;
  public:
  void clear_velocityuncertainty();
  const ::od::Matrix3f& velocityuncertainty() const;
  PROTOBUF_NODISCARD ::od::Matrix3f* release_velocityuncertainty();
  ::od::Matrix3f* mutable_velocityuncertainty();
  void set_allocated_velocityuncertainty(::od::Matrix3f* velocityuncertainty);
  private:
  const ::od::Matrix3f& _internal_velocityuncertainty() const;
  ::od::Matrix3f* _internal_mutable_velocityuncertainty();
  public:
  void unsafe_arena_set_allocated_velocityuncertainty(
      ::od::Matrix3f* velocityuncertainty);
  ::od::Matrix3f* unsafe_arena_release_velocityuncertainty();

  // optional .od.Vector3d acceleration = 7;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::od::Vector3d& acceleration() const;
  PROTOBUF_NODISCARD ::od::Vector3d* release_acceleration();
  ::od::Vector3d* mutable_acceleration();
  void set_allocated_acceleration(::od::Vector3d* acceleration);
  private:
  const ::od::Vector3d& _internal_acceleration() const;
  ::od::Vector3d* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::od::Vector3d* acceleration);
  ::od::Vector3d* unsafe_arena_release_acceleration();

  // optional .od.Matrix3f accelerationUncertainty = 8;
  bool has_accelerationuncertainty() const;
  private:
  bool _internal_has_accelerationuncertainty() const;
  public:
  void clear_accelerationuncertainty();
  const ::od::Matrix3f& accelerationuncertainty() const;
  PROTOBUF_NODISCARD ::od::Matrix3f* release_accelerationuncertainty();
  ::od::Matrix3f* mutable_accelerationuncertainty();
  void set_allocated_accelerationuncertainty(::od::Matrix3f* accelerationuncertainty);
  private:
  const ::od::Matrix3f& _internal_accelerationuncertainty() const;
  ::od::Matrix3f* _internal_mutable_accelerationuncertainty();
  public:
  void unsafe_arena_set_allocated_accelerationuncertainty(
      ::od::Matrix3f* accelerationuncertainty);
  ::od::Matrix3f* unsafe_arena_release_accelerationuncertainty();

  // optional .od.Vector3f jerk = 9;
  bool has_jerk() const;
  private:
  bool _internal_has_jerk() const;
  public:
  void clear_jerk();
  const ::od::Vector3f& jerk() const;
  PROTOBUF_NODISCARD ::od::Vector3f* release_jerk();
  ::od::Vector3f* mutable_jerk();
  void set_allocated_jerk(::od::Vector3f* jerk);
  private:
  const ::od::Vector3f& _internal_jerk() const;
  ::od::Vector3f* _internal_mutable_jerk();
  public:
  void unsafe_arena_set_allocated_jerk(
      ::od::Vector3f* jerk);
  ::od::Vector3f* unsafe_arena_release_jerk();

  // optional .od.Matrix3f jerkUncertainty = 10;
  bool has_jerkuncertainty() const;
  private:
  bool _internal_has_jerkuncertainty() const;
  public:
  void clear_jerkuncertainty();
  const ::od::Matrix3f& jerkuncertainty() const;
  PROTOBUF_NODISCARD ::od::Matrix3f* release_jerkuncertainty();
  ::od::Matrix3f* mutable_jerkuncertainty();
  void set_allocated_jerkuncertainty(::od::Matrix3f* jerkuncertainty);
  private:
  const ::od::Matrix3f& _internal_jerkuncertainty() const;
  ::od::Matrix3f* _internal_mutable_jerkuncertainty();
  public:
  void unsafe_arena_set_allocated_jerkuncertainty(
      ::od::Matrix3f* jerkuncertainty);
  ::od::Matrix3f* unsafe_arena_release_jerkuncertainty();

  // optional bool isValid = 1;
  bool has_isvalid() const;
  private:
  bool _internal_has_isvalid() const;
  public:
  void clear_isvalid();
  bool isvalid() const;
  void set_isvalid(bool value);
  private:
  bool _internal_isvalid() const;
  void _internal_set_isvalid(bool value);
  public:

  // optional int32 motionStatus = 2;
  bool has_motionstatus() const;
  private:
  bool _internal_has_motionstatus() const;
  public:
  void clear_motionstatus();
  int32_t motionstatus() const;
  void set_motionstatus(int32_t value);
  private:
  int32_t _internal_motionstatus() const;
  void _internal_set_motionstatus(int32_t value);
  public:

  // optional float velocityHeading = 11;
  bool has_velocityheading() const;
  private:
  bool _internal_has_velocityheading() const;
  public:
  void clear_velocityheading();
  float velocityheading() const;
  void set_velocityheading(float value);
  private:
  float _internal_velocityheading() const;
  void _internal_set_velocityheading(float value);
  public:

  // optional float velocityHeadingUncertainty = 12;
  bool has_velocityheadinguncertainty() const;
  private:
  bool _internal_has_velocityheadinguncertainty() const;
  public:
  void clear_velocityheadinguncertainty();
  float velocityheadinguncertainty() const;
  void set_velocityheadinguncertainty(float value);
  private:
  float _internal_velocityheadinguncertainty() const;
  void _internal_set_velocityheadinguncertainty(float value);
  public:

  // optional float velocityHeadingRate = 13;
  bool has_velocityheadingrate() const;
  private:
  bool _internal_has_velocityheadingrate() const;
  public:
  void clear_velocityheadingrate();
  float velocityheadingrate() const;
  void set_velocityheadingrate(float value);
  private:
  float _internal_velocityheadingrate() const;
  void _internal_set_velocityheadingrate(float value);
  public:

  // optional float velocityHeadingRateUncertainty = 14;
  bool has_velocityheadingrateuncertainty() const;
  private:
  bool _internal_has_velocityheadingrateuncertainty() const;
  public:
  void clear_velocityheadingrateuncertainty();
  float velocityheadingrateuncertainty() const;
  void set_velocityheadingrateuncertainty(float value);
  private:
  float _internal_velocityheadingrateuncertainty() const;
  void _internal_set_velocityheadingrateuncertainty(float value);
  public:

  // @@protoc_insertion_point(class_scope:od.MotionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::od::Vector3d* center_;
  ::od::Matrix3f* centeruncertainty_;
  ::od::Vector3d* velocity_;
  ::od::Matrix3f* velocityuncertainty_;
  ::od::Vector3d* acceleration_;
  ::od::Matrix3f* accelerationuncertainty_;
  ::od::Vector3f* jerk_;
  ::od::Matrix3f* jerkuncertainty_;
  bool isvalid_;
  int32_t motionstatus_;
  float velocityheading_;
  float velocityheadinguncertainty_;
  float velocityheadingrate_;
  float velocityheadingrateuncertainty_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class Point2f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.Point2f) */ {
 public:
  inline Point2f() : Point2f(nullptr) {}
  ~Point2f() override;
  explicit constexpr Point2f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point2f(const Point2f& from);
  Point2f(Point2f&& from) noexcept
    : Point2f() {
    *this = ::std::move(from);
  }

  inline Point2f& operator=(const Point2f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point2f& operator=(Point2f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point2f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point2f* internal_default_instance() {
    return reinterpret_cast<const Point2f*>(
               &_Point2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Point2f& a, Point2f& b) {
    a.Swap(&b);
  }
  inline void Swap(Point2f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point2f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point2f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point2f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point2f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Point2f& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.Point2f";
  }
  protected:
  explicit Point2f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:od.Point2f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class Vector3f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.Vector3f) */ {
 public:
  inline Vector3f() : Vector3f(nullptr) {}
  ~Vector3f() override;
  explicit constexpr Vector3f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3f(const Vector3f& from);
  Vector3f(Vector3f&& from) noexcept
    : Vector3f() {
    *this = ::std::move(from);
  }

  inline Vector3f& operator=(const Vector3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3f& operator=(Vector3f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3f* internal_default_instance() {
    return reinterpret_cast<const Vector3f*>(
               &_Vector3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Vector3f& a, Vector3f& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector3f& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.Vector3f";
  }
  protected:
  explicit Vector3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:od.Vector3f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class Matrix3f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.Matrix3f) */ {
 public:
  inline Matrix3f() : Matrix3f(nullptr) {}
  ~Matrix3f() override;
  explicit constexpr Matrix3f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Matrix3f(const Matrix3f& from);
  Matrix3f(Matrix3f&& from) noexcept
    : Matrix3f() {
    *this = ::std::move(from);
  }

  inline Matrix3f& operator=(const Matrix3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline Matrix3f& operator=(Matrix3f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Matrix3f& default_instance() {
    return *internal_default_instance();
  }
  static inline const Matrix3f* internal_default_instance() {
    return reinterpret_cast<const Matrix3f*>(
               &_Matrix3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Matrix3f& a, Matrix3f& b) {
    a.Swap(&b);
  }
  inline void Swap(Matrix3f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Matrix3f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Matrix3f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Matrix3f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Matrix3f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Matrix3f& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Matrix3f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.Matrix3f";
  }
  protected:
  explicit Matrix3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional .od.Vector3f x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const ::od::Vector3f& x() const;
  PROTOBUF_NODISCARD ::od::Vector3f* release_x();
  ::od::Vector3f* mutable_x();
  void set_allocated_x(::od::Vector3f* x);
  private:
  const ::od::Vector3f& _internal_x() const;
  ::od::Vector3f* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      ::od::Vector3f* x);
  ::od::Vector3f* unsafe_arena_release_x();

  // optional .od.Vector3f y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const ::od::Vector3f& y() const;
  PROTOBUF_NODISCARD ::od::Vector3f* release_y();
  ::od::Vector3f* mutable_y();
  void set_allocated_y(::od::Vector3f* y);
  private:
  const ::od::Vector3f& _internal_y() const;
  ::od::Vector3f* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      ::od::Vector3f* y);
  ::od::Vector3f* unsafe_arena_release_y();

  // optional .od.Vector3f z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  const ::od::Vector3f& z() const;
  PROTOBUF_NODISCARD ::od::Vector3f* release_z();
  ::od::Vector3f* mutable_z();
  void set_allocated_z(::od::Vector3f* z);
  private:
  const ::od::Vector3f& _internal_z() const;
  ::od::Vector3f* _internal_mutable_z();
  public:
  void unsafe_arena_set_allocated_z(
      ::od::Vector3f* z);
  ::od::Vector3f* unsafe_arena_release_z();

  // @@protoc_insertion_point(class_scope:od.Matrix3f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::od::Vector3f* x_;
  ::od::Vector3f* y_;
  ::od::Vector3f* z_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class ObstacleCube final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.ObstacleCube) */ {
 public:
  inline ObstacleCube() : ObstacleCube(nullptr) {}
  ~ObstacleCube() override;
  explicit constexpr ObstacleCube(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleCube(const ObstacleCube& from);
  ObstacleCube(ObstacleCube&& from) noexcept
    : ObstacleCube() {
    *this = ::std::move(from);
  }

  inline ObstacleCube& operator=(const ObstacleCube& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleCube& operator=(ObstacleCube&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleCube& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleCube* internal_default_instance() {
    return reinterpret_cast<const ObstacleCube*>(
               &_ObstacleCube_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ObstacleCube& a, ObstacleCube& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleCube* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleCube* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleCube* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleCube>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleCube& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleCube& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleCube* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.ObstacleCube";
  }
  protected:
  explicit ObstacleCube(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryFieldNumber = 10,
    kCameraFieldNumber = 1,
    kCenterFieldNumber = 6,
    kShapeFieldNumber = 7,
    kDirectionFieldNumber = 8,
    kMotionInfoFieldNumber = 9,
    kLabelFieldNumber = 2,
    kTypeConfidenceFieldNumber = 3,
    kExistenceConfidenceFieldNumber = 4,
    kTrackIdFieldNumber = 5,
  };
  // repeated .od.ObstacleTrajectory trajectory = 10;
  int trajectory_size() const;
  private:
  int _internal_trajectory_size() const;
  public:
  void clear_trajectory();
  ::od::ObstacleTrajectory* mutable_trajectory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory >*
      mutable_trajectory();
  private:
  const ::od::ObstacleTrajectory& _internal_trajectory(int index) const;
  ::od::ObstacleTrajectory* _internal_add_trajectory();
  public:
  const ::od::ObstacleTrajectory& trajectory(int index) const;
  ::od::ObstacleTrajectory* add_trajectory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory >&
      trajectory() const;

  // optional string camera = 1;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const std::string& camera() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera();
  PROTOBUF_NODISCARD std::string* release_camera();
  void set_allocated_camera(std::string* camera);
  private:
  const std::string& _internal_camera() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera(const std::string& value);
  std::string* _internal_mutable_camera();
  public:

  // optional .od.Vector3d Center = 6;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::od::Vector3d& center() const;
  PROTOBUF_NODISCARD ::od::Vector3d* release_center();
  ::od::Vector3d* mutable_center();
  void set_allocated_center(::od::Vector3d* center);
  private:
  const ::od::Vector3d& _internal_center() const;
  ::od::Vector3d* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::od::Vector3d* center);
  ::od::Vector3d* unsafe_arena_release_center();

  // optional .od.Vector3d shape = 7;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const ::od::Vector3d& shape() const;
  PROTOBUF_NODISCARD ::od::Vector3d* release_shape();
  ::od::Vector3d* mutable_shape();
  void set_allocated_shape(::od::Vector3d* shape);
  private:
  const ::od::Vector3d& _internal_shape() const;
  ::od::Vector3d* _internal_mutable_shape();
  public:
  void unsafe_arena_set_allocated_shape(
      ::od::Vector3d* shape);
  ::od::Vector3d* unsafe_arena_release_shape();

  // optional .od.Vector3d direction = 8;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::od::Vector3d& direction() const;
  PROTOBUF_NODISCARD ::od::Vector3d* release_direction();
  ::od::Vector3d* mutable_direction();
  void set_allocated_direction(::od::Vector3d* direction);
  private:
  const ::od::Vector3d& _internal_direction() const;
  ::od::Vector3d* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::od::Vector3d* direction);
  ::od::Vector3d* unsafe_arena_release_direction();

  // optional .od.MotionInfo motionInfo = 9;
  bool has_motioninfo() const;
  private:
  bool _internal_has_motioninfo() const;
  public:
  void clear_motioninfo();
  const ::od::MotionInfo& motioninfo() const;
  PROTOBUF_NODISCARD ::od::MotionInfo* release_motioninfo();
  ::od::MotionInfo* mutable_motioninfo();
  void set_allocated_motioninfo(::od::MotionInfo* motioninfo);
  private:
  const ::od::MotionInfo& _internal_motioninfo() const;
  ::od::MotionInfo* _internal_mutable_motioninfo();
  public:
  void unsafe_arena_set_allocated_motioninfo(
      ::od::MotionInfo* motioninfo);
  ::od::MotionInfo* unsafe_arena_release_motioninfo();

  // optional int32 label = 2;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  int32_t label() const;
  void set_label(int32_t value);
  private:
  int32_t _internal_label() const;
  void _internal_set_label(int32_t value);
  public:

  // optional float typeConfidence = 3;
  bool has_typeconfidence() const;
  private:
  bool _internal_has_typeconfidence() const;
  public:
  void clear_typeconfidence();
  float typeconfidence() const;
  void set_typeconfidence(float value);
  private:
  float _internal_typeconfidence() const;
  void _internal_set_typeconfidence(float value);
  public:

  // optional float existenceConfidence = 4;
  bool has_existenceconfidence() const;
  private:
  bool _internal_has_existenceconfidence() const;
  public:
  void clear_existenceconfidence();
  float existenceconfidence() const;
  void set_existenceconfidence(float value);
  private:
  float _internal_existenceconfidence() const;
  void _internal_set_existenceconfidence(float value);
  public:

  // optional int32 trackId = 5;
  bool has_trackid() const;
  private:
  bool _internal_has_trackid() const;
  public:
  void clear_trackid();
  int32_t trackid() const;
  void set_trackid(int32_t value);
  private:
  int32_t _internal_trackid() const;
  void _internal_set_trackid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:od.ObstacleCube)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory > trajectory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_;
  ::od::Vector3d* center_;
  ::od::Vector3d* shape_;
  ::od::Vector3d* direction_;
  ::od::MotionInfo* motioninfo_;
  int32_t label_;
  float typeconfidence_;
  float existenceconfidence_;
  int32_t trackid_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class ObstacleTrajectory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.ObstacleTrajectory) */ {
 public:
  inline ObstacleTrajectory() : ObstacleTrajectory(nullptr) {}
  ~ObstacleTrajectory() override;
  explicit constexpr ObstacleTrajectory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleTrajectory(const ObstacleTrajectory& from);
  ObstacleTrajectory(ObstacleTrajectory&& from) noexcept
    : ObstacleTrajectory() {
    *this = ::std::move(from);
  }

  inline ObstacleTrajectory& operator=(const ObstacleTrajectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleTrajectory& operator=(ObstacleTrajectory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleTrajectory& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleTrajectory* internal_default_instance() {
    return reinterpret_cast<const ObstacleTrajectory*>(
               &_ObstacleTrajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ObstacleTrajectory& a, ObstacleTrajectory& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleTrajectory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleTrajectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleTrajectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleTrajectory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleTrajectory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleTrajectory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleTrajectory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.ObstacleTrajectory";
  }
  protected:
  explicit ObstacleTrajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 3,
    kMotionStatusFieldNumber = 1,
    kConfidenceFieldNumber = 2,
  };
  // repeated .od.ObstacleTrajectoryPoint points = 3;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::od::ObstacleTrajectoryPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectoryPoint >*
      mutable_points();
  private:
  const ::od::ObstacleTrajectoryPoint& _internal_points(int index) const;
  ::od::ObstacleTrajectoryPoint* _internal_add_points();
  public:
  const ::od::ObstacleTrajectoryPoint& points(int index) const;
  ::od::ObstacleTrajectoryPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectoryPoint >&
      points() const;

  // optional .od.MotionStatus motionStatus = 1;
  bool has_motionstatus() const;
  private:
  bool _internal_has_motionstatus() const;
  public:
  void clear_motionstatus();
  ::od::MotionStatus motionstatus() const;
  void set_motionstatus(::od::MotionStatus value);
  private:
  ::od::MotionStatus _internal_motionstatus() const;
  void _internal_set_motionstatus(::od::MotionStatus value);
  public:

  // optional float confidence = 2;
  bool has_confidence() const;
  private:
  bool _internal_has_confidence() const;
  public:
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:od.ObstacleTrajectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectoryPoint > points_;
  int motionstatus_;
  float confidence_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class ObstacleTrajectoryPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.ObstacleTrajectoryPoint) */ {
 public:
  inline ObstacleTrajectoryPoint() : ObstacleTrajectoryPoint(nullptr) {}
  ~ObstacleTrajectoryPoint() override;
  explicit constexpr ObstacleTrajectoryPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleTrajectoryPoint(const ObstacleTrajectoryPoint& from);
  ObstacleTrajectoryPoint(ObstacleTrajectoryPoint&& from) noexcept
    : ObstacleTrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline ObstacleTrajectoryPoint& operator=(const ObstacleTrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleTrajectoryPoint& operator=(ObstacleTrajectoryPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleTrajectoryPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleTrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const ObstacleTrajectoryPoint*>(
               &_ObstacleTrajectoryPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ObstacleTrajectoryPoint& a, ObstacleTrajectoryPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleTrajectoryPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleTrajectoryPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleTrajectoryPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleTrajectoryPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleTrajectoryPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleTrajectoryPoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleTrajectoryPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.ObstacleTrajectoryPoint";
  }
  protected:
  explicit ObstacleTrajectoryPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 2,
    kDirectionFieldNumber = 3,
    kDeltaTNsFieldNumber = 1,
  };
  // optional .od.Vector3f center = 2;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::od::Vector3f& center() const;
  PROTOBUF_NODISCARD ::od::Vector3f* release_center();
  ::od::Vector3f* mutable_center();
  void set_allocated_center(::od::Vector3f* center);
  private:
  const ::od::Vector3f& _internal_center() const;
  ::od::Vector3f* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::od::Vector3f* center);
  ::od::Vector3f* unsafe_arena_release_center();

  // optional .od.Vector3f direction = 3;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::od::Vector3f& direction() const;
  PROTOBUF_NODISCARD ::od::Vector3f* release_direction();
  ::od::Vector3f* mutable_direction();
  void set_allocated_direction(::od::Vector3f* direction);
  private:
  const ::od::Vector3f& _internal_direction() const;
  ::od::Vector3f* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::od::Vector3f* direction);
  ::od::Vector3f* unsafe_arena_release_direction();

  // optional uint64 deltaTNs = 1;
  bool has_deltatns() const;
  private:
  bool _internal_has_deltatns() const;
  public:
  void clear_deltatns();
  uint64_t deltatns() const;
  void set_deltatns(uint64_t value);
  private:
  uint64_t _internal_deltatns() const;
  void _internal_set_deltatns(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:od.ObstacleTrajectoryPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::od::Vector3f* center_;
  ::od::Vector3f* direction_;
  uint64_t deltatns_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class ObstacleRaw final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.ObstacleRaw) */ {
 public:
  inline ObstacleRaw() : ObstacleRaw(nullptr) {}
  ~ObstacleRaw() override;
  explicit constexpr ObstacleRaw(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObstacleRaw(const ObstacleRaw& from);
  ObstacleRaw(ObstacleRaw&& from) noexcept
    : ObstacleRaw() {
    *this = ::std::move(from);
  }

  inline ObstacleRaw& operator=(const ObstacleRaw& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleRaw& operator=(ObstacleRaw&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObstacleRaw& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObstacleRaw* internal_default_instance() {
    return reinterpret_cast<const ObstacleRaw*>(
               &_ObstacleRaw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ObstacleRaw& a, ObstacleRaw& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleRaw* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleRaw* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObstacleRaw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObstacleRaw>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObstacleRaw& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObstacleRaw& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleRaw* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.ObstacleRaw";
  }
  protected:
  explicit ObstacleRaw(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLandmarkFieldNumber = 7,
    kLandmarkScoresFieldNumber = 8,
    kLandmark4FieldNumber = 9,
    kLandmark4ScoresFieldNumber = 10,
    kLandmark9FieldNumber = 11,
    kLandmark9ScoresFieldNumber = 12,
    kBox3DFieldNumber = 14,
    kCameraFieldNumber = 1,
    kBox2DFieldNumber = 5,
    kDirectionInfoFieldNumber = 6,
    kPositionInfoFieldNumber = 13,
    kLabelFieldNumber = 2,
    kTypeConfidenceFieldNumber = 3,
    kExistenceConfidenceFieldNumber = 4,
    kStaticStateFieldNumber = 15,
    kAttrScoreFieldNumber = 16,
  };
  // repeated .od.Point2f landmark = 7;
  int landmark_size() const;
  private:
  int _internal_landmark_size() const;
  public:
  void clear_landmark();
  ::od::Point2f* mutable_landmark(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >*
      mutable_landmark();
  private:
  const ::od::Point2f& _internal_landmark(int index) const;
  ::od::Point2f* _internal_add_landmark();
  public:
  const ::od::Point2f& landmark(int index) const;
  ::od::Point2f* add_landmark();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >&
      landmark() const;

  // repeated float landmarkScores = 8;
  int landmarkscores_size() const;
  private:
  int _internal_landmarkscores_size() const;
  public:
  void clear_landmarkscores();
  private:
  float _internal_landmarkscores(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_landmarkscores() const;
  void _internal_add_landmarkscores(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_landmarkscores();
  public:
  float landmarkscores(int index) const;
  void set_landmarkscores(int index, float value);
  void add_landmarkscores(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      landmarkscores() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_landmarkscores();

  // repeated .od.Point2f landmark4 = 9;
  int landmark4_size() const;
  private:
  int _internal_landmark4_size() const;
  public:
  void clear_landmark4();
  ::od::Point2f* mutable_landmark4(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >*
      mutable_landmark4();
  private:
  const ::od::Point2f& _internal_landmark4(int index) const;
  ::od::Point2f* _internal_add_landmark4();
  public:
  const ::od::Point2f& landmark4(int index) const;
  ::od::Point2f* add_landmark4();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >&
      landmark4() const;

  // repeated float landmark4Scores = 10;
  int landmark4scores_size() const;
  private:
  int _internal_landmark4scores_size() const;
  public:
  void clear_landmark4scores();
  private:
  float _internal_landmark4scores(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_landmark4scores() const;
  void _internal_add_landmark4scores(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_landmark4scores();
  public:
  float landmark4scores(int index) const;
  void set_landmark4scores(int index, float value);
  void add_landmark4scores(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      landmark4scores() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_landmark4scores();

  // repeated .od.Point2f landmark9 = 11;
  int landmark9_size() const;
  private:
  int _internal_landmark9_size() const;
  public:
  void clear_landmark9();
  ::od::Point2f* mutable_landmark9(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >*
      mutable_landmark9();
  private:
  const ::od::Point2f& _internal_landmark9(int index) const;
  ::od::Point2f* _internal_add_landmark9();
  public:
  const ::od::Point2f& landmark9(int index) const;
  ::od::Point2f* add_landmark9();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >&
      landmark9() const;

  // repeated float landmark9Scores = 12;
  int landmark9scores_size() const;
  private:
  int _internal_landmark9scores_size() const;
  public:
  void clear_landmark9scores();
  private:
  float _internal_landmark9scores(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_landmark9scores() const;
  void _internal_add_landmark9scores(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_landmark9scores();
  public:
  float landmark9scores(int index) const;
  void set_landmark9scores(int index, float value);
  void add_landmark9scores(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      landmark9scores() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_landmark9scores();

  // repeated float box3D = 14;
  int box3d_size() const;
  private:
  int _internal_box3d_size() const;
  public:
  void clear_box3d();
  private:
  float _internal_box3d(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_box3d() const;
  void _internal_add_box3d(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_box3d();
  public:
  float box3d(int index) const;
  void set_box3d(int index, float value);
  void add_box3d(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      box3d() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_box3d();

  // optional string camera = 1;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const std::string& camera() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera();
  PROTOBUF_NODISCARD std::string* release_camera();
  void set_allocated_camera(std::string* camera);
  private:
  const std::string& _internal_camera() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera(const std::string& value);
  std::string* _internal_mutable_camera();
  public:

  // optional .od.Bbox2D box2D = 5;
  bool has_box2d() const;
  private:
  bool _internal_has_box2d() const;
  public:
  void clear_box2d();
  const ::od::Bbox2D& box2d() const;
  PROTOBUF_NODISCARD ::od::Bbox2D* release_box2d();
  ::od::Bbox2D* mutable_box2d();
  void set_allocated_box2d(::od::Bbox2D* box2d);
  private:
  const ::od::Bbox2D& _internal_box2d() const;
  ::od::Bbox2D* _internal_mutable_box2d();
  public:
  void unsafe_arena_set_allocated_box2d(
      ::od::Bbox2D* box2d);
  ::od::Bbox2D* unsafe_arena_release_box2d();

  // optional .od.DirectionInfo directionInfo = 6;
  bool has_directioninfo() const;
  private:
  bool _internal_has_directioninfo() const;
  public:
  void clear_directioninfo();
  const ::od::DirectionInfo& directioninfo() const;
  PROTOBUF_NODISCARD ::od::DirectionInfo* release_directioninfo();
  ::od::DirectionInfo* mutable_directioninfo();
  void set_allocated_directioninfo(::od::DirectionInfo* directioninfo);
  private:
  const ::od::DirectionInfo& _internal_directioninfo() const;
  ::od::DirectionInfo* _internal_mutable_directioninfo();
  public:
  void unsafe_arena_set_allocated_directioninfo(
      ::od::DirectionInfo* directioninfo);
  ::od::DirectionInfo* unsafe_arena_release_directioninfo();

  // optional .od.PositionInfo positionInfo = 13;
  bool has_positioninfo() const;
  private:
  bool _internal_has_positioninfo() const;
  public:
  void clear_positioninfo();
  const ::od::PositionInfo& positioninfo() const;
  PROTOBUF_NODISCARD ::od::PositionInfo* release_positioninfo();
  ::od::PositionInfo* mutable_positioninfo();
  void set_allocated_positioninfo(::od::PositionInfo* positioninfo);
  private:
  const ::od::PositionInfo& _internal_positioninfo() const;
  ::od::PositionInfo* _internal_mutable_positioninfo();
  public:
  void unsafe_arena_set_allocated_positioninfo(
      ::od::PositionInfo* positioninfo);
  ::od::PositionInfo* unsafe_arena_release_positioninfo();

  // optional int32 label = 2;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  int32_t label() const;
  void set_label(int32_t value);
  private:
  int32_t _internal_label() const;
  void _internal_set_label(int32_t value);
  public:

  // optional float typeConfidence = 3;
  bool has_typeconfidence() const;
  private:
  bool _internal_has_typeconfidence() const;
  public:
  void clear_typeconfidence();
  float typeconfidence() const;
  void set_typeconfidence(float value);
  private:
  float _internal_typeconfidence() const;
  void _internal_set_typeconfidence(float value);
  public:

  // optional float existenceConfidence = 4;
  bool has_existenceconfidence() const;
  private:
  bool _internal_has_existenceconfidence() const;
  public:
  void clear_existenceconfidence();
  float existenceconfidence() const;
  void set_existenceconfidence(float value);
  private:
  float _internal_existenceconfidence() const;
  void _internal_set_existenceconfidence(float value);
  public:

  // optional int32 staticState = 15;
  bool has_staticstate() const;
  private:
  bool _internal_has_staticstate() const;
  public:
  void clear_staticstate();
  int32_t staticstate() const;
  void set_staticstate(int32_t value);
  private:
  int32_t _internal_staticstate() const;
  void _internal_set_staticstate(int32_t value);
  public:

  // optional float attrScore = 16;
  bool has_attrscore() const;
  private:
  bool _internal_has_attrscore() const;
  public:
  void clear_attrscore();
  float attrscore() const;
  void set_attrscore(float value);
  private:
  float _internal_attrscore() const;
  void _internal_set_attrscore(float value);
  public:

  // @@protoc_insertion_point(class_scope:od.ObstacleRaw)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f > landmark_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > landmarkscores_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f > landmark4_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > landmark4scores_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f > landmark9_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > landmark9scores_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > box3d_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_;
  ::od::Bbox2D* box2d_;
  ::od::DirectionInfo* directioninfo_;
  ::od::PositionInfo* positioninfo_;
  int32_t label_;
  float typeconfidence_;
  float existenceconfidence_;
  int32_t staticstate_;
  float attrscore_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class Bbox2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.Bbox2D) */ {
 public:
  inline Bbox2D() : Bbox2D(nullptr) {}
  ~Bbox2D() override;
  explicit constexpr Bbox2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bbox2D(const Bbox2D& from);
  Bbox2D(Bbox2D&& from) noexcept
    : Bbox2D() {
    *this = ::std::move(from);
  }

  inline Bbox2D& operator=(const Bbox2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bbox2D& operator=(Bbox2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bbox2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bbox2D* internal_default_instance() {
    return reinterpret_cast<const Bbox2D*>(
               &_Bbox2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Bbox2D& a, Bbox2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Bbox2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bbox2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bbox2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bbox2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bbox2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Bbox2D& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bbox2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.Bbox2D";
  }
  protected:
  explicit Bbox2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitializedFieldNumber = 1,
    kTopLeftXFieldNumber = 2,
    kTopLeftYFieldNumber = 3,
    kBottomRightXFieldNumber = 4,
    kBottomRightYFieldNumber = 5,
    kConfidenceFieldNumber = 6,
  };
  // optional bool initialized = 1;
  bool has_initialized() const;
  private:
  bool _internal_has_initialized() const;
  public:
  void clear_initialized();
  bool initialized() const;
  void set_initialized(bool value);
  private:
  bool _internal_initialized() const;
  void _internal_set_initialized(bool value);
  public:

  // optional float topLeftX = 2;
  bool has_topleftx() const;
  private:
  bool _internal_has_topleftx() const;
  public:
  void clear_topleftx();
  float topleftx() const;
  void set_topleftx(float value);
  private:
  float _internal_topleftx() const;
  void _internal_set_topleftx(float value);
  public:

  // optional float topLeftY = 3;
  bool has_toplefty() const;
  private:
  bool _internal_has_toplefty() const;
  public:
  void clear_toplefty();
  float toplefty() const;
  void set_toplefty(float value);
  private:
  float _internal_toplefty() const;
  void _internal_set_toplefty(float value);
  public:

  // optional float bottomRightX = 4;
  bool has_bottomrightx() const;
  private:
  bool _internal_has_bottomrightx() const;
  public:
  void clear_bottomrightx();
  float bottomrightx() const;
  void set_bottomrightx(float value);
  private:
  float _internal_bottomrightx() const;
  void _internal_set_bottomrightx(float value);
  public:

  // optional float bottomRightY = 5;
  bool has_bottomrighty() const;
  private:
  bool _internal_has_bottomrighty() const;
  public:
  void clear_bottomrighty();
  float bottomrighty() const;
  void set_bottomrighty(float value);
  private:
  float _internal_bottomrighty() const;
  void _internal_set_bottomrighty(float value);
  public:

  // optional float confidence = 6;
  bool has_confidence() const;
  private:
  bool _internal_has_confidence() const;
  public:
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:od.Bbox2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool initialized_;
  float topleftx_;
  float toplefty_;
  float bottomrightx_;
  float bottomrighty_;
  float confidence_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class DirectionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.DirectionInfo) */ {
 public:
  inline DirectionInfo() : DirectionInfo(nullptr) {}
  ~DirectionInfo() override;
  explicit constexpr DirectionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionInfo(const DirectionInfo& from);
  DirectionInfo(DirectionInfo&& from) noexcept
    : DirectionInfo() {
    *this = ::std::move(from);
  }

  inline DirectionInfo& operator=(const DirectionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionInfo& operator=(DirectionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionInfo* internal_default_instance() {
    return reinterpret_cast<const DirectionInfo*>(
               &_DirectionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DirectionInfo& a, DirectionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirectionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DirectionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.DirectionInfo";
  }
  protected:
  explicit DirectionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionYprFieldNumber = 2,
    kDirectionYprUncertaintyFieldNumber = 3,
    kIsValidFieldNumber = 1,
    kYawFieldNumber = 4,
    kYawUncertaintyFieldNumber = 5,
    kYawRateFieldNumber = 6,
    kYawRateUncertaintyFieldNumber = 7,
    kSurfaceFieldNumber = 8,
    kSurfaceScoreFieldNumber = 9,
  };
  // optional .od.Vector3f directionYpr = 2;
  bool has_directionypr() const;
  private:
  bool _internal_has_directionypr() const;
  public:
  void clear_directionypr();
  const ::od::Vector3f& directionypr() const;
  PROTOBUF_NODISCARD ::od::Vector3f* release_directionypr();
  ::od::Vector3f* mutable_directionypr();
  void set_allocated_directionypr(::od::Vector3f* directionypr);
  private:
  const ::od::Vector3f& _internal_directionypr() const;
  ::od::Vector3f* _internal_mutable_directionypr();
  public:
  void unsafe_arena_set_allocated_directionypr(
      ::od::Vector3f* directionypr);
  ::od::Vector3f* unsafe_arena_release_directionypr();

  // optional .od.Matrix3f directionYprUncertainty = 3;
  bool has_directionypruncertainty() const;
  private:
  bool _internal_has_directionypruncertainty() const;
  public:
  void clear_directionypruncertainty();
  const ::od::Matrix3f& directionypruncertainty() const;
  PROTOBUF_NODISCARD ::od::Matrix3f* release_directionypruncertainty();
  ::od::Matrix3f* mutable_directionypruncertainty();
  void set_allocated_directionypruncertainty(::od::Matrix3f* directionypruncertainty);
  private:
  const ::od::Matrix3f& _internal_directionypruncertainty() const;
  ::od::Matrix3f* _internal_mutable_directionypruncertainty();
  public:
  void unsafe_arena_set_allocated_directionypruncertainty(
      ::od::Matrix3f* directionypruncertainty);
  ::od::Matrix3f* unsafe_arena_release_directionypruncertainty();

  // optional bool isValid = 1;
  bool has_isvalid() const;
  private:
  bool _internal_has_isvalid() const;
  public:
  void clear_isvalid();
  bool isvalid() const;
  void set_isvalid(bool value);
  private:
  bool _internal_isvalid() const;
  void _internal_set_isvalid(bool value);
  public:

  // optional float yaw = 4;
  bool has_yaw() const;
  private:
  bool _internal_has_yaw() const;
  public:
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // optional float yawUncertainty = 5;
  bool has_yawuncertainty() const;
  private:
  bool _internal_has_yawuncertainty() const;
  public:
  void clear_yawuncertainty();
  float yawuncertainty() const;
  void set_yawuncertainty(float value);
  private:
  float _internal_yawuncertainty() const;
  void _internal_set_yawuncertainty(float value);
  public:

  // optional float yawRate = 6;
  bool has_yawrate() const;
  private:
  bool _internal_has_yawrate() const;
  public:
  void clear_yawrate();
  float yawrate() const;
  void set_yawrate(float value);
  private:
  float _internal_yawrate() const;
  void _internal_set_yawrate(float value);
  public:

  // optional float yawRateUncertainty = 7;
  bool has_yawrateuncertainty() const;
  private:
  bool _internal_has_yawrateuncertainty() const;
  public:
  void clear_yawrateuncertainty();
  float yawrateuncertainty() const;
  void set_yawrateuncertainty(float value);
  private:
  float _internal_yawrateuncertainty() const;
  void _internal_set_yawrateuncertainty(float value);
  public:

  // optional int32 surface = 8;
  bool has_surface() const;
  private:
  bool _internal_has_surface() const;
  public:
  void clear_surface();
  int32_t surface() const;
  void set_surface(int32_t value);
  private:
  int32_t _internal_surface() const;
  void _internal_set_surface(int32_t value);
  public:

  // optional float surfaceScore = 9;
  bool has_surfacescore() const;
  private:
  bool _internal_has_surfacescore() const;
  public:
  void clear_surfacescore();
  float surfacescore() const;
  void set_surfacescore(float value);
  private:
  float _internal_surfacescore() const;
  void _internal_set_surfacescore(float value);
  public:

  // @@protoc_insertion_point(class_scope:od.DirectionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::od::Vector3f* directionypr_;
  ::od::Matrix3f* directionypruncertainty_;
  bool isvalid_;
  float yaw_;
  float yawuncertainty_;
  float yawrate_;
  float yawrateuncertainty_;
  int32_t surface_;
  float surfacescore_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class UssRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.UssRange) */ {
 public:
  inline UssRange() : UssRange(nullptr) {}
  ~UssRange() override;
  explicit constexpr UssRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UssRange(const UssRange& from);
  UssRange(UssRange&& from) noexcept
    : UssRange() {
    *this = ::std::move(from);
  }

  inline UssRange& operator=(const UssRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline UssRange& operator=(UssRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UssRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const UssRange* internal_default_instance() {
    return reinterpret_cast<const UssRange*>(
               &_UssRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UssRange& a, UssRange& b) {
    a.Swap(&b);
  }
  inline void Swap(UssRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UssRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UssRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UssRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UssRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UssRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UssRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.UssRange";
  }
  protected:
  explicit UssRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceIdFieldNumber = 1,
    kPositionFieldNumber = 5,
    kRecvTimeNsFieldNumber = 2,
    kDistanceFieldNumber = 3,
    kIsValidFieldNumber = 4,
  };
  // optional string distanceId = 1;
  bool has_distanceid() const;
  private:
  bool _internal_has_distanceid() const;
  public:
  void clear_distanceid();
  const std::string& distanceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_distanceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_distanceid();
  PROTOBUF_NODISCARD std::string* release_distanceid();
  void set_allocated_distanceid(std::string* distanceid);
  private:
  const std::string& _internal_distanceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_distanceid(const std::string& value);
  std::string* _internal_mutable_distanceid();
  public:

  // optional .od.Vector3f position = 5;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::od::Vector3f& position() const;
  PROTOBUF_NODISCARD ::od::Vector3f* release_position();
  ::od::Vector3f* mutable_position();
  void set_allocated_position(::od::Vector3f* position);
  private:
  const ::od::Vector3f& _internal_position() const;
  ::od::Vector3f* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::od::Vector3f* position);
  ::od::Vector3f* unsafe_arena_release_position();

  // optional uint64 recvTimeNs = 2;
  bool has_recvtimens() const;
  private:
  bool _internal_has_recvtimens() const;
  public:
  void clear_recvtimens();
  uint64_t recvtimens() const;
  void set_recvtimens(uint64_t value);
  private:
  uint64_t _internal_recvtimens() const;
  void _internal_set_recvtimens(uint64_t value);
  public:

  // optional uint32 distance = 3;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  uint32_t distance() const;
  void set_distance(uint32_t value);
  private:
  uint32_t _internal_distance() const;
  void _internal_set_distance(uint32_t value);
  public:

  // optional bool isValid = 4;
  bool has_isvalid() const;
  private:
  bool _internal_has_isvalid() const;
  public:
  void clear_isvalid();
  bool isvalid() const;
  void set_isvalid(bool value);
  private:
  bool _internal_isvalid() const;
  void _internal_set_isvalid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:od.UssRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr distanceid_;
  ::od::Vector3f* position_;
  uint64_t recvtimens_;
  uint32_t distance_;
  bool isvalid_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class PositionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.PositionInfo) */ {
 public:
  inline PositionInfo() : PositionInfo(nullptr) {}
  ~PositionInfo() override;
  explicit constexpr PositionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionInfo(const PositionInfo& from);
  PositionInfo(PositionInfo&& from) noexcept
    : PositionInfo() {
    *this = ::std::move(from);
  }

  inline PositionInfo& operator=(const PositionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionInfo& operator=(PositionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionInfo* internal_default_instance() {
    return reinterpret_cast<const PositionInfo*>(
               &_PositionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PositionInfo& a, PositionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PositionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.PositionInfo";
  }
  protected:
  explicit PositionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kIsValidFieldNumber = 1,
  };
  // optional .od.Vector3f position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::od::Vector3f& position() const;
  PROTOBUF_NODISCARD ::od::Vector3f* release_position();
  ::od::Vector3f* mutable_position();
  void set_allocated_position(::od::Vector3f* position);
  private:
  const ::od::Vector3f& _internal_position() const;
  ::od::Vector3f* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::od::Vector3f* position);
  ::od::Vector3f* unsafe_arena_release_position();

  // optional bool isValid = 1;
  bool has_isvalid() const;
  private:
  bool _internal_has_isvalid() const;
  public:
  void clear_isvalid();
  bool isvalid() const;
  void set_isvalid(bool value);
  private:
  bool _internal_isvalid() const;
  void _internal_set_isvalid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:od.PositionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::od::Vector3f* position_;
  bool isvalid_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class FSLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.FSLine) */ {
 public:
  inline FSLine() : FSLine(nullptr) {}
  ~FSLine() override;
  explicit constexpr FSLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FSLine(const FSLine& from);
  FSLine(FSLine&& from) noexcept
    : FSLine() {
    *this = ::std::move(from);
  }

  inline FSLine& operator=(const FSLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline FSLine& operator=(FSLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FSLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const FSLine* internal_default_instance() {
    return reinterpret_cast<const FSLine*>(
               &_FSLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(FSLine& a, FSLine& b) {
    a.Swap(&b);
  }
  inline void Swap(FSLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FSLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FSLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FSLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FSLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FSLine& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FSLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.FSLine";
  }
  protected:
  explicit FSLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFsLineFieldNumber = 1,
  };
  // repeated .od.FSLinesimple fsLine = 1;
  int fsline_size() const;
  private:
  int _internal_fsline_size() const;
  public:
  void clear_fsline();
  ::od::FSLinesimple* mutable_fsline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinesimple >*
      mutable_fsline();
  private:
  const ::od::FSLinesimple& _internal_fsline(int index) const;
  ::od::FSLinesimple* _internal_add_fsline();
  public:
  const ::od::FSLinesimple& fsline(int index) const;
  ::od::FSLinesimple* add_fsline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinesimple >&
      fsline() const;

  // @@protoc_insertion_point(class_scope:od.FSLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinesimple > fsline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class FSLinesimple final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.FSLinesimple) */ {
 public:
  inline FSLinesimple() : FSLinesimple(nullptr) {}
  ~FSLinesimple() override;
  explicit constexpr FSLinesimple(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FSLinesimple(const FSLinesimple& from);
  FSLinesimple(FSLinesimple&& from) noexcept
    : FSLinesimple() {
    *this = ::std::move(from);
  }

  inline FSLinesimple& operator=(const FSLinesimple& from) {
    CopyFrom(from);
    return *this;
  }
  inline FSLinesimple& operator=(FSLinesimple&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FSLinesimple& default_instance() {
    return *internal_default_instance();
  }
  static inline const FSLinesimple* internal_default_instance() {
    return reinterpret_cast<const FSLinesimple*>(
               &_FSLinesimple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FSLinesimple& a, FSLinesimple& b) {
    a.Swap(&b);
  }
  inline void Swap(FSLinesimple* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FSLinesimple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FSLinesimple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FSLinesimple>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FSLinesimple& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FSLinesimple& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FSLinesimple* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.FSLinesimple";
  }
  protected:
  explicit FSLinesimple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFsLinepointsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kFrameTimestampNsFieldNumber = 2,
  };
  // repeated .od.FSLinePoint fsLinepoints = 3;
  int fslinepoints_size() const;
  private:
  int _internal_fslinepoints_size() const;
  public:
  void clear_fslinepoints();
  ::od::FSLinePoint* mutable_fslinepoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinePoint >*
      mutable_fslinepoints();
  private:
  const ::od::FSLinePoint& _internal_fslinepoints(int index) const;
  ::od::FSLinePoint* _internal_add_fslinepoints();
  public:
  const ::od::FSLinePoint& fslinepoints(int index) const;
  ::od::FSLinePoint* add_fslinepoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinePoint >&
      fslinepoints() const;

  // optional .od.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::od::Header& header() const;
  PROTOBUF_NODISCARD ::od::Header* release_header();
  ::od::Header* mutable_header();
  void set_allocated_header(::od::Header* header);
  private:
  const ::od::Header& _internal_header() const;
  ::od::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::od::Header* header);
  ::od::Header* unsafe_arena_release_header();

  // optional uint64 frameTimestampNs = 2;
  bool has_frametimestampns() const;
  private:
  bool _internal_has_frametimestampns() const;
  public:
  void clear_frametimestampns();
  uint64_t frametimestampns() const;
  void set_frametimestampns(uint64_t value);
  private:
  uint64_t _internal_frametimestampns() const;
  void _internal_set_frametimestampns(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:od.FSLinesimple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinePoint > fslinepoints_;
  ::od::Header* header_;
  uint64_t frametimestampns_;
  friend struct ::TableStruct_od_2eproto;
};
// -------------------------------------------------------------------

class FSLinePoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:od.FSLinePoint) */ {
 public:
  inline FSLinePoint() : FSLinePoint(nullptr) {}
  ~FSLinePoint() override;
  explicit constexpr FSLinePoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FSLinePoint(const FSLinePoint& from);
  FSLinePoint(FSLinePoint&& from) noexcept
    : FSLinePoint() {
    *this = ::std::move(from);
  }

  inline FSLinePoint& operator=(const FSLinePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline FSLinePoint& operator=(FSLinePoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FSLinePoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const FSLinePoint* internal_default_instance() {
    return reinterpret_cast<const FSLinePoint*>(
               &_FSLinePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(FSLinePoint& a, FSLinePoint& b) {
    a.Swap(&b);
  }
  inline void Swap(FSLinePoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FSLinePoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FSLinePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FSLinePoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FSLinePoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FSLinePoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FSLinePoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "od.FSLinePoint";
  }
  protected:
  explicit FSLinePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordinateFieldNumber = 1,
    kPointLabelFieldNumber = 2,
  };
  // optional .od.Point2f coordinate = 1;
  bool has_coordinate() const;
  private:
  bool _internal_has_coordinate() const;
  public:
  void clear_coordinate();
  const ::od::Point2f& coordinate() const;
  PROTOBUF_NODISCARD ::od::Point2f* release_coordinate();
  ::od::Point2f* mutable_coordinate();
  void set_allocated_coordinate(::od::Point2f* coordinate);
  private:
  const ::od::Point2f& _internal_coordinate() const;
  ::od::Point2f* _internal_mutable_coordinate();
  public:
  void unsafe_arena_set_allocated_coordinate(
      ::od::Point2f* coordinate);
  ::od::Point2f* unsafe_arena_release_coordinate();

  // optional .od.SpaceLabel pointLabel = 2;
  bool has_pointlabel() const;
  private:
  bool _internal_has_pointlabel() const;
  public:
  void clear_pointlabel();
  ::od::SpaceLabel pointlabel() const;
  void set_pointlabel(::od::SpaceLabel value);
  private:
  ::od::SpaceLabel _internal_pointlabel() const;
  void _internal_set_pointlabel(::od::SpaceLabel value);
  public:

  // @@protoc_insertion_point(class_scope:od.FSLinePoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::od::Point2f* coordinate_;
  int pointlabel_;
  friend struct ::TableStruct_od_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Obstacles

// optional .od.Header header = 1;
inline bool Obstacles::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool Obstacles::has_header() const {
  return _internal_has_header();
}
inline void Obstacles::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::od::Header& Obstacles::_internal_header() const {
  const ::od::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Header&>(
      ::od::_Header_default_instance_);
}
inline const ::od::Header& Obstacles::header() const {
  // @@protoc_insertion_point(field_get:od.Obstacles.header)
  return _internal_header();
}
inline void Obstacles::unsafe_arena_set_allocated_header(
    ::od::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.Obstacles.header)
}
inline ::od::Header* Obstacles::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::od::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Header* Obstacles::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:od.Obstacles.header)
  _has_bits_[0] &= ~0x00000001u;
  ::od::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::od::Header* Obstacles::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::od::Header* Obstacles::mutable_header() {
  ::od::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:od.Obstacles.header)
  return _msg;
}
inline void Obstacles::set_allocated_header(::od::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Header>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:od.Obstacles.header)
}

// repeated .od.ObstacleCylindrical cylindricalObstalces = 2;
inline int Obstacles::_internal_cylindricalobstalces_size() const {
  return cylindricalobstalces_.size();
}
inline int Obstacles::cylindricalobstalces_size() const {
  return _internal_cylindricalobstalces_size();
}
inline void Obstacles::clear_cylindricalobstalces() {
  cylindricalobstalces_.Clear();
}
inline ::od::ObstacleCylindrical* Obstacles::mutable_cylindricalobstalces(int index) {
  // @@protoc_insertion_point(field_mutable:od.Obstacles.cylindricalObstalces)
  return cylindricalobstalces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCylindrical >*
Obstacles::mutable_cylindricalobstalces() {
  // @@protoc_insertion_point(field_mutable_list:od.Obstacles.cylindricalObstalces)
  return &cylindricalobstalces_;
}
inline const ::od::ObstacleCylindrical& Obstacles::_internal_cylindricalobstalces(int index) const {
  return cylindricalobstalces_.Get(index);
}
inline const ::od::ObstacleCylindrical& Obstacles::cylindricalobstalces(int index) const {
  // @@protoc_insertion_point(field_get:od.Obstacles.cylindricalObstalces)
  return _internal_cylindricalobstalces(index);
}
inline ::od::ObstacleCylindrical* Obstacles::_internal_add_cylindricalobstalces() {
  return cylindricalobstalces_.Add();
}
inline ::od::ObstacleCylindrical* Obstacles::add_cylindricalobstalces() {
  ::od::ObstacleCylindrical* _add = _internal_add_cylindricalobstalces();
  // @@protoc_insertion_point(field_add:od.Obstacles.cylindricalObstalces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCylindrical >&
Obstacles::cylindricalobstalces() const {
  // @@protoc_insertion_point(field_list:od.Obstacles.cylindricalObstalces)
  return cylindricalobstalces_;
}

// repeated .od.ObstacleCube cubeObstacles = 3;
inline int Obstacles::_internal_cubeobstacles_size() const {
  return cubeobstacles_.size();
}
inline int Obstacles::cubeobstacles_size() const {
  return _internal_cubeobstacles_size();
}
inline void Obstacles::clear_cubeobstacles() {
  cubeobstacles_.Clear();
}
inline ::od::ObstacleCube* Obstacles::mutable_cubeobstacles(int index) {
  // @@protoc_insertion_point(field_mutable:od.Obstacles.cubeObstacles)
  return cubeobstacles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCube >*
Obstacles::mutable_cubeobstacles() {
  // @@protoc_insertion_point(field_mutable_list:od.Obstacles.cubeObstacles)
  return &cubeobstacles_;
}
inline const ::od::ObstacleCube& Obstacles::_internal_cubeobstacles(int index) const {
  return cubeobstacles_.Get(index);
}
inline const ::od::ObstacleCube& Obstacles::cubeobstacles(int index) const {
  // @@protoc_insertion_point(field_get:od.Obstacles.cubeObstacles)
  return _internal_cubeobstacles(index);
}
inline ::od::ObstacleCube* Obstacles::_internal_add_cubeobstacles() {
  return cubeobstacles_.Add();
}
inline ::od::ObstacleCube* Obstacles::add_cubeobstacles() {
  ::od::ObstacleCube* _add = _internal_add_cubeobstacles();
  // @@protoc_insertion_point(field_add:od.Obstacles.cubeObstacles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleCube >&
Obstacles::cubeobstacles() const {
  // @@protoc_insertion_point(field_list:od.Obstacles.cubeObstacles)
  return cubeobstacles_;
}

// repeated .od.ObstacleRaw rawObjects = 4;
inline int Obstacles::_internal_rawobjects_size() const {
  return rawobjects_.size();
}
inline int Obstacles::rawobjects_size() const {
  return _internal_rawobjects_size();
}
inline void Obstacles::clear_rawobjects() {
  rawobjects_.Clear();
}
inline ::od::ObstacleRaw* Obstacles::mutable_rawobjects(int index) {
  // @@protoc_insertion_point(field_mutable:od.Obstacles.rawObjects)
  return rawobjects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleRaw >*
Obstacles::mutable_rawobjects() {
  // @@protoc_insertion_point(field_mutable_list:od.Obstacles.rawObjects)
  return &rawobjects_;
}
inline const ::od::ObstacleRaw& Obstacles::_internal_rawobjects(int index) const {
  return rawobjects_.Get(index);
}
inline const ::od::ObstacleRaw& Obstacles::rawobjects(int index) const {
  // @@protoc_insertion_point(field_get:od.Obstacles.rawObjects)
  return _internal_rawobjects(index);
}
inline ::od::ObstacleRaw* Obstacles::_internal_add_rawobjects() {
  return rawobjects_.Add();
}
inline ::od::ObstacleRaw* Obstacles::add_rawobjects() {
  ::od::ObstacleRaw* _add = _internal_add_rawobjects();
  // @@protoc_insertion_point(field_add:od.Obstacles.rawObjects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleRaw >&
Obstacles::rawobjects() const {
  // @@protoc_insertion_point(field_list:od.Obstacles.rawObjects)
  return rawobjects_;
}

// repeated .od.UssRange rangeUnitArray = 5;
inline int Obstacles::_internal_rangeunitarray_size() const {
  return rangeunitarray_.size();
}
inline int Obstacles::rangeunitarray_size() const {
  return _internal_rangeunitarray_size();
}
inline void Obstacles::clear_rangeunitarray() {
  rangeunitarray_.Clear();
}
inline ::od::UssRange* Obstacles::mutable_rangeunitarray(int index) {
  // @@protoc_insertion_point(field_mutable:od.Obstacles.rangeUnitArray)
  return rangeunitarray_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::UssRange >*
Obstacles::mutable_rangeunitarray() {
  // @@protoc_insertion_point(field_mutable_list:od.Obstacles.rangeUnitArray)
  return &rangeunitarray_;
}
inline const ::od::UssRange& Obstacles::_internal_rangeunitarray(int index) const {
  return rangeunitarray_.Get(index);
}
inline const ::od::UssRange& Obstacles::rangeunitarray(int index) const {
  // @@protoc_insertion_point(field_get:od.Obstacles.rangeUnitArray)
  return _internal_rangeunitarray(index);
}
inline ::od::UssRange* Obstacles::_internal_add_rangeunitarray() {
  return rangeunitarray_.Add();
}
inline ::od::UssRange* Obstacles::add_rangeunitarray() {
  ::od::UssRange* _add = _internal_add_rangeunitarray();
  // @@protoc_insertion_point(field_add:od.Obstacles.rangeUnitArray)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::UssRange >&
Obstacles::rangeunitarray() const {
  // @@protoc_insertion_point(field_list:od.Obstacles.rangeUnitArray)
  return rangeunitarray_;
}

// -------------------------------------------------------------------

// Header

// optional uint32 seq = 1;
inline bool Header::_internal_has_seq() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Header::has_seq() const {
  return _internal_has_seq();
}
inline void Header::clear_seq() {
  seq_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Header::_internal_seq() const {
  return seq_;
}
inline uint32_t Header::seq() const {
  // @@protoc_insertion_point(field_get:od.Header.seq)
  return _internal_seq();
}
inline void Header::_internal_set_seq(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  seq_ = value;
}
inline void Header::set_seq(uint32_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:od.Header.seq)
}

// optional .od.Time timestampNs = 2;
inline bool Header::_internal_has_timestampns() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || timestampns_ != nullptr);
  return value;
}
inline bool Header::has_timestampns() const {
  return _internal_has_timestampns();
}
inline void Header::clear_timestampns() {
  if (timestampns_ != nullptr) timestampns_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::od::Time& Header::_internal_timestampns() const {
  const ::od::Time* p = timestampns_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Time&>(
      ::od::_Time_default_instance_);
}
inline const ::od::Time& Header::timestampns() const {
  // @@protoc_insertion_point(field_get:od.Header.timestampNs)
  return _internal_timestampns();
}
inline void Header::unsafe_arena_set_allocated_timestampns(
    ::od::Time* timestampns) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestampns_);
  }
  timestampns_ = timestampns;
  if (timestampns) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.Header.timestampNs)
}
inline ::od::Time* Header::release_timestampns() {
  _has_bits_[0] &= ~0x00000002u;
  ::od::Time* temp = timestampns_;
  timestampns_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Time* Header::unsafe_arena_release_timestampns() {
  // @@protoc_insertion_point(field_release:od.Header.timestampNs)
  _has_bits_[0] &= ~0x00000002u;
  ::od::Time* temp = timestampns_;
  timestampns_ = nullptr;
  return temp;
}
inline ::od::Time* Header::_internal_mutable_timestampns() {
  _has_bits_[0] |= 0x00000002u;
  if (timestampns_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Time>(GetArenaForAllocation());
    timestampns_ = p;
  }
  return timestampns_;
}
inline ::od::Time* Header::mutable_timestampns() {
  ::od::Time* _msg = _internal_mutable_timestampns();
  // @@protoc_insertion_point(field_mutable:od.Header.timestampNs)
  return _msg;
}
inline void Header::set_allocated_timestampns(::od::Time* timestampns) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete timestampns_;
  }
  if (timestampns) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Time>::GetOwningArena(timestampns);
    if (message_arena != submessage_arena) {
      timestampns = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestampns, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  timestampns_ = timestampns;
  // @@protoc_insertion_point(field_set_allocated:od.Header.timestampNs)
}

// optional string frameId = 3;
inline bool Header::_internal_has_frameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Header::has_frameid() const {
  return _internal_has_frameid();
}
inline void Header::clear_frameid() {
  frameid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Header::frameid() const {
  // @@protoc_insertion_point(field_get:od.Header.frameId)
  return _internal_frameid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Header::set_frameid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 frameid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:od.Header.frameId)
}
inline std::string* Header::mutable_frameid() {
  std::string* _s = _internal_mutable_frameid();
  // @@protoc_insertion_point(field_mutable:od.Header.frameId)
  return _s;
}
inline const std::string& Header::_internal_frameid() const {
  return frameid_.Get();
}
inline void Header::_internal_set_frameid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  frameid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_frameid() {
  _has_bits_[0] |= 0x00000001u;
  return frameid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Header::release_frameid() {
  // @@protoc_insertion_point(field_release:od.Header.frameId)
  if (!_internal_has_frameid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = frameid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (frameid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    frameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Header::set_allocated_frameid(std::string* frameid) {
  if (frameid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  frameid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frameid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (frameid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    frameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:od.Header.frameId)
}

// -------------------------------------------------------------------

// Time

// optional uint64 nanoSec = 1;
inline bool Time::_internal_has_nanosec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Time::has_nanosec() const {
  return _internal_has_nanosec();
}
inline void Time::clear_nanosec() {
  nanosec_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Time::_internal_nanosec() const {
  return nanosec_;
}
inline uint64_t Time::nanosec() const {
  // @@protoc_insertion_point(field_get:od.Time.nanoSec)
  return _internal_nanosec();
}
inline void Time::_internal_set_nanosec(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  nanosec_ = value;
}
inline void Time::set_nanosec(uint64_t value) {
  _internal_set_nanosec(value);
  // @@protoc_insertion_point(field_set:od.Time.nanoSec)
}

// -------------------------------------------------------------------

// ObstacleCylindrical

// optional string camera = 1;
inline bool ObstacleCylindrical::_internal_has_camera() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObstacleCylindrical::has_camera() const {
  return _internal_has_camera();
}
inline void ObstacleCylindrical::clear_camera() {
  camera_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObstacleCylindrical::camera() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.camera)
  return _internal_camera();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObstacleCylindrical::set_camera(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:od.ObstacleCylindrical.camera)
}
inline std::string* ObstacleCylindrical::mutable_camera() {
  std::string* _s = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:od.ObstacleCylindrical.camera)
  return _s;
}
inline const std::string& ObstacleCylindrical::_internal_camera() const {
  return camera_.Get();
}
inline void ObstacleCylindrical::_internal_set_camera(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObstacleCylindrical::_internal_mutable_camera() {
  _has_bits_[0] |= 0x00000001u;
  return camera_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObstacleCylindrical::release_camera() {
  // @@protoc_insertion_point(field_release:od.ObstacleCylindrical.camera)
  if (!_internal_has_camera()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = camera_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObstacleCylindrical::set_allocated_camera(std::string* camera) {
  if (camera != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  camera_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), camera,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleCylindrical.camera)
}

// optional int32 label = 2;
inline bool ObstacleCylindrical::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ObstacleCylindrical::has_label() const {
  return _internal_has_label();
}
inline void ObstacleCylindrical::clear_label() {
  label_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ObstacleCylindrical::_internal_label() const {
  return label_;
}
inline int32_t ObstacleCylindrical::label() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.label)
  return _internal_label();
}
inline void ObstacleCylindrical::_internal_set_label(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  label_ = value;
}
inline void ObstacleCylindrical::set_label(int32_t value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCylindrical.label)
}

// optional float typeConfidence = 3;
inline bool ObstacleCylindrical::_internal_has_typeconfidence() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ObstacleCylindrical::has_typeconfidence() const {
  return _internal_has_typeconfidence();
}
inline void ObstacleCylindrical::clear_typeconfidence() {
  typeconfidence_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float ObstacleCylindrical::_internal_typeconfidence() const {
  return typeconfidence_;
}
inline float ObstacleCylindrical::typeconfidence() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.typeConfidence)
  return _internal_typeconfidence();
}
inline void ObstacleCylindrical::_internal_set_typeconfidence(float value) {
  _has_bits_[0] |= 0x00000020u;
  typeconfidence_ = value;
}
inline void ObstacleCylindrical::set_typeconfidence(float value) {
  _internal_set_typeconfidence(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCylindrical.typeConfidence)
}

// optional float existenceConfidence = 4;
inline bool ObstacleCylindrical::_internal_has_existenceconfidence() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ObstacleCylindrical::has_existenceconfidence() const {
  return _internal_has_existenceconfidence();
}
inline void ObstacleCylindrical::clear_existenceconfidence() {
  existenceconfidence_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ObstacleCylindrical::_internal_existenceconfidence() const {
  return existenceconfidence_;
}
inline float ObstacleCylindrical::existenceconfidence() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.existenceConfidence)
  return _internal_existenceconfidence();
}
inline void ObstacleCylindrical::_internal_set_existenceconfidence(float value) {
  _has_bits_[0] |= 0x00000040u;
  existenceconfidence_ = value;
}
inline void ObstacleCylindrical::set_existenceconfidence(float value) {
  _internal_set_existenceconfidence(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCylindrical.existenceConfidence)
}

// optional int32 trackId = 5;
inline bool ObstacleCylindrical::_internal_has_trackid() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ObstacleCylindrical::has_trackid() const {
  return _internal_has_trackid();
}
inline void ObstacleCylindrical::clear_trackid() {
  trackid_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ObstacleCylindrical::_internal_trackid() const {
  return trackid_;
}
inline int32_t ObstacleCylindrical::trackid() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.trackId)
  return _internal_trackid();
}
inline void ObstacleCylindrical::_internal_set_trackid(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  trackid_ = value;
}
inline void ObstacleCylindrical::set_trackid(int32_t value) {
  _internal_set_trackid(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCylindrical.trackId)
}

// optional .od.Vector3d Center = 6;
inline bool ObstacleCylindrical::_internal_has_center() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || center_ != nullptr);
  return value;
}
inline bool ObstacleCylindrical::has_center() const {
  return _internal_has_center();
}
inline void ObstacleCylindrical::clear_center() {
  if (center_ != nullptr) center_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::od::Vector3d& ObstacleCylindrical::_internal_center() const {
  const ::od::Vector3d* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3d&>(
      ::od::_Vector3d_default_instance_);
}
inline const ::od::Vector3d& ObstacleCylindrical::center() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.Center)
  return _internal_center();
}
inline void ObstacleCylindrical::unsafe_arena_set_allocated_center(
    ::od::Vector3d* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleCylindrical.Center)
}
inline ::od::Vector3d* ObstacleCylindrical::release_center() {
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3d* temp = center_;
  center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3d* ObstacleCylindrical::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:od.ObstacleCylindrical.Center)
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3d* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::od::Vector3d* ObstacleCylindrical::_internal_mutable_center() {
  _has_bits_[0] |= 0x00000002u;
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3d>(GetArenaForAllocation());
    center_ = p;
  }
  return center_;
}
inline ::od::Vector3d* ObstacleCylindrical::mutable_center() {
  ::od::Vector3d* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:od.ObstacleCylindrical.Center)
  return _msg;
}
inline void ObstacleCylindrical::set_allocated_center(::od::Vector3d* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3d>::GetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleCylindrical.Center)
}

// optional float radius = 7;
inline bool ObstacleCylindrical::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ObstacleCylindrical::has_radius() const {
  return _internal_has_radius();
}
inline void ObstacleCylindrical::clear_radius() {
  radius_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float ObstacleCylindrical::_internal_radius() const {
  return radius_;
}
inline float ObstacleCylindrical::radius() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.radius)
  return _internal_radius();
}
inline void ObstacleCylindrical::_internal_set_radius(float value) {
  _has_bits_[0] |= 0x00000100u;
  radius_ = value;
}
inline void ObstacleCylindrical::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCylindrical.radius)
}

// optional float height = 8;
inline bool ObstacleCylindrical::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ObstacleCylindrical::has_height() const {
  return _internal_has_height();
}
inline void ObstacleCylindrical::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float ObstacleCylindrical::_internal_height() const {
  return height_;
}
inline float ObstacleCylindrical::height() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.height)
  return _internal_height();
}
inline void ObstacleCylindrical::_internal_set_height(float value) {
  _has_bits_[0] |= 0x00000200u;
  height_ = value;
}
inline void ObstacleCylindrical::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCylindrical.height)
}

// optional .od.Vector3d direction = 9;
inline bool ObstacleCylindrical::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || direction_ != nullptr);
  return value;
}
inline bool ObstacleCylindrical::has_direction() const {
  return _internal_has_direction();
}
inline void ObstacleCylindrical::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::od::Vector3d& ObstacleCylindrical::_internal_direction() const {
  const ::od::Vector3d* p = direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3d&>(
      ::od::_Vector3d_default_instance_);
}
inline const ::od::Vector3d& ObstacleCylindrical::direction() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.direction)
  return _internal_direction();
}
inline void ObstacleCylindrical::unsafe_arena_set_allocated_direction(
    ::od::Vector3d* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction_);
  }
  direction_ = direction;
  if (direction) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleCylindrical.direction)
}
inline ::od::Vector3d* ObstacleCylindrical::release_direction() {
  _has_bits_[0] &= ~0x00000004u;
  ::od::Vector3d* temp = direction_;
  direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3d* ObstacleCylindrical::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:od.ObstacleCylindrical.direction)
  _has_bits_[0] &= ~0x00000004u;
  ::od::Vector3d* temp = direction_;
  direction_ = nullptr;
  return temp;
}
inline ::od::Vector3d* ObstacleCylindrical::_internal_mutable_direction() {
  _has_bits_[0] |= 0x00000004u;
  if (direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3d>(GetArenaForAllocation());
    direction_ = p;
  }
  return direction_;
}
inline ::od::Vector3d* ObstacleCylindrical::mutable_direction() {
  ::od::Vector3d* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:od.ObstacleCylindrical.direction)
  return _msg;
}
inline void ObstacleCylindrical::set_allocated_direction(::od::Vector3d* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete direction_;
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3d>::GetOwningArena(direction);
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleCylindrical.direction)
}

// optional .od.MotionInfo motionInfo = 10;
inline bool ObstacleCylindrical::_internal_has_motioninfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || motioninfo_ != nullptr);
  return value;
}
inline bool ObstacleCylindrical::has_motioninfo() const {
  return _internal_has_motioninfo();
}
inline void ObstacleCylindrical::clear_motioninfo() {
  if (motioninfo_ != nullptr) motioninfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::od::MotionInfo& ObstacleCylindrical::_internal_motioninfo() const {
  const ::od::MotionInfo* p = motioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::MotionInfo&>(
      ::od::_MotionInfo_default_instance_);
}
inline const ::od::MotionInfo& ObstacleCylindrical::motioninfo() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.motionInfo)
  return _internal_motioninfo();
}
inline void ObstacleCylindrical::unsafe_arena_set_allocated_motioninfo(
    ::od::MotionInfo* motioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motioninfo_);
  }
  motioninfo_ = motioninfo;
  if (motioninfo) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleCylindrical.motionInfo)
}
inline ::od::MotionInfo* ObstacleCylindrical::release_motioninfo() {
  _has_bits_[0] &= ~0x00000008u;
  ::od::MotionInfo* temp = motioninfo_;
  motioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::MotionInfo* ObstacleCylindrical::unsafe_arena_release_motioninfo() {
  // @@protoc_insertion_point(field_release:od.ObstacleCylindrical.motionInfo)
  _has_bits_[0] &= ~0x00000008u;
  ::od::MotionInfo* temp = motioninfo_;
  motioninfo_ = nullptr;
  return temp;
}
inline ::od::MotionInfo* ObstacleCylindrical::_internal_mutable_motioninfo() {
  _has_bits_[0] |= 0x00000008u;
  if (motioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::MotionInfo>(GetArenaForAllocation());
    motioninfo_ = p;
  }
  return motioninfo_;
}
inline ::od::MotionInfo* ObstacleCylindrical::mutable_motioninfo() {
  ::od::MotionInfo* _msg = _internal_mutable_motioninfo();
  // @@protoc_insertion_point(field_mutable:od.ObstacleCylindrical.motionInfo)
  return _msg;
}
inline void ObstacleCylindrical::set_allocated_motioninfo(::od::MotionInfo* motioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete motioninfo_;
  }
  if (motioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::MotionInfo>::GetOwningArena(motioninfo);
    if (message_arena != submessage_arena) {
      motioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motioninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  motioninfo_ = motioninfo;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleCylindrical.motionInfo)
}

// repeated .od.ObstacleTrajectory trajectory = 11;
inline int ObstacleCylindrical::_internal_trajectory_size() const {
  return trajectory_.size();
}
inline int ObstacleCylindrical::trajectory_size() const {
  return _internal_trajectory_size();
}
inline void ObstacleCylindrical::clear_trajectory() {
  trajectory_.Clear();
}
inline ::od::ObstacleTrajectory* ObstacleCylindrical::mutable_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:od.ObstacleCylindrical.trajectory)
  return trajectory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory >*
ObstacleCylindrical::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleCylindrical.trajectory)
  return &trajectory_;
}
inline const ::od::ObstacleTrajectory& ObstacleCylindrical::_internal_trajectory(int index) const {
  return trajectory_.Get(index);
}
inline const ::od::ObstacleTrajectory& ObstacleCylindrical::trajectory(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.trajectory)
  return _internal_trajectory(index);
}
inline ::od::ObstacleTrajectory* ObstacleCylindrical::_internal_add_trajectory() {
  return trajectory_.Add();
}
inline ::od::ObstacleTrajectory* ObstacleCylindrical::add_trajectory() {
  ::od::ObstacleTrajectory* _add = _internal_add_trajectory();
  // @@protoc_insertion_point(field_add:od.ObstacleCylindrical.trajectory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory >&
ObstacleCylindrical::trajectory() const {
  // @@protoc_insertion_point(field_list:od.ObstacleCylindrical.trajectory)
  return trajectory_;
}

// optional int32 staticState = 12;
inline bool ObstacleCylindrical::_internal_has_staticstate() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ObstacleCylindrical::has_staticstate() const {
  return _internal_has_staticstate();
}
inline void ObstacleCylindrical::clear_staticstate() {
  staticstate_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline int32_t ObstacleCylindrical::_internal_staticstate() const {
  return staticstate_;
}
inline int32_t ObstacleCylindrical::staticstate() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.staticState)
  return _internal_staticstate();
}
inline void ObstacleCylindrical::_internal_set_staticstate(int32_t value) {
  _has_bits_[0] |= 0x00000400u;
  staticstate_ = value;
}
inline void ObstacleCylindrical::set_staticstate(int32_t value) {
  _internal_set_staticstate(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCylindrical.staticState)
}

// optional float attrScore = 13;
inline bool ObstacleCylindrical::_internal_has_attrscore() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ObstacleCylindrical::has_attrscore() const {
  return _internal_has_attrscore();
}
inline void ObstacleCylindrical::clear_attrscore() {
  attrscore_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float ObstacleCylindrical::_internal_attrscore() const {
  return attrscore_;
}
inline float ObstacleCylindrical::attrscore() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCylindrical.attrScore)
  return _internal_attrscore();
}
inline void ObstacleCylindrical::_internal_set_attrscore(float value) {
  _has_bits_[0] |= 0x00000800u;
  attrscore_ = value;
}
inline void ObstacleCylindrical::set_attrscore(float value) {
  _internal_set_attrscore(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCylindrical.attrScore)
}

// -------------------------------------------------------------------

// Vector3d

// optional float x = 1;
inline bool Vector3d::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vector3d::has_x() const {
  return _internal_has_x();
}
inline void Vector3d::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Vector3d::_internal_x() const {
  return x_;
}
inline float Vector3d::x() const {
  // @@protoc_insertion_point(field_get:od.Vector3d.x)
  return _internal_x();
}
inline void Vector3d::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Vector3d::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:od.Vector3d.x)
}

// optional float y = 2;
inline bool Vector3d::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vector3d::has_y() const {
  return _internal_has_y();
}
inline void Vector3d::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Vector3d::_internal_y() const {
  return y_;
}
inline float Vector3d::y() const {
  // @@protoc_insertion_point(field_get:od.Vector3d.y)
  return _internal_y();
}
inline void Vector3d::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Vector3d::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:od.Vector3d.y)
}

// optional float z = 3;
inline bool Vector3d::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Vector3d::has_z() const {
  return _internal_has_z();
}
inline void Vector3d::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Vector3d::_internal_z() const {
  return z_;
}
inline float Vector3d::z() const {
  // @@protoc_insertion_point(field_get:od.Vector3d.z)
  return _internal_z();
}
inline void Vector3d::_internal_set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void Vector3d::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:od.Vector3d.z)
}

// -------------------------------------------------------------------

// MotionInfo

// optional bool isValid = 1;
inline bool MotionInfo::_internal_has_isvalid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MotionInfo::has_isvalid() const {
  return _internal_has_isvalid();
}
inline void MotionInfo::clear_isvalid() {
  isvalid_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool MotionInfo::_internal_isvalid() const {
  return isvalid_;
}
inline bool MotionInfo::isvalid() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.isValid)
  return _internal_isvalid();
}
inline void MotionInfo::_internal_set_isvalid(bool value) {
  _has_bits_[0] |= 0x00000100u;
  isvalid_ = value;
}
inline void MotionInfo::set_isvalid(bool value) {
  _internal_set_isvalid(value);
  // @@protoc_insertion_point(field_set:od.MotionInfo.isValid)
}

// optional int32 motionStatus = 2;
inline bool MotionInfo::_internal_has_motionstatus() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MotionInfo::has_motionstatus() const {
  return _internal_has_motionstatus();
}
inline void MotionInfo::clear_motionstatus() {
  motionstatus_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t MotionInfo::_internal_motionstatus() const {
  return motionstatus_;
}
inline int32_t MotionInfo::motionstatus() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.motionStatus)
  return _internal_motionstatus();
}
inline void MotionInfo::_internal_set_motionstatus(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  motionstatus_ = value;
}
inline void MotionInfo::set_motionstatus(int32_t value) {
  _internal_set_motionstatus(value);
  // @@protoc_insertion_point(field_set:od.MotionInfo.motionStatus)
}

// optional .od.Vector3d center = 3;
inline bool MotionInfo::_internal_has_center() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || center_ != nullptr);
  return value;
}
inline bool MotionInfo::has_center() const {
  return _internal_has_center();
}
inline void MotionInfo::clear_center() {
  if (center_ != nullptr) center_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::od::Vector3d& MotionInfo::_internal_center() const {
  const ::od::Vector3d* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3d&>(
      ::od::_Vector3d_default_instance_);
}
inline const ::od::Vector3d& MotionInfo::center() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.center)
  return _internal_center();
}
inline void MotionInfo::unsafe_arena_set_allocated_center(
    ::od::Vector3d* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.MotionInfo.center)
}
inline ::od::Vector3d* MotionInfo::release_center() {
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3d* temp = center_;
  center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3d* MotionInfo::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:od.MotionInfo.center)
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3d* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::od::Vector3d* MotionInfo::_internal_mutable_center() {
  _has_bits_[0] |= 0x00000001u;
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3d>(GetArenaForAllocation());
    center_ = p;
  }
  return center_;
}
inline ::od::Vector3d* MotionInfo::mutable_center() {
  ::od::Vector3d* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:od.MotionInfo.center)
  return _msg;
}
inline void MotionInfo::set_allocated_center(::od::Vector3d* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3d>::GetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:od.MotionInfo.center)
}

// optional .od.Matrix3f centerUncertainty = 4;
inline bool MotionInfo::_internal_has_centeruncertainty() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || centeruncertainty_ != nullptr);
  return value;
}
inline bool MotionInfo::has_centeruncertainty() const {
  return _internal_has_centeruncertainty();
}
inline void MotionInfo::clear_centeruncertainty() {
  if (centeruncertainty_ != nullptr) centeruncertainty_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::od::Matrix3f& MotionInfo::_internal_centeruncertainty() const {
  const ::od::Matrix3f* p = centeruncertainty_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Matrix3f&>(
      ::od::_Matrix3f_default_instance_);
}
inline const ::od::Matrix3f& MotionInfo::centeruncertainty() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.centerUncertainty)
  return _internal_centeruncertainty();
}
inline void MotionInfo::unsafe_arena_set_allocated_centeruncertainty(
    ::od::Matrix3f* centeruncertainty) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centeruncertainty_);
  }
  centeruncertainty_ = centeruncertainty;
  if (centeruncertainty) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.MotionInfo.centerUncertainty)
}
inline ::od::Matrix3f* MotionInfo::release_centeruncertainty() {
  _has_bits_[0] &= ~0x00000002u;
  ::od::Matrix3f* temp = centeruncertainty_;
  centeruncertainty_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Matrix3f* MotionInfo::unsafe_arena_release_centeruncertainty() {
  // @@protoc_insertion_point(field_release:od.MotionInfo.centerUncertainty)
  _has_bits_[0] &= ~0x00000002u;
  ::od::Matrix3f* temp = centeruncertainty_;
  centeruncertainty_ = nullptr;
  return temp;
}
inline ::od::Matrix3f* MotionInfo::_internal_mutable_centeruncertainty() {
  _has_bits_[0] |= 0x00000002u;
  if (centeruncertainty_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Matrix3f>(GetArenaForAllocation());
    centeruncertainty_ = p;
  }
  return centeruncertainty_;
}
inline ::od::Matrix3f* MotionInfo::mutable_centeruncertainty() {
  ::od::Matrix3f* _msg = _internal_mutable_centeruncertainty();
  // @@protoc_insertion_point(field_mutable:od.MotionInfo.centerUncertainty)
  return _msg;
}
inline void MotionInfo::set_allocated_centeruncertainty(::od::Matrix3f* centeruncertainty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete centeruncertainty_;
  }
  if (centeruncertainty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Matrix3f>::GetOwningArena(centeruncertainty);
    if (message_arena != submessage_arena) {
      centeruncertainty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, centeruncertainty, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  centeruncertainty_ = centeruncertainty;
  // @@protoc_insertion_point(field_set_allocated:od.MotionInfo.centerUncertainty)
}

// optional .od.Vector3d velocity = 5;
inline bool MotionInfo::_internal_has_velocity() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || velocity_ != nullptr);
  return value;
}
inline bool MotionInfo::has_velocity() const {
  return _internal_has_velocity();
}
inline void MotionInfo::clear_velocity() {
  if (velocity_ != nullptr) velocity_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::od::Vector3d& MotionInfo::_internal_velocity() const {
  const ::od::Vector3d* p = velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3d&>(
      ::od::_Vector3d_default_instance_);
}
inline const ::od::Vector3d& MotionInfo::velocity() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.velocity)
  return _internal_velocity();
}
inline void MotionInfo::unsafe_arena_set_allocated_velocity(
    ::od::Vector3d* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.MotionInfo.velocity)
}
inline ::od::Vector3d* MotionInfo::release_velocity() {
  _has_bits_[0] &= ~0x00000004u;
  ::od::Vector3d* temp = velocity_;
  velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3d* MotionInfo::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:od.MotionInfo.velocity)
  _has_bits_[0] &= ~0x00000004u;
  ::od::Vector3d* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::od::Vector3d* MotionInfo::_internal_mutable_velocity() {
  _has_bits_[0] |= 0x00000004u;
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3d>(GetArenaForAllocation());
    velocity_ = p;
  }
  return velocity_;
}
inline ::od::Vector3d* MotionInfo::mutable_velocity() {
  ::od::Vector3d* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:od.MotionInfo.velocity)
  return _msg;
}
inline void MotionInfo::set_allocated_velocity(::od::Vector3d* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3d>::GetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:od.MotionInfo.velocity)
}

// optional .od.Matrix3f velocityUncertainty = 6;
inline bool MotionInfo::_internal_has_velocityuncertainty() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || velocityuncertainty_ != nullptr);
  return value;
}
inline bool MotionInfo::has_velocityuncertainty() const {
  return _internal_has_velocityuncertainty();
}
inline void MotionInfo::clear_velocityuncertainty() {
  if (velocityuncertainty_ != nullptr) velocityuncertainty_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::od::Matrix3f& MotionInfo::_internal_velocityuncertainty() const {
  const ::od::Matrix3f* p = velocityuncertainty_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Matrix3f&>(
      ::od::_Matrix3f_default_instance_);
}
inline const ::od::Matrix3f& MotionInfo::velocityuncertainty() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.velocityUncertainty)
  return _internal_velocityuncertainty();
}
inline void MotionInfo::unsafe_arena_set_allocated_velocityuncertainty(
    ::od::Matrix3f* velocityuncertainty) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocityuncertainty_);
  }
  velocityuncertainty_ = velocityuncertainty;
  if (velocityuncertainty) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.MotionInfo.velocityUncertainty)
}
inline ::od::Matrix3f* MotionInfo::release_velocityuncertainty() {
  _has_bits_[0] &= ~0x00000008u;
  ::od::Matrix3f* temp = velocityuncertainty_;
  velocityuncertainty_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Matrix3f* MotionInfo::unsafe_arena_release_velocityuncertainty() {
  // @@protoc_insertion_point(field_release:od.MotionInfo.velocityUncertainty)
  _has_bits_[0] &= ~0x00000008u;
  ::od::Matrix3f* temp = velocityuncertainty_;
  velocityuncertainty_ = nullptr;
  return temp;
}
inline ::od::Matrix3f* MotionInfo::_internal_mutable_velocityuncertainty() {
  _has_bits_[0] |= 0x00000008u;
  if (velocityuncertainty_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Matrix3f>(GetArenaForAllocation());
    velocityuncertainty_ = p;
  }
  return velocityuncertainty_;
}
inline ::od::Matrix3f* MotionInfo::mutable_velocityuncertainty() {
  ::od::Matrix3f* _msg = _internal_mutable_velocityuncertainty();
  // @@protoc_insertion_point(field_mutable:od.MotionInfo.velocityUncertainty)
  return _msg;
}
inline void MotionInfo::set_allocated_velocityuncertainty(::od::Matrix3f* velocityuncertainty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete velocityuncertainty_;
  }
  if (velocityuncertainty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Matrix3f>::GetOwningArena(velocityuncertainty);
    if (message_arena != submessage_arena) {
      velocityuncertainty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocityuncertainty, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  velocityuncertainty_ = velocityuncertainty;
  // @@protoc_insertion_point(field_set_allocated:od.MotionInfo.velocityUncertainty)
}

// optional .od.Vector3d acceleration = 7;
inline bool MotionInfo::_internal_has_acceleration() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || acceleration_ != nullptr);
  return value;
}
inline bool MotionInfo::has_acceleration() const {
  return _internal_has_acceleration();
}
inline void MotionInfo::clear_acceleration() {
  if (acceleration_ != nullptr) acceleration_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::od::Vector3d& MotionInfo::_internal_acceleration() const {
  const ::od::Vector3d* p = acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3d&>(
      ::od::_Vector3d_default_instance_);
}
inline const ::od::Vector3d& MotionInfo::acceleration() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.acceleration)
  return _internal_acceleration();
}
inline void MotionInfo::unsafe_arena_set_allocated_acceleration(
    ::od::Vector3d* acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration_);
  }
  acceleration_ = acceleration;
  if (acceleration) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.MotionInfo.acceleration)
}
inline ::od::Vector3d* MotionInfo::release_acceleration() {
  _has_bits_[0] &= ~0x00000010u;
  ::od::Vector3d* temp = acceleration_;
  acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3d* MotionInfo::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:od.MotionInfo.acceleration)
  _has_bits_[0] &= ~0x00000010u;
  ::od::Vector3d* temp = acceleration_;
  acceleration_ = nullptr;
  return temp;
}
inline ::od::Vector3d* MotionInfo::_internal_mutable_acceleration() {
  _has_bits_[0] |= 0x00000010u;
  if (acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3d>(GetArenaForAllocation());
    acceleration_ = p;
  }
  return acceleration_;
}
inline ::od::Vector3d* MotionInfo::mutable_acceleration() {
  ::od::Vector3d* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:od.MotionInfo.acceleration)
  return _msg;
}
inline void MotionInfo::set_allocated_acceleration(::od::Vector3d* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete acceleration_;
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3d>::GetOwningArena(acceleration);
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:od.MotionInfo.acceleration)
}

// optional .od.Matrix3f accelerationUncertainty = 8;
inline bool MotionInfo::_internal_has_accelerationuncertainty() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || accelerationuncertainty_ != nullptr);
  return value;
}
inline bool MotionInfo::has_accelerationuncertainty() const {
  return _internal_has_accelerationuncertainty();
}
inline void MotionInfo::clear_accelerationuncertainty() {
  if (accelerationuncertainty_ != nullptr) accelerationuncertainty_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::od::Matrix3f& MotionInfo::_internal_accelerationuncertainty() const {
  const ::od::Matrix3f* p = accelerationuncertainty_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Matrix3f&>(
      ::od::_Matrix3f_default_instance_);
}
inline const ::od::Matrix3f& MotionInfo::accelerationuncertainty() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.accelerationUncertainty)
  return _internal_accelerationuncertainty();
}
inline void MotionInfo::unsafe_arena_set_allocated_accelerationuncertainty(
    ::od::Matrix3f* accelerationuncertainty) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accelerationuncertainty_);
  }
  accelerationuncertainty_ = accelerationuncertainty;
  if (accelerationuncertainty) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.MotionInfo.accelerationUncertainty)
}
inline ::od::Matrix3f* MotionInfo::release_accelerationuncertainty() {
  _has_bits_[0] &= ~0x00000020u;
  ::od::Matrix3f* temp = accelerationuncertainty_;
  accelerationuncertainty_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Matrix3f* MotionInfo::unsafe_arena_release_accelerationuncertainty() {
  // @@protoc_insertion_point(field_release:od.MotionInfo.accelerationUncertainty)
  _has_bits_[0] &= ~0x00000020u;
  ::od::Matrix3f* temp = accelerationuncertainty_;
  accelerationuncertainty_ = nullptr;
  return temp;
}
inline ::od::Matrix3f* MotionInfo::_internal_mutable_accelerationuncertainty() {
  _has_bits_[0] |= 0x00000020u;
  if (accelerationuncertainty_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Matrix3f>(GetArenaForAllocation());
    accelerationuncertainty_ = p;
  }
  return accelerationuncertainty_;
}
inline ::od::Matrix3f* MotionInfo::mutable_accelerationuncertainty() {
  ::od::Matrix3f* _msg = _internal_mutable_accelerationuncertainty();
  // @@protoc_insertion_point(field_mutable:od.MotionInfo.accelerationUncertainty)
  return _msg;
}
inline void MotionInfo::set_allocated_accelerationuncertainty(::od::Matrix3f* accelerationuncertainty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete accelerationuncertainty_;
  }
  if (accelerationuncertainty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Matrix3f>::GetOwningArena(accelerationuncertainty);
    if (message_arena != submessage_arena) {
      accelerationuncertainty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accelerationuncertainty, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  accelerationuncertainty_ = accelerationuncertainty;
  // @@protoc_insertion_point(field_set_allocated:od.MotionInfo.accelerationUncertainty)
}

// optional .od.Vector3f jerk = 9;
inline bool MotionInfo::_internal_has_jerk() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || jerk_ != nullptr);
  return value;
}
inline bool MotionInfo::has_jerk() const {
  return _internal_has_jerk();
}
inline void MotionInfo::clear_jerk() {
  if (jerk_ != nullptr) jerk_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::od::Vector3f& MotionInfo::_internal_jerk() const {
  const ::od::Vector3f* p = jerk_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3f&>(
      ::od::_Vector3f_default_instance_);
}
inline const ::od::Vector3f& MotionInfo::jerk() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.jerk)
  return _internal_jerk();
}
inline void MotionInfo::unsafe_arena_set_allocated_jerk(
    ::od::Vector3f* jerk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(jerk_);
  }
  jerk_ = jerk;
  if (jerk) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.MotionInfo.jerk)
}
inline ::od::Vector3f* MotionInfo::release_jerk() {
  _has_bits_[0] &= ~0x00000040u;
  ::od::Vector3f* temp = jerk_;
  jerk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3f* MotionInfo::unsafe_arena_release_jerk() {
  // @@protoc_insertion_point(field_release:od.MotionInfo.jerk)
  _has_bits_[0] &= ~0x00000040u;
  ::od::Vector3f* temp = jerk_;
  jerk_ = nullptr;
  return temp;
}
inline ::od::Vector3f* MotionInfo::_internal_mutable_jerk() {
  _has_bits_[0] |= 0x00000040u;
  if (jerk_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3f>(GetArenaForAllocation());
    jerk_ = p;
  }
  return jerk_;
}
inline ::od::Vector3f* MotionInfo::mutable_jerk() {
  ::od::Vector3f* _msg = _internal_mutable_jerk();
  // @@protoc_insertion_point(field_mutable:od.MotionInfo.jerk)
  return _msg;
}
inline void MotionInfo::set_allocated_jerk(::od::Vector3f* jerk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete jerk_;
  }
  if (jerk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3f>::GetOwningArena(jerk);
    if (message_arena != submessage_arena) {
      jerk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, jerk, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  jerk_ = jerk;
  // @@protoc_insertion_point(field_set_allocated:od.MotionInfo.jerk)
}

// optional .od.Matrix3f jerkUncertainty = 10;
inline bool MotionInfo::_internal_has_jerkuncertainty() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || jerkuncertainty_ != nullptr);
  return value;
}
inline bool MotionInfo::has_jerkuncertainty() const {
  return _internal_has_jerkuncertainty();
}
inline void MotionInfo::clear_jerkuncertainty() {
  if (jerkuncertainty_ != nullptr) jerkuncertainty_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::od::Matrix3f& MotionInfo::_internal_jerkuncertainty() const {
  const ::od::Matrix3f* p = jerkuncertainty_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Matrix3f&>(
      ::od::_Matrix3f_default_instance_);
}
inline const ::od::Matrix3f& MotionInfo::jerkuncertainty() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.jerkUncertainty)
  return _internal_jerkuncertainty();
}
inline void MotionInfo::unsafe_arena_set_allocated_jerkuncertainty(
    ::od::Matrix3f* jerkuncertainty) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(jerkuncertainty_);
  }
  jerkuncertainty_ = jerkuncertainty;
  if (jerkuncertainty) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.MotionInfo.jerkUncertainty)
}
inline ::od::Matrix3f* MotionInfo::release_jerkuncertainty() {
  _has_bits_[0] &= ~0x00000080u;
  ::od::Matrix3f* temp = jerkuncertainty_;
  jerkuncertainty_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Matrix3f* MotionInfo::unsafe_arena_release_jerkuncertainty() {
  // @@protoc_insertion_point(field_release:od.MotionInfo.jerkUncertainty)
  _has_bits_[0] &= ~0x00000080u;
  ::od::Matrix3f* temp = jerkuncertainty_;
  jerkuncertainty_ = nullptr;
  return temp;
}
inline ::od::Matrix3f* MotionInfo::_internal_mutable_jerkuncertainty() {
  _has_bits_[0] |= 0x00000080u;
  if (jerkuncertainty_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Matrix3f>(GetArenaForAllocation());
    jerkuncertainty_ = p;
  }
  return jerkuncertainty_;
}
inline ::od::Matrix3f* MotionInfo::mutable_jerkuncertainty() {
  ::od::Matrix3f* _msg = _internal_mutable_jerkuncertainty();
  // @@protoc_insertion_point(field_mutable:od.MotionInfo.jerkUncertainty)
  return _msg;
}
inline void MotionInfo::set_allocated_jerkuncertainty(::od::Matrix3f* jerkuncertainty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete jerkuncertainty_;
  }
  if (jerkuncertainty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Matrix3f>::GetOwningArena(jerkuncertainty);
    if (message_arena != submessage_arena) {
      jerkuncertainty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, jerkuncertainty, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  jerkuncertainty_ = jerkuncertainty;
  // @@protoc_insertion_point(field_set_allocated:od.MotionInfo.jerkUncertainty)
}

// optional float velocityHeading = 11;
inline bool MotionInfo::_internal_has_velocityheading() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MotionInfo::has_velocityheading() const {
  return _internal_has_velocityheading();
}
inline void MotionInfo::clear_velocityheading() {
  velocityheading_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float MotionInfo::_internal_velocityheading() const {
  return velocityheading_;
}
inline float MotionInfo::velocityheading() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.velocityHeading)
  return _internal_velocityheading();
}
inline void MotionInfo::_internal_set_velocityheading(float value) {
  _has_bits_[0] |= 0x00000400u;
  velocityheading_ = value;
}
inline void MotionInfo::set_velocityheading(float value) {
  _internal_set_velocityheading(value);
  // @@protoc_insertion_point(field_set:od.MotionInfo.velocityHeading)
}

// optional float velocityHeadingUncertainty = 12;
inline bool MotionInfo::_internal_has_velocityheadinguncertainty() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MotionInfo::has_velocityheadinguncertainty() const {
  return _internal_has_velocityheadinguncertainty();
}
inline void MotionInfo::clear_velocityheadinguncertainty() {
  velocityheadinguncertainty_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float MotionInfo::_internal_velocityheadinguncertainty() const {
  return velocityheadinguncertainty_;
}
inline float MotionInfo::velocityheadinguncertainty() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.velocityHeadingUncertainty)
  return _internal_velocityheadinguncertainty();
}
inline void MotionInfo::_internal_set_velocityheadinguncertainty(float value) {
  _has_bits_[0] |= 0x00000800u;
  velocityheadinguncertainty_ = value;
}
inline void MotionInfo::set_velocityheadinguncertainty(float value) {
  _internal_set_velocityheadinguncertainty(value);
  // @@protoc_insertion_point(field_set:od.MotionInfo.velocityHeadingUncertainty)
}

// optional float velocityHeadingRate = 13;
inline bool MotionInfo::_internal_has_velocityheadingrate() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool MotionInfo::has_velocityheadingrate() const {
  return _internal_has_velocityheadingrate();
}
inline void MotionInfo::clear_velocityheadingrate() {
  velocityheadingrate_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float MotionInfo::_internal_velocityheadingrate() const {
  return velocityheadingrate_;
}
inline float MotionInfo::velocityheadingrate() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.velocityHeadingRate)
  return _internal_velocityheadingrate();
}
inline void MotionInfo::_internal_set_velocityheadingrate(float value) {
  _has_bits_[0] |= 0x00001000u;
  velocityheadingrate_ = value;
}
inline void MotionInfo::set_velocityheadingrate(float value) {
  _internal_set_velocityheadingrate(value);
  // @@protoc_insertion_point(field_set:od.MotionInfo.velocityHeadingRate)
}

// optional float velocityHeadingRateUncertainty = 14;
inline bool MotionInfo::_internal_has_velocityheadingrateuncertainty() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool MotionInfo::has_velocityheadingrateuncertainty() const {
  return _internal_has_velocityheadingrateuncertainty();
}
inline void MotionInfo::clear_velocityheadingrateuncertainty() {
  velocityheadingrateuncertainty_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float MotionInfo::_internal_velocityheadingrateuncertainty() const {
  return velocityheadingrateuncertainty_;
}
inline float MotionInfo::velocityheadingrateuncertainty() const {
  // @@protoc_insertion_point(field_get:od.MotionInfo.velocityHeadingRateUncertainty)
  return _internal_velocityheadingrateuncertainty();
}
inline void MotionInfo::_internal_set_velocityheadingrateuncertainty(float value) {
  _has_bits_[0] |= 0x00002000u;
  velocityheadingrateuncertainty_ = value;
}
inline void MotionInfo::set_velocityheadingrateuncertainty(float value) {
  _internal_set_velocityheadingrateuncertainty(value);
  // @@protoc_insertion_point(field_set:od.MotionInfo.velocityHeadingRateUncertainty)
}

// -------------------------------------------------------------------

// Point2f

// optional float x = 1;
inline bool Point2f::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Point2f::has_x() const {
  return _internal_has_x();
}
inline void Point2f::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Point2f::_internal_x() const {
  return x_;
}
inline float Point2f::x() const {
  // @@protoc_insertion_point(field_get:od.Point2f.x)
  return _internal_x();
}
inline void Point2f::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Point2f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:od.Point2f.x)
}

// optional float y = 2;
inline bool Point2f::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Point2f::has_y() const {
  return _internal_has_y();
}
inline void Point2f::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Point2f::_internal_y() const {
  return y_;
}
inline float Point2f::y() const {
  // @@protoc_insertion_point(field_get:od.Point2f.y)
  return _internal_y();
}
inline void Point2f::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Point2f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:od.Point2f.y)
}

// -------------------------------------------------------------------

// Vector3f

// optional float x = 1;
inline bool Vector3f::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vector3f::has_x() const {
  return _internal_has_x();
}
inline void Vector3f::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Vector3f::_internal_x() const {
  return x_;
}
inline float Vector3f::x() const {
  // @@protoc_insertion_point(field_get:od.Vector3f.x)
  return _internal_x();
}
inline void Vector3f::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Vector3f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:od.Vector3f.x)
}

// optional float y = 2;
inline bool Vector3f::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vector3f::has_y() const {
  return _internal_has_y();
}
inline void Vector3f::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Vector3f::_internal_y() const {
  return y_;
}
inline float Vector3f::y() const {
  // @@protoc_insertion_point(field_get:od.Vector3f.y)
  return _internal_y();
}
inline void Vector3f::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Vector3f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:od.Vector3f.y)
}

// optional float z = 3;
inline bool Vector3f::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Vector3f::has_z() const {
  return _internal_has_z();
}
inline void Vector3f::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Vector3f::_internal_z() const {
  return z_;
}
inline float Vector3f::z() const {
  // @@protoc_insertion_point(field_get:od.Vector3f.z)
  return _internal_z();
}
inline void Vector3f::_internal_set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void Vector3f::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:od.Vector3f.z)
}

// -------------------------------------------------------------------

// Matrix3f

// optional .od.Vector3f x = 1;
inline bool Matrix3f::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || x_ != nullptr);
  return value;
}
inline bool Matrix3f::has_x() const {
  return _internal_has_x();
}
inline void Matrix3f::clear_x() {
  if (x_ != nullptr) x_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::od::Vector3f& Matrix3f::_internal_x() const {
  const ::od::Vector3f* p = x_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3f&>(
      ::od::_Vector3f_default_instance_);
}
inline const ::od::Vector3f& Matrix3f::x() const {
  // @@protoc_insertion_point(field_get:od.Matrix3f.x)
  return _internal_x();
}
inline void Matrix3f::unsafe_arena_set_allocated_x(
    ::od::Vector3f* x) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  x_ = x;
  if (x) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.Matrix3f.x)
}
inline ::od::Vector3f* Matrix3f::release_x() {
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3f* temp = x_;
  x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3f* Matrix3f::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:od.Matrix3f.x)
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3f* temp = x_;
  x_ = nullptr;
  return temp;
}
inline ::od::Vector3f* Matrix3f::_internal_mutable_x() {
  _has_bits_[0] |= 0x00000001u;
  if (x_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3f>(GetArenaForAllocation());
    x_ = p;
  }
  return x_;
}
inline ::od::Vector3f* Matrix3f::mutable_x() {
  ::od::Vector3f* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:od.Matrix3f.x)
  return _msg;
}
inline void Matrix3f::set_allocated_x(::od::Vector3f* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete x_;
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3f>::GetOwningArena(x);
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:od.Matrix3f.x)
}

// optional .od.Vector3f y = 2;
inline bool Matrix3f::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || y_ != nullptr);
  return value;
}
inline bool Matrix3f::has_y() const {
  return _internal_has_y();
}
inline void Matrix3f::clear_y() {
  if (y_ != nullptr) y_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::od::Vector3f& Matrix3f::_internal_y() const {
  const ::od::Vector3f* p = y_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3f&>(
      ::od::_Vector3f_default_instance_);
}
inline const ::od::Vector3f& Matrix3f::y() const {
  // @@protoc_insertion_point(field_get:od.Matrix3f.y)
  return _internal_y();
}
inline void Matrix3f::unsafe_arena_set_allocated_y(
    ::od::Vector3f* y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.Matrix3f.y)
}
inline ::od::Vector3f* Matrix3f::release_y() {
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3f* temp = y_;
  y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3f* Matrix3f::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:od.Matrix3f.y)
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3f* temp = y_;
  y_ = nullptr;
  return temp;
}
inline ::od::Vector3f* Matrix3f::_internal_mutable_y() {
  _has_bits_[0] |= 0x00000002u;
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3f>(GetArenaForAllocation());
    y_ = p;
  }
  return y_;
}
inline ::od::Vector3f* Matrix3f::mutable_y() {
  ::od::Vector3f* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:od.Matrix3f.y)
  return _msg;
}
inline void Matrix3f::set_allocated_y(::od::Vector3f* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete y_;
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3f>::GetOwningArena(y);
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:od.Matrix3f.y)
}

// optional .od.Vector3f z = 3;
inline bool Matrix3f::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || z_ != nullptr);
  return value;
}
inline bool Matrix3f::has_z() const {
  return _internal_has_z();
}
inline void Matrix3f::clear_z() {
  if (z_ != nullptr) z_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::od::Vector3f& Matrix3f::_internal_z() const {
  const ::od::Vector3f* p = z_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3f&>(
      ::od::_Vector3f_default_instance_);
}
inline const ::od::Vector3f& Matrix3f::z() const {
  // @@protoc_insertion_point(field_get:od.Matrix3f.z)
  return _internal_z();
}
inline void Matrix3f::unsafe_arena_set_allocated_z(
    ::od::Vector3f* z) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z_);
  }
  z_ = z;
  if (z) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.Matrix3f.z)
}
inline ::od::Vector3f* Matrix3f::release_z() {
  _has_bits_[0] &= ~0x00000004u;
  ::od::Vector3f* temp = z_;
  z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3f* Matrix3f::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_release:od.Matrix3f.z)
  _has_bits_[0] &= ~0x00000004u;
  ::od::Vector3f* temp = z_;
  z_ = nullptr;
  return temp;
}
inline ::od::Vector3f* Matrix3f::_internal_mutable_z() {
  _has_bits_[0] |= 0x00000004u;
  if (z_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3f>(GetArenaForAllocation());
    z_ = p;
  }
  return z_;
}
inline ::od::Vector3f* Matrix3f::mutable_z() {
  ::od::Vector3f* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:od.Matrix3f.z)
  return _msg;
}
inline void Matrix3f::set_allocated_z(::od::Vector3f* z) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete z_;
  }
  if (z) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3f>::GetOwningArena(z);
    if (message_arena != submessage_arena) {
      z = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:od.Matrix3f.z)
}

// -------------------------------------------------------------------

// ObstacleCube

// optional string camera = 1;
inline bool ObstacleCube::_internal_has_camera() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObstacleCube::has_camera() const {
  return _internal_has_camera();
}
inline void ObstacleCube::clear_camera() {
  camera_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObstacleCube::camera() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.camera)
  return _internal_camera();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObstacleCube::set_camera(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:od.ObstacleCube.camera)
}
inline std::string* ObstacleCube::mutable_camera() {
  std::string* _s = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:od.ObstacleCube.camera)
  return _s;
}
inline const std::string& ObstacleCube::_internal_camera() const {
  return camera_.Get();
}
inline void ObstacleCube::_internal_set_camera(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObstacleCube::_internal_mutable_camera() {
  _has_bits_[0] |= 0x00000001u;
  return camera_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObstacleCube::release_camera() {
  // @@protoc_insertion_point(field_release:od.ObstacleCube.camera)
  if (!_internal_has_camera()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = camera_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObstacleCube::set_allocated_camera(std::string* camera) {
  if (camera != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  camera_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), camera,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleCube.camera)
}

// optional int32 label = 2;
inline bool ObstacleCube::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ObstacleCube::has_label() const {
  return _internal_has_label();
}
inline void ObstacleCube::clear_label() {
  label_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t ObstacleCube::_internal_label() const {
  return label_;
}
inline int32_t ObstacleCube::label() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.label)
  return _internal_label();
}
inline void ObstacleCube::_internal_set_label(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  label_ = value;
}
inline void ObstacleCube::set_label(int32_t value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCube.label)
}

// optional float typeConfidence = 3;
inline bool ObstacleCube::_internal_has_typeconfidence() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ObstacleCube::has_typeconfidence() const {
  return _internal_has_typeconfidence();
}
inline void ObstacleCube::clear_typeconfidence() {
  typeconfidence_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ObstacleCube::_internal_typeconfidence() const {
  return typeconfidence_;
}
inline float ObstacleCube::typeconfidence() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.typeConfidence)
  return _internal_typeconfidence();
}
inline void ObstacleCube::_internal_set_typeconfidence(float value) {
  _has_bits_[0] |= 0x00000040u;
  typeconfidence_ = value;
}
inline void ObstacleCube::set_typeconfidence(float value) {
  _internal_set_typeconfidence(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCube.typeConfidence)
}

// optional float existenceConfidence = 4;
inline bool ObstacleCube::_internal_has_existenceconfidence() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ObstacleCube::has_existenceconfidence() const {
  return _internal_has_existenceconfidence();
}
inline void ObstacleCube::clear_existenceconfidence() {
  existenceconfidence_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float ObstacleCube::_internal_existenceconfidence() const {
  return existenceconfidence_;
}
inline float ObstacleCube::existenceconfidence() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.existenceConfidence)
  return _internal_existenceconfidence();
}
inline void ObstacleCube::_internal_set_existenceconfidence(float value) {
  _has_bits_[0] |= 0x00000080u;
  existenceconfidence_ = value;
}
inline void ObstacleCube::set_existenceconfidence(float value) {
  _internal_set_existenceconfidence(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCube.existenceConfidence)
}

// optional int32 trackId = 5;
inline bool ObstacleCube::_internal_has_trackid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ObstacleCube::has_trackid() const {
  return _internal_has_trackid();
}
inline void ObstacleCube::clear_trackid() {
  trackid_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ObstacleCube::_internal_trackid() const {
  return trackid_;
}
inline int32_t ObstacleCube::trackid() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.trackId)
  return _internal_trackid();
}
inline void ObstacleCube::_internal_set_trackid(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  trackid_ = value;
}
inline void ObstacleCube::set_trackid(int32_t value) {
  _internal_set_trackid(value);
  // @@protoc_insertion_point(field_set:od.ObstacleCube.trackId)
}

// optional .od.Vector3d Center = 6;
inline bool ObstacleCube::_internal_has_center() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || center_ != nullptr);
  return value;
}
inline bool ObstacleCube::has_center() const {
  return _internal_has_center();
}
inline void ObstacleCube::clear_center() {
  if (center_ != nullptr) center_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::od::Vector3d& ObstacleCube::_internal_center() const {
  const ::od::Vector3d* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3d&>(
      ::od::_Vector3d_default_instance_);
}
inline const ::od::Vector3d& ObstacleCube::center() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.Center)
  return _internal_center();
}
inline void ObstacleCube::unsafe_arena_set_allocated_center(
    ::od::Vector3d* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleCube.Center)
}
inline ::od::Vector3d* ObstacleCube::release_center() {
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3d* temp = center_;
  center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3d* ObstacleCube::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:od.ObstacleCube.Center)
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3d* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::od::Vector3d* ObstacleCube::_internal_mutable_center() {
  _has_bits_[0] |= 0x00000002u;
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3d>(GetArenaForAllocation());
    center_ = p;
  }
  return center_;
}
inline ::od::Vector3d* ObstacleCube::mutable_center() {
  ::od::Vector3d* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:od.ObstacleCube.Center)
  return _msg;
}
inline void ObstacleCube::set_allocated_center(::od::Vector3d* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3d>::GetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleCube.Center)
}

// optional .od.Vector3d shape = 7;
inline bool ObstacleCube::_internal_has_shape() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || shape_ != nullptr);
  return value;
}
inline bool ObstacleCube::has_shape() const {
  return _internal_has_shape();
}
inline void ObstacleCube::clear_shape() {
  if (shape_ != nullptr) shape_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::od::Vector3d& ObstacleCube::_internal_shape() const {
  const ::od::Vector3d* p = shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3d&>(
      ::od::_Vector3d_default_instance_);
}
inline const ::od::Vector3d& ObstacleCube::shape() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.shape)
  return _internal_shape();
}
inline void ObstacleCube::unsafe_arena_set_allocated_shape(
    ::od::Vector3d* shape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shape_);
  }
  shape_ = shape;
  if (shape) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleCube.shape)
}
inline ::od::Vector3d* ObstacleCube::release_shape() {
  _has_bits_[0] &= ~0x00000004u;
  ::od::Vector3d* temp = shape_;
  shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3d* ObstacleCube::unsafe_arena_release_shape() {
  // @@protoc_insertion_point(field_release:od.ObstacleCube.shape)
  _has_bits_[0] &= ~0x00000004u;
  ::od::Vector3d* temp = shape_;
  shape_ = nullptr;
  return temp;
}
inline ::od::Vector3d* ObstacleCube::_internal_mutable_shape() {
  _has_bits_[0] |= 0x00000004u;
  if (shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3d>(GetArenaForAllocation());
    shape_ = p;
  }
  return shape_;
}
inline ::od::Vector3d* ObstacleCube::mutable_shape() {
  ::od::Vector3d* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:od.ObstacleCube.shape)
  return _msg;
}
inline void ObstacleCube::set_allocated_shape(::od::Vector3d* shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete shape_;
  }
  if (shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3d>::GetOwningArena(shape);
    if (message_arena != submessage_arena) {
      shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleCube.shape)
}

// optional .od.Vector3d direction = 8;
inline bool ObstacleCube::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || direction_ != nullptr);
  return value;
}
inline bool ObstacleCube::has_direction() const {
  return _internal_has_direction();
}
inline void ObstacleCube::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::od::Vector3d& ObstacleCube::_internal_direction() const {
  const ::od::Vector3d* p = direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3d&>(
      ::od::_Vector3d_default_instance_);
}
inline const ::od::Vector3d& ObstacleCube::direction() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.direction)
  return _internal_direction();
}
inline void ObstacleCube::unsafe_arena_set_allocated_direction(
    ::od::Vector3d* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction_);
  }
  direction_ = direction;
  if (direction) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleCube.direction)
}
inline ::od::Vector3d* ObstacleCube::release_direction() {
  _has_bits_[0] &= ~0x00000008u;
  ::od::Vector3d* temp = direction_;
  direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3d* ObstacleCube::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:od.ObstacleCube.direction)
  _has_bits_[0] &= ~0x00000008u;
  ::od::Vector3d* temp = direction_;
  direction_ = nullptr;
  return temp;
}
inline ::od::Vector3d* ObstacleCube::_internal_mutable_direction() {
  _has_bits_[0] |= 0x00000008u;
  if (direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3d>(GetArenaForAllocation());
    direction_ = p;
  }
  return direction_;
}
inline ::od::Vector3d* ObstacleCube::mutable_direction() {
  ::od::Vector3d* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:od.ObstacleCube.direction)
  return _msg;
}
inline void ObstacleCube::set_allocated_direction(::od::Vector3d* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete direction_;
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3d>::GetOwningArena(direction);
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleCube.direction)
}

// optional .od.MotionInfo motionInfo = 9;
inline bool ObstacleCube::_internal_has_motioninfo() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || motioninfo_ != nullptr);
  return value;
}
inline bool ObstacleCube::has_motioninfo() const {
  return _internal_has_motioninfo();
}
inline void ObstacleCube::clear_motioninfo() {
  if (motioninfo_ != nullptr) motioninfo_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::od::MotionInfo& ObstacleCube::_internal_motioninfo() const {
  const ::od::MotionInfo* p = motioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::MotionInfo&>(
      ::od::_MotionInfo_default_instance_);
}
inline const ::od::MotionInfo& ObstacleCube::motioninfo() const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.motionInfo)
  return _internal_motioninfo();
}
inline void ObstacleCube::unsafe_arena_set_allocated_motioninfo(
    ::od::MotionInfo* motioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motioninfo_);
  }
  motioninfo_ = motioninfo;
  if (motioninfo) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleCube.motionInfo)
}
inline ::od::MotionInfo* ObstacleCube::release_motioninfo() {
  _has_bits_[0] &= ~0x00000010u;
  ::od::MotionInfo* temp = motioninfo_;
  motioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::MotionInfo* ObstacleCube::unsafe_arena_release_motioninfo() {
  // @@protoc_insertion_point(field_release:od.ObstacleCube.motionInfo)
  _has_bits_[0] &= ~0x00000010u;
  ::od::MotionInfo* temp = motioninfo_;
  motioninfo_ = nullptr;
  return temp;
}
inline ::od::MotionInfo* ObstacleCube::_internal_mutable_motioninfo() {
  _has_bits_[0] |= 0x00000010u;
  if (motioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::MotionInfo>(GetArenaForAllocation());
    motioninfo_ = p;
  }
  return motioninfo_;
}
inline ::od::MotionInfo* ObstacleCube::mutable_motioninfo() {
  ::od::MotionInfo* _msg = _internal_mutable_motioninfo();
  // @@protoc_insertion_point(field_mutable:od.ObstacleCube.motionInfo)
  return _msg;
}
inline void ObstacleCube::set_allocated_motioninfo(::od::MotionInfo* motioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete motioninfo_;
  }
  if (motioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::MotionInfo>::GetOwningArena(motioninfo);
    if (message_arena != submessage_arena) {
      motioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motioninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  motioninfo_ = motioninfo;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleCube.motionInfo)
}

// repeated .od.ObstacleTrajectory trajectory = 10;
inline int ObstacleCube::_internal_trajectory_size() const {
  return trajectory_.size();
}
inline int ObstacleCube::trajectory_size() const {
  return _internal_trajectory_size();
}
inline void ObstacleCube::clear_trajectory() {
  trajectory_.Clear();
}
inline ::od::ObstacleTrajectory* ObstacleCube::mutable_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:od.ObstacleCube.trajectory)
  return trajectory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory >*
ObstacleCube::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleCube.trajectory)
  return &trajectory_;
}
inline const ::od::ObstacleTrajectory& ObstacleCube::_internal_trajectory(int index) const {
  return trajectory_.Get(index);
}
inline const ::od::ObstacleTrajectory& ObstacleCube::trajectory(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleCube.trajectory)
  return _internal_trajectory(index);
}
inline ::od::ObstacleTrajectory* ObstacleCube::_internal_add_trajectory() {
  return trajectory_.Add();
}
inline ::od::ObstacleTrajectory* ObstacleCube::add_trajectory() {
  ::od::ObstacleTrajectory* _add = _internal_add_trajectory();
  // @@protoc_insertion_point(field_add:od.ObstacleCube.trajectory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectory >&
ObstacleCube::trajectory() const {
  // @@protoc_insertion_point(field_list:od.ObstacleCube.trajectory)
  return trajectory_;
}

// -------------------------------------------------------------------

// ObstacleTrajectory

// optional .od.MotionStatus motionStatus = 1;
inline bool ObstacleTrajectory::_internal_has_motionstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObstacleTrajectory::has_motionstatus() const {
  return _internal_has_motionstatus();
}
inline void ObstacleTrajectory::clear_motionstatus() {
  motionstatus_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::od::MotionStatus ObstacleTrajectory::_internal_motionstatus() const {
  return static_cast< ::od::MotionStatus >(motionstatus_);
}
inline ::od::MotionStatus ObstacleTrajectory::motionstatus() const {
  // @@protoc_insertion_point(field_get:od.ObstacleTrajectory.motionStatus)
  return _internal_motionstatus();
}
inline void ObstacleTrajectory::_internal_set_motionstatus(::od::MotionStatus value) {
  _has_bits_[0] |= 0x00000001u;
  motionstatus_ = value;
}
inline void ObstacleTrajectory::set_motionstatus(::od::MotionStatus value) {
  _internal_set_motionstatus(value);
  // @@protoc_insertion_point(field_set:od.ObstacleTrajectory.motionStatus)
}

// optional float confidence = 2;
inline bool ObstacleTrajectory::_internal_has_confidence() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObstacleTrajectory::has_confidence() const {
  return _internal_has_confidence();
}
inline void ObstacleTrajectory::clear_confidence() {
  confidence_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ObstacleTrajectory::_internal_confidence() const {
  return confidence_;
}
inline float ObstacleTrajectory::confidence() const {
  // @@protoc_insertion_point(field_get:od.ObstacleTrajectory.confidence)
  return _internal_confidence();
}
inline void ObstacleTrajectory::_internal_set_confidence(float value) {
  _has_bits_[0] |= 0x00000002u;
  confidence_ = value;
}
inline void ObstacleTrajectory::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:od.ObstacleTrajectory.confidence)
}

// repeated .od.ObstacleTrajectoryPoint points = 3;
inline int ObstacleTrajectory::_internal_points_size() const {
  return points_.size();
}
inline int ObstacleTrajectory::points_size() const {
  return _internal_points_size();
}
inline void ObstacleTrajectory::clear_points() {
  points_.Clear();
}
inline ::od::ObstacleTrajectoryPoint* ObstacleTrajectory::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:od.ObstacleTrajectory.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectoryPoint >*
ObstacleTrajectory::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleTrajectory.points)
  return &points_;
}
inline const ::od::ObstacleTrajectoryPoint& ObstacleTrajectory::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::od::ObstacleTrajectoryPoint& ObstacleTrajectory::points(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleTrajectory.points)
  return _internal_points(index);
}
inline ::od::ObstacleTrajectoryPoint* ObstacleTrajectory::_internal_add_points() {
  return points_.Add();
}
inline ::od::ObstacleTrajectoryPoint* ObstacleTrajectory::add_points() {
  ::od::ObstacleTrajectoryPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:od.ObstacleTrajectory.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::ObstacleTrajectoryPoint >&
ObstacleTrajectory::points() const {
  // @@protoc_insertion_point(field_list:od.ObstacleTrajectory.points)
  return points_;
}

// -------------------------------------------------------------------

// ObstacleTrajectoryPoint

// optional uint64 deltaTNs = 1;
inline bool ObstacleTrajectoryPoint::_internal_has_deltatns() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObstacleTrajectoryPoint::has_deltatns() const {
  return _internal_has_deltatns();
}
inline void ObstacleTrajectoryPoint::clear_deltatns() {
  deltatns_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ObstacleTrajectoryPoint::_internal_deltatns() const {
  return deltatns_;
}
inline uint64_t ObstacleTrajectoryPoint::deltatns() const {
  // @@protoc_insertion_point(field_get:od.ObstacleTrajectoryPoint.deltaTNs)
  return _internal_deltatns();
}
inline void ObstacleTrajectoryPoint::_internal_set_deltatns(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  deltatns_ = value;
}
inline void ObstacleTrajectoryPoint::set_deltatns(uint64_t value) {
  _internal_set_deltatns(value);
  // @@protoc_insertion_point(field_set:od.ObstacleTrajectoryPoint.deltaTNs)
}

// optional .od.Vector3f center = 2;
inline bool ObstacleTrajectoryPoint::_internal_has_center() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || center_ != nullptr);
  return value;
}
inline bool ObstacleTrajectoryPoint::has_center() const {
  return _internal_has_center();
}
inline void ObstacleTrajectoryPoint::clear_center() {
  if (center_ != nullptr) center_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::od::Vector3f& ObstacleTrajectoryPoint::_internal_center() const {
  const ::od::Vector3f* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3f&>(
      ::od::_Vector3f_default_instance_);
}
inline const ::od::Vector3f& ObstacleTrajectoryPoint::center() const {
  // @@protoc_insertion_point(field_get:od.ObstacleTrajectoryPoint.center)
  return _internal_center();
}
inline void ObstacleTrajectoryPoint::unsafe_arena_set_allocated_center(
    ::od::Vector3f* center) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleTrajectoryPoint.center)
}
inline ::od::Vector3f* ObstacleTrajectoryPoint::release_center() {
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3f* temp = center_;
  center_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3f* ObstacleTrajectoryPoint::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:od.ObstacleTrajectoryPoint.center)
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3f* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::od::Vector3f* ObstacleTrajectoryPoint::_internal_mutable_center() {
  _has_bits_[0] |= 0x00000001u;
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3f>(GetArenaForAllocation());
    center_ = p;
  }
  return center_;
}
inline ::od::Vector3f* ObstacleTrajectoryPoint::mutable_center() {
  ::od::Vector3f* _msg = _internal_mutable_center();
  // @@protoc_insertion_point(field_mutable:od.ObstacleTrajectoryPoint.center)
  return _msg;
}
inline void ObstacleTrajectoryPoint::set_allocated_center(::od::Vector3f* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3f>::GetOwningArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleTrajectoryPoint.center)
}

// optional .od.Vector3f direction = 3;
inline bool ObstacleTrajectoryPoint::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || direction_ != nullptr);
  return value;
}
inline bool ObstacleTrajectoryPoint::has_direction() const {
  return _internal_has_direction();
}
inline void ObstacleTrajectoryPoint::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::od::Vector3f& ObstacleTrajectoryPoint::_internal_direction() const {
  const ::od::Vector3f* p = direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3f&>(
      ::od::_Vector3f_default_instance_);
}
inline const ::od::Vector3f& ObstacleTrajectoryPoint::direction() const {
  // @@protoc_insertion_point(field_get:od.ObstacleTrajectoryPoint.direction)
  return _internal_direction();
}
inline void ObstacleTrajectoryPoint::unsafe_arena_set_allocated_direction(
    ::od::Vector3f* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction_);
  }
  direction_ = direction;
  if (direction) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleTrajectoryPoint.direction)
}
inline ::od::Vector3f* ObstacleTrajectoryPoint::release_direction() {
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3f* temp = direction_;
  direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3f* ObstacleTrajectoryPoint::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:od.ObstacleTrajectoryPoint.direction)
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3f* temp = direction_;
  direction_ = nullptr;
  return temp;
}
inline ::od::Vector3f* ObstacleTrajectoryPoint::_internal_mutable_direction() {
  _has_bits_[0] |= 0x00000002u;
  if (direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3f>(GetArenaForAllocation());
    direction_ = p;
  }
  return direction_;
}
inline ::od::Vector3f* ObstacleTrajectoryPoint::mutable_direction() {
  ::od::Vector3f* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:od.ObstacleTrajectoryPoint.direction)
  return _msg;
}
inline void ObstacleTrajectoryPoint::set_allocated_direction(::od::Vector3f* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete direction_;
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3f>::GetOwningArena(direction);
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleTrajectoryPoint.direction)
}

// -------------------------------------------------------------------

// ObstacleRaw

// optional string camera = 1;
inline bool ObstacleRaw::_internal_has_camera() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObstacleRaw::has_camera() const {
  return _internal_has_camera();
}
inline void ObstacleRaw::clear_camera() {
  camera_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObstacleRaw::camera() const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.camera)
  return _internal_camera();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObstacleRaw::set_camera(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.camera)
}
inline std::string* ObstacleRaw::mutable_camera() {
  std::string* _s = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:od.ObstacleRaw.camera)
  return _s;
}
inline const std::string& ObstacleRaw::_internal_camera() const {
  return camera_.Get();
}
inline void ObstacleRaw::_internal_set_camera(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  camera_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ObstacleRaw::_internal_mutable_camera() {
  _has_bits_[0] |= 0x00000001u;
  return camera_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ObstacleRaw::release_camera() {
  // @@protoc_insertion_point(field_release:od.ObstacleRaw.camera)
  if (!_internal_has_camera()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = camera_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ObstacleRaw::set_allocated_camera(std::string* camera) {
  if (camera != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  camera_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), camera,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    camera_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleRaw.camera)
}

// optional int32 label = 2;
inline bool ObstacleRaw::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ObstacleRaw::has_label() const {
  return _internal_has_label();
}
inline void ObstacleRaw::clear_label() {
  label_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ObstacleRaw::_internal_label() const {
  return label_;
}
inline int32_t ObstacleRaw::label() const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.label)
  return _internal_label();
}
inline void ObstacleRaw::_internal_set_label(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  label_ = value;
}
inline void ObstacleRaw::set_label(int32_t value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.label)
}

// optional float typeConfidence = 3;
inline bool ObstacleRaw::_internal_has_typeconfidence() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ObstacleRaw::has_typeconfidence() const {
  return _internal_has_typeconfidence();
}
inline void ObstacleRaw::clear_typeconfidence() {
  typeconfidence_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float ObstacleRaw::_internal_typeconfidence() const {
  return typeconfidence_;
}
inline float ObstacleRaw::typeconfidence() const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.typeConfidence)
  return _internal_typeconfidence();
}
inline void ObstacleRaw::_internal_set_typeconfidence(float value) {
  _has_bits_[0] |= 0x00000020u;
  typeconfidence_ = value;
}
inline void ObstacleRaw::set_typeconfidence(float value) {
  _internal_set_typeconfidence(value);
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.typeConfidence)
}

// optional float existenceConfidence = 4;
inline bool ObstacleRaw::_internal_has_existenceconfidence() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ObstacleRaw::has_existenceconfidence() const {
  return _internal_has_existenceconfidence();
}
inline void ObstacleRaw::clear_existenceconfidence() {
  existenceconfidence_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ObstacleRaw::_internal_existenceconfidence() const {
  return existenceconfidence_;
}
inline float ObstacleRaw::existenceconfidence() const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.existenceConfidence)
  return _internal_existenceconfidence();
}
inline void ObstacleRaw::_internal_set_existenceconfidence(float value) {
  _has_bits_[0] |= 0x00000040u;
  existenceconfidence_ = value;
}
inline void ObstacleRaw::set_existenceconfidence(float value) {
  _internal_set_existenceconfidence(value);
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.existenceConfidence)
}

// optional .od.Bbox2D box2D = 5;
inline bool ObstacleRaw::_internal_has_box2d() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || box2d_ != nullptr);
  return value;
}
inline bool ObstacleRaw::has_box2d() const {
  return _internal_has_box2d();
}
inline void ObstacleRaw::clear_box2d() {
  if (box2d_ != nullptr) box2d_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::od::Bbox2D& ObstacleRaw::_internal_box2d() const {
  const ::od::Bbox2D* p = box2d_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Bbox2D&>(
      ::od::_Bbox2D_default_instance_);
}
inline const ::od::Bbox2D& ObstacleRaw::box2d() const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.box2D)
  return _internal_box2d();
}
inline void ObstacleRaw::unsafe_arena_set_allocated_box2d(
    ::od::Bbox2D* box2d) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box2d_);
  }
  box2d_ = box2d;
  if (box2d) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleRaw.box2D)
}
inline ::od::Bbox2D* ObstacleRaw::release_box2d() {
  _has_bits_[0] &= ~0x00000002u;
  ::od::Bbox2D* temp = box2d_;
  box2d_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Bbox2D* ObstacleRaw::unsafe_arena_release_box2d() {
  // @@protoc_insertion_point(field_release:od.ObstacleRaw.box2D)
  _has_bits_[0] &= ~0x00000002u;
  ::od::Bbox2D* temp = box2d_;
  box2d_ = nullptr;
  return temp;
}
inline ::od::Bbox2D* ObstacleRaw::_internal_mutable_box2d() {
  _has_bits_[0] |= 0x00000002u;
  if (box2d_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Bbox2D>(GetArenaForAllocation());
    box2d_ = p;
  }
  return box2d_;
}
inline ::od::Bbox2D* ObstacleRaw::mutable_box2d() {
  ::od::Bbox2D* _msg = _internal_mutable_box2d();
  // @@protoc_insertion_point(field_mutable:od.ObstacleRaw.box2D)
  return _msg;
}
inline void ObstacleRaw::set_allocated_box2d(::od::Bbox2D* box2d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete box2d_;
  }
  if (box2d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Bbox2D>::GetOwningArena(box2d);
    if (message_arena != submessage_arena) {
      box2d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box2d, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  box2d_ = box2d;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleRaw.box2D)
}

// optional .od.DirectionInfo directionInfo = 6;
inline bool ObstacleRaw::_internal_has_directioninfo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || directioninfo_ != nullptr);
  return value;
}
inline bool ObstacleRaw::has_directioninfo() const {
  return _internal_has_directioninfo();
}
inline void ObstacleRaw::clear_directioninfo() {
  if (directioninfo_ != nullptr) directioninfo_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::od::DirectionInfo& ObstacleRaw::_internal_directioninfo() const {
  const ::od::DirectionInfo* p = directioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::DirectionInfo&>(
      ::od::_DirectionInfo_default_instance_);
}
inline const ::od::DirectionInfo& ObstacleRaw::directioninfo() const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.directionInfo)
  return _internal_directioninfo();
}
inline void ObstacleRaw::unsafe_arena_set_allocated_directioninfo(
    ::od::DirectionInfo* directioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(directioninfo_);
  }
  directioninfo_ = directioninfo;
  if (directioninfo) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleRaw.directionInfo)
}
inline ::od::DirectionInfo* ObstacleRaw::release_directioninfo() {
  _has_bits_[0] &= ~0x00000004u;
  ::od::DirectionInfo* temp = directioninfo_;
  directioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::DirectionInfo* ObstacleRaw::unsafe_arena_release_directioninfo() {
  // @@protoc_insertion_point(field_release:od.ObstacleRaw.directionInfo)
  _has_bits_[0] &= ~0x00000004u;
  ::od::DirectionInfo* temp = directioninfo_;
  directioninfo_ = nullptr;
  return temp;
}
inline ::od::DirectionInfo* ObstacleRaw::_internal_mutable_directioninfo() {
  _has_bits_[0] |= 0x00000004u;
  if (directioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::DirectionInfo>(GetArenaForAllocation());
    directioninfo_ = p;
  }
  return directioninfo_;
}
inline ::od::DirectionInfo* ObstacleRaw::mutable_directioninfo() {
  ::od::DirectionInfo* _msg = _internal_mutable_directioninfo();
  // @@protoc_insertion_point(field_mutable:od.ObstacleRaw.directionInfo)
  return _msg;
}
inline void ObstacleRaw::set_allocated_directioninfo(::od::DirectionInfo* directioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete directioninfo_;
  }
  if (directioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::DirectionInfo>::GetOwningArena(directioninfo);
    if (message_arena != submessage_arena) {
      directioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, directioninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  directioninfo_ = directioninfo;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleRaw.directionInfo)
}

// repeated .od.Point2f landmark = 7;
inline int ObstacleRaw::_internal_landmark_size() const {
  return landmark_.size();
}
inline int ObstacleRaw::landmark_size() const {
  return _internal_landmark_size();
}
inline void ObstacleRaw::clear_landmark() {
  landmark_.Clear();
}
inline ::od::Point2f* ObstacleRaw::mutable_landmark(int index) {
  // @@protoc_insertion_point(field_mutable:od.ObstacleRaw.landmark)
  return landmark_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >*
ObstacleRaw::mutable_landmark() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleRaw.landmark)
  return &landmark_;
}
inline const ::od::Point2f& ObstacleRaw::_internal_landmark(int index) const {
  return landmark_.Get(index);
}
inline const ::od::Point2f& ObstacleRaw::landmark(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.landmark)
  return _internal_landmark(index);
}
inline ::od::Point2f* ObstacleRaw::_internal_add_landmark() {
  return landmark_.Add();
}
inline ::od::Point2f* ObstacleRaw::add_landmark() {
  ::od::Point2f* _add = _internal_add_landmark();
  // @@protoc_insertion_point(field_add:od.ObstacleRaw.landmark)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >&
ObstacleRaw::landmark() const {
  // @@protoc_insertion_point(field_list:od.ObstacleRaw.landmark)
  return landmark_;
}

// repeated float landmarkScores = 8;
inline int ObstacleRaw::_internal_landmarkscores_size() const {
  return landmarkscores_.size();
}
inline int ObstacleRaw::landmarkscores_size() const {
  return _internal_landmarkscores_size();
}
inline void ObstacleRaw::clear_landmarkscores() {
  landmarkscores_.Clear();
}
inline float ObstacleRaw::_internal_landmarkscores(int index) const {
  return landmarkscores_.Get(index);
}
inline float ObstacleRaw::landmarkscores(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.landmarkScores)
  return _internal_landmarkscores(index);
}
inline void ObstacleRaw::set_landmarkscores(int index, float value) {
  landmarkscores_.Set(index, value);
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.landmarkScores)
}
inline void ObstacleRaw::_internal_add_landmarkscores(float value) {
  landmarkscores_.Add(value);
}
inline void ObstacleRaw::add_landmarkscores(float value) {
  _internal_add_landmarkscores(value);
  // @@protoc_insertion_point(field_add:od.ObstacleRaw.landmarkScores)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ObstacleRaw::_internal_landmarkscores() const {
  return landmarkscores_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ObstacleRaw::landmarkscores() const {
  // @@protoc_insertion_point(field_list:od.ObstacleRaw.landmarkScores)
  return _internal_landmarkscores();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ObstacleRaw::_internal_mutable_landmarkscores() {
  return &landmarkscores_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ObstacleRaw::mutable_landmarkscores() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleRaw.landmarkScores)
  return _internal_mutable_landmarkscores();
}

// repeated .od.Point2f landmark4 = 9;
inline int ObstacleRaw::_internal_landmark4_size() const {
  return landmark4_.size();
}
inline int ObstacleRaw::landmark4_size() const {
  return _internal_landmark4_size();
}
inline void ObstacleRaw::clear_landmark4() {
  landmark4_.Clear();
}
inline ::od::Point2f* ObstacleRaw::mutable_landmark4(int index) {
  // @@protoc_insertion_point(field_mutable:od.ObstacleRaw.landmark4)
  return landmark4_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >*
ObstacleRaw::mutable_landmark4() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleRaw.landmark4)
  return &landmark4_;
}
inline const ::od::Point2f& ObstacleRaw::_internal_landmark4(int index) const {
  return landmark4_.Get(index);
}
inline const ::od::Point2f& ObstacleRaw::landmark4(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.landmark4)
  return _internal_landmark4(index);
}
inline ::od::Point2f* ObstacleRaw::_internal_add_landmark4() {
  return landmark4_.Add();
}
inline ::od::Point2f* ObstacleRaw::add_landmark4() {
  ::od::Point2f* _add = _internal_add_landmark4();
  // @@protoc_insertion_point(field_add:od.ObstacleRaw.landmark4)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >&
ObstacleRaw::landmark4() const {
  // @@protoc_insertion_point(field_list:od.ObstacleRaw.landmark4)
  return landmark4_;
}

// repeated float landmark4Scores = 10;
inline int ObstacleRaw::_internal_landmark4scores_size() const {
  return landmark4scores_.size();
}
inline int ObstacleRaw::landmark4scores_size() const {
  return _internal_landmark4scores_size();
}
inline void ObstacleRaw::clear_landmark4scores() {
  landmark4scores_.Clear();
}
inline float ObstacleRaw::_internal_landmark4scores(int index) const {
  return landmark4scores_.Get(index);
}
inline float ObstacleRaw::landmark4scores(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.landmark4Scores)
  return _internal_landmark4scores(index);
}
inline void ObstacleRaw::set_landmark4scores(int index, float value) {
  landmark4scores_.Set(index, value);
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.landmark4Scores)
}
inline void ObstacleRaw::_internal_add_landmark4scores(float value) {
  landmark4scores_.Add(value);
}
inline void ObstacleRaw::add_landmark4scores(float value) {
  _internal_add_landmark4scores(value);
  // @@protoc_insertion_point(field_add:od.ObstacleRaw.landmark4Scores)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ObstacleRaw::_internal_landmark4scores() const {
  return landmark4scores_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ObstacleRaw::landmark4scores() const {
  // @@protoc_insertion_point(field_list:od.ObstacleRaw.landmark4Scores)
  return _internal_landmark4scores();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ObstacleRaw::_internal_mutable_landmark4scores() {
  return &landmark4scores_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ObstacleRaw::mutable_landmark4scores() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleRaw.landmark4Scores)
  return _internal_mutable_landmark4scores();
}

// repeated .od.Point2f landmark9 = 11;
inline int ObstacleRaw::_internal_landmark9_size() const {
  return landmark9_.size();
}
inline int ObstacleRaw::landmark9_size() const {
  return _internal_landmark9_size();
}
inline void ObstacleRaw::clear_landmark9() {
  landmark9_.Clear();
}
inline ::od::Point2f* ObstacleRaw::mutable_landmark9(int index) {
  // @@protoc_insertion_point(field_mutable:od.ObstacleRaw.landmark9)
  return landmark9_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >*
ObstacleRaw::mutable_landmark9() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleRaw.landmark9)
  return &landmark9_;
}
inline const ::od::Point2f& ObstacleRaw::_internal_landmark9(int index) const {
  return landmark9_.Get(index);
}
inline const ::od::Point2f& ObstacleRaw::landmark9(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.landmark9)
  return _internal_landmark9(index);
}
inline ::od::Point2f* ObstacleRaw::_internal_add_landmark9() {
  return landmark9_.Add();
}
inline ::od::Point2f* ObstacleRaw::add_landmark9() {
  ::od::Point2f* _add = _internal_add_landmark9();
  // @@protoc_insertion_point(field_add:od.ObstacleRaw.landmark9)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::Point2f >&
ObstacleRaw::landmark9() const {
  // @@protoc_insertion_point(field_list:od.ObstacleRaw.landmark9)
  return landmark9_;
}

// repeated float landmark9Scores = 12;
inline int ObstacleRaw::_internal_landmark9scores_size() const {
  return landmark9scores_.size();
}
inline int ObstacleRaw::landmark9scores_size() const {
  return _internal_landmark9scores_size();
}
inline void ObstacleRaw::clear_landmark9scores() {
  landmark9scores_.Clear();
}
inline float ObstacleRaw::_internal_landmark9scores(int index) const {
  return landmark9scores_.Get(index);
}
inline float ObstacleRaw::landmark9scores(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.landmark9Scores)
  return _internal_landmark9scores(index);
}
inline void ObstacleRaw::set_landmark9scores(int index, float value) {
  landmark9scores_.Set(index, value);
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.landmark9Scores)
}
inline void ObstacleRaw::_internal_add_landmark9scores(float value) {
  landmark9scores_.Add(value);
}
inline void ObstacleRaw::add_landmark9scores(float value) {
  _internal_add_landmark9scores(value);
  // @@protoc_insertion_point(field_add:od.ObstacleRaw.landmark9Scores)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ObstacleRaw::_internal_landmark9scores() const {
  return landmark9scores_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ObstacleRaw::landmark9scores() const {
  // @@protoc_insertion_point(field_list:od.ObstacleRaw.landmark9Scores)
  return _internal_landmark9scores();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ObstacleRaw::_internal_mutable_landmark9scores() {
  return &landmark9scores_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ObstacleRaw::mutable_landmark9scores() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleRaw.landmark9Scores)
  return _internal_mutable_landmark9scores();
}

// optional .od.PositionInfo positionInfo = 13;
inline bool ObstacleRaw::_internal_has_positioninfo() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || positioninfo_ != nullptr);
  return value;
}
inline bool ObstacleRaw::has_positioninfo() const {
  return _internal_has_positioninfo();
}
inline void ObstacleRaw::clear_positioninfo() {
  if (positioninfo_ != nullptr) positioninfo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::od::PositionInfo& ObstacleRaw::_internal_positioninfo() const {
  const ::od::PositionInfo* p = positioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::PositionInfo&>(
      ::od::_PositionInfo_default_instance_);
}
inline const ::od::PositionInfo& ObstacleRaw::positioninfo() const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.positionInfo)
  return _internal_positioninfo();
}
inline void ObstacleRaw::unsafe_arena_set_allocated_positioninfo(
    ::od::PositionInfo* positioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positioninfo_);
  }
  positioninfo_ = positioninfo;
  if (positioninfo) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.ObstacleRaw.positionInfo)
}
inline ::od::PositionInfo* ObstacleRaw::release_positioninfo() {
  _has_bits_[0] &= ~0x00000008u;
  ::od::PositionInfo* temp = positioninfo_;
  positioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::PositionInfo* ObstacleRaw::unsafe_arena_release_positioninfo() {
  // @@protoc_insertion_point(field_release:od.ObstacleRaw.positionInfo)
  _has_bits_[0] &= ~0x00000008u;
  ::od::PositionInfo* temp = positioninfo_;
  positioninfo_ = nullptr;
  return temp;
}
inline ::od::PositionInfo* ObstacleRaw::_internal_mutable_positioninfo() {
  _has_bits_[0] |= 0x00000008u;
  if (positioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::PositionInfo>(GetArenaForAllocation());
    positioninfo_ = p;
  }
  return positioninfo_;
}
inline ::od::PositionInfo* ObstacleRaw::mutable_positioninfo() {
  ::od::PositionInfo* _msg = _internal_mutable_positioninfo();
  // @@protoc_insertion_point(field_mutable:od.ObstacleRaw.positionInfo)
  return _msg;
}
inline void ObstacleRaw::set_allocated_positioninfo(::od::PositionInfo* positioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete positioninfo_;
  }
  if (positioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::PositionInfo>::GetOwningArena(positioninfo);
    if (message_arena != submessage_arena) {
      positioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positioninfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  positioninfo_ = positioninfo;
  // @@protoc_insertion_point(field_set_allocated:od.ObstacleRaw.positionInfo)
}

// repeated float box3D = 14;
inline int ObstacleRaw::_internal_box3d_size() const {
  return box3d_.size();
}
inline int ObstacleRaw::box3d_size() const {
  return _internal_box3d_size();
}
inline void ObstacleRaw::clear_box3d() {
  box3d_.Clear();
}
inline float ObstacleRaw::_internal_box3d(int index) const {
  return box3d_.Get(index);
}
inline float ObstacleRaw::box3d(int index) const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.box3D)
  return _internal_box3d(index);
}
inline void ObstacleRaw::set_box3d(int index, float value) {
  box3d_.Set(index, value);
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.box3D)
}
inline void ObstacleRaw::_internal_add_box3d(float value) {
  box3d_.Add(value);
}
inline void ObstacleRaw::add_box3d(float value) {
  _internal_add_box3d(value);
  // @@protoc_insertion_point(field_add:od.ObstacleRaw.box3D)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ObstacleRaw::_internal_box3d() const {
  return box3d_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ObstacleRaw::box3d() const {
  // @@protoc_insertion_point(field_list:od.ObstacleRaw.box3D)
  return _internal_box3d();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ObstacleRaw::_internal_mutable_box3d() {
  return &box3d_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ObstacleRaw::mutable_box3d() {
  // @@protoc_insertion_point(field_mutable_list:od.ObstacleRaw.box3D)
  return _internal_mutable_box3d();
}

// optional int32 staticState = 15;
inline bool ObstacleRaw::_internal_has_staticstate() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ObstacleRaw::has_staticstate() const {
  return _internal_has_staticstate();
}
inline void ObstacleRaw::clear_staticstate() {
  staticstate_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ObstacleRaw::_internal_staticstate() const {
  return staticstate_;
}
inline int32_t ObstacleRaw::staticstate() const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.staticState)
  return _internal_staticstate();
}
inline void ObstacleRaw::_internal_set_staticstate(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  staticstate_ = value;
}
inline void ObstacleRaw::set_staticstate(int32_t value) {
  _internal_set_staticstate(value);
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.staticState)
}

// optional float attrScore = 16;
inline bool ObstacleRaw::_internal_has_attrscore() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ObstacleRaw::has_attrscore() const {
  return _internal_has_attrscore();
}
inline void ObstacleRaw::clear_attrscore() {
  attrscore_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float ObstacleRaw::_internal_attrscore() const {
  return attrscore_;
}
inline float ObstacleRaw::attrscore() const {
  // @@protoc_insertion_point(field_get:od.ObstacleRaw.attrScore)
  return _internal_attrscore();
}
inline void ObstacleRaw::_internal_set_attrscore(float value) {
  _has_bits_[0] |= 0x00000100u;
  attrscore_ = value;
}
inline void ObstacleRaw::set_attrscore(float value) {
  _internal_set_attrscore(value);
  // @@protoc_insertion_point(field_set:od.ObstacleRaw.attrScore)
}

// -------------------------------------------------------------------

// Bbox2D

// optional bool initialized = 1;
inline bool Bbox2D::_internal_has_initialized() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Bbox2D::has_initialized() const {
  return _internal_has_initialized();
}
inline void Bbox2D::clear_initialized() {
  initialized_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Bbox2D::_internal_initialized() const {
  return initialized_;
}
inline bool Bbox2D::initialized() const {
  // @@protoc_insertion_point(field_get:od.Bbox2D.initialized)
  return _internal_initialized();
}
inline void Bbox2D::_internal_set_initialized(bool value) {
  _has_bits_[0] |= 0x00000001u;
  initialized_ = value;
}
inline void Bbox2D::set_initialized(bool value) {
  _internal_set_initialized(value);
  // @@protoc_insertion_point(field_set:od.Bbox2D.initialized)
}

// optional float topLeftX = 2;
inline bool Bbox2D::_internal_has_topleftx() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Bbox2D::has_topleftx() const {
  return _internal_has_topleftx();
}
inline void Bbox2D::clear_topleftx() {
  topleftx_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Bbox2D::_internal_topleftx() const {
  return topleftx_;
}
inline float Bbox2D::topleftx() const {
  // @@protoc_insertion_point(field_get:od.Bbox2D.topLeftX)
  return _internal_topleftx();
}
inline void Bbox2D::_internal_set_topleftx(float value) {
  _has_bits_[0] |= 0x00000002u;
  topleftx_ = value;
}
inline void Bbox2D::set_topleftx(float value) {
  _internal_set_topleftx(value);
  // @@protoc_insertion_point(field_set:od.Bbox2D.topLeftX)
}

// optional float topLeftY = 3;
inline bool Bbox2D::_internal_has_toplefty() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Bbox2D::has_toplefty() const {
  return _internal_has_toplefty();
}
inline void Bbox2D::clear_toplefty() {
  toplefty_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Bbox2D::_internal_toplefty() const {
  return toplefty_;
}
inline float Bbox2D::toplefty() const {
  // @@protoc_insertion_point(field_get:od.Bbox2D.topLeftY)
  return _internal_toplefty();
}
inline void Bbox2D::_internal_set_toplefty(float value) {
  _has_bits_[0] |= 0x00000004u;
  toplefty_ = value;
}
inline void Bbox2D::set_toplefty(float value) {
  _internal_set_toplefty(value);
  // @@protoc_insertion_point(field_set:od.Bbox2D.topLeftY)
}

// optional float bottomRightX = 4;
inline bool Bbox2D::_internal_has_bottomrightx() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Bbox2D::has_bottomrightx() const {
  return _internal_has_bottomrightx();
}
inline void Bbox2D::clear_bottomrightx() {
  bottomrightx_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Bbox2D::_internal_bottomrightx() const {
  return bottomrightx_;
}
inline float Bbox2D::bottomrightx() const {
  // @@protoc_insertion_point(field_get:od.Bbox2D.bottomRightX)
  return _internal_bottomrightx();
}
inline void Bbox2D::_internal_set_bottomrightx(float value) {
  _has_bits_[0] |= 0x00000008u;
  bottomrightx_ = value;
}
inline void Bbox2D::set_bottomrightx(float value) {
  _internal_set_bottomrightx(value);
  // @@protoc_insertion_point(field_set:od.Bbox2D.bottomRightX)
}

// optional float bottomRightY = 5;
inline bool Bbox2D::_internal_has_bottomrighty() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Bbox2D::has_bottomrighty() const {
  return _internal_has_bottomrighty();
}
inline void Bbox2D::clear_bottomrighty() {
  bottomrighty_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Bbox2D::_internal_bottomrighty() const {
  return bottomrighty_;
}
inline float Bbox2D::bottomrighty() const {
  // @@protoc_insertion_point(field_get:od.Bbox2D.bottomRightY)
  return _internal_bottomrighty();
}
inline void Bbox2D::_internal_set_bottomrighty(float value) {
  _has_bits_[0] |= 0x00000010u;
  bottomrighty_ = value;
}
inline void Bbox2D::set_bottomrighty(float value) {
  _internal_set_bottomrighty(value);
  // @@protoc_insertion_point(field_set:od.Bbox2D.bottomRightY)
}

// optional float confidence = 6;
inline bool Bbox2D::_internal_has_confidence() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Bbox2D::has_confidence() const {
  return _internal_has_confidence();
}
inline void Bbox2D::clear_confidence() {
  confidence_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Bbox2D::_internal_confidence() const {
  return confidence_;
}
inline float Bbox2D::confidence() const {
  // @@protoc_insertion_point(field_get:od.Bbox2D.confidence)
  return _internal_confidence();
}
inline void Bbox2D::_internal_set_confidence(float value) {
  _has_bits_[0] |= 0x00000020u;
  confidence_ = value;
}
inline void Bbox2D::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:od.Bbox2D.confidence)
}

// -------------------------------------------------------------------

// DirectionInfo

// optional bool isValid = 1;
inline bool DirectionInfo::_internal_has_isvalid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectionInfo::has_isvalid() const {
  return _internal_has_isvalid();
}
inline void DirectionInfo::clear_isvalid() {
  isvalid_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DirectionInfo::_internal_isvalid() const {
  return isvalid_;
}
inline bool DirectionInfo::isvalid() const {
  // @@protoc_insertion_point(field_get:od.DirectionInfo.isValid)
  return _internal_isvalid();
}
inline void DirectionInfo::_internal_set_isvalid(bool value) {
  _has_bits_[0] |= 0x00000004u;
  isvalid_ = value;
}
inline void DirectionInfo::set_isvalid(bool value) {
  _internal_set_isvalid(value);
  // @@protoc_insertion_point(field_set:od.DirectionInfo.isValid)
}

// optional .od.Vector3f directionYpr = 2;
inline bool DirectionInfo::_internal_has_directionypr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || directionypr_ != nullptr);
  return value;
}
inline bool DirectionInfo::has_directionypr() const {
  return _internal_has_directionypr();
}
inline void DirectionInfo::clear_directionypr() {
  if (directionypr_ != nullptr) directionypr_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::od::Vector3f& DirectionInfo::_internal_directionypr() const {
  const ::od::Vector3f* p = directionypr_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3f&>(
      ::od::_Vector3f_default_instance_);
}
inline const ::od::Vector3f& DirectionInfo::directionypr() const {
  // @@protoc_insertion_point(field_get:od.DirectionInfo.directionYpr)
  return _internal_directionypr();
}
inline void DirectionInfo::unsafe_arena_set_allocated_directionypr(
    ::od::Vector3f* directionypr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(directionypr_);
  }
  directionypr_ = directionypr;
  if (directionypr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.DirectionInfo.directionYpr)
}
inline ::od::Vector3f* DirectionInfo::release_directionypr() {
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3f* temp = directionypr_;
  directionypr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3f* DirectionInfo::unsafe_arena_release_directionypr() {
  // @@protoc_insertion_point(field_release:od.DirectionInfo.directionYpr)
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3f* temp = directionypr_;
  directionypr_ = nullptr;
  return temp;
}
inline ::od::Vector3f* DirectionInfo::_internal_mutable_directionypr() {
  _has_bits_[0] |= 0x00000001u;
  if (directionypr_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3f>(GetArenaForAllocation());
    directionypr_ = p;
  }
  return directionypr_;
}
inline ::od::Vector3f* DirectionInfo::mutable_directionypr() {
  ::od::Vector3f* _msg = _internal_mutable_directionypr();
  // @@protoc_insertion_point(field_mutable:od.DirectionInfo.directionYpr)
  return _msg;
}
inline void DirectionInfo::set_allocated_directionypr(::od::Vector3f* directionypr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete directionypr_;
  }
  if (directionypr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3f>::GetOwningArena(directionypr);
    if (message_arena != submessage_arena) {
      directionypr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, directionypr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  directionypr_ = directionypr;
  // @@protoc_insertion_point(field_set_allocated:od.DirectionInfo.directionYpr)
}

// optional .od.Matrix3f directionYprUncertainty = 3;
inline bool DirectionInfo::_internal_has_directionypruncertainty() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || directionypruncertainty_ != nullptr);
  return value;
}
inline bool DirectionInfo::has_directionypruncertainty() const {
  return _internal_has_directionypruncertainty();
}
inline void DirectionInfo::clear_directionypruncertainty() {
  if (directionypruncertainty_ != nullptr) directionypruncertainty_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::od::Matrix3f& DirectionInfo::_internal_directionypruncertainty() const {
  const ::od::Matrix3f* p = directionypruncertainty_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Matrix3f&>(
      ::od::_Matrix3f_default_instance_);
}
inline const ::od::Matrix3f& DirectionInfo::directionypruncertainty() const {
  // @@protoc_insertion_point(field_get:od.DirectionInfo.directionYprUncertainty)
  return _internal_directionypruncertainty();
}
inline void DirectionInfo::unsafe_arena_set_allocated_directionypruncertainty(
    ::od::Matrix3f* directionypruncertainty) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(directionypruncertainty_);
  }
  directionypruncertainty_ = directionypruncertainty;
  if (directionypruncertainty) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.DirectionInfo.directionYprUncertainty)
}
inline ::od::Matrix3f* DirectionInfo::release_directionypruncertainty() {
  _has_bits_[0] &= ~0x00000002u;
  ::od::Matrix3f* temp = directionypruncertainty_;
  directionypruncertainty_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Matrix3f* DirectionInfo::unsafe_arena_release_directionypruncertainty() {
  // @@protoc_insertion_point(field_release:od.DirectionInfo.directionYprUncertainty)
  _has_bits_[0] &= ~0x00000002u;
  ::od::Matrix3f* temp = directionypruncertainty_;
  directionypruncertainty_ = nullptr;
  return temp;
}
inline ::od::Matrix3f* DirectionInfo::_internal_mutable_directionypruncertainty() {
  _has_bits_[0] |= 0x00000002u;
  if (directionypruncertainty_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Matrix3f>(GetArenaForAllocation());
    directionypruncertainty_ = p;
  }
  return directionypruncertainty_;
}
inline ::od::Matrix3f* DirectionInfo::mutable_directionypruncertainty() {
  ::od::Matrix3f* _msg = _internal_mutable_directionypruncertainty();
  // @@protoc_insertion_point(field_mutable:od.DirectionInfo.directionYprUncertainty)
  return _msg;
}
inline void DirectionInfo::set_allocated_directionypruncertainty(::od::Matrix3f* directionypruncertainty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete directionypruncertainty_;
  }
  if (directionypruncertainty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Matrix3f>::GetOwningArena(directionypruncertainty);
    if (message_arena != submessage_arena) {
      directionypruncertainty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, directionypruncertainty, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  directionypruncertainty_ = directionypruncertainty;
  // @@protoc_insertion_point(field_set_allocated:od.DirectionInfo.directionYprUncertainty)
}

// optional float yaw = 4;
inline bool DirectionInfo::_internal_has_yaw() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DirectionInfo::has_yaw() const {
  return _internal_has_yaw();
}
inline void DirectionInfo::clear_yaw() {
  yaw_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float DirectionInfo::_internal_yaw() const {
  return yaw_;
}
inline float DirectionInfo::yaw() const {
  // @@protoc_insertion_point(field_get:od.DirectionInfo.yaw)
  return _internal_yaw();
}
inline void DirectionInfo::_internal_set_yaw(float value) {
  _has_bits_[0] |= 0x00000008u;
  yaw_ = value;
}
inline void DirectionInfo::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:od.DirectionInfo.yaw)
}

// optional float yawUncertainty = 5;
inline bool DirectionInfo::_internal_has_yawuncertainty() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DirectionInfo::has_yawuncertainty() const {
  return _internal_has_yawuncertainty();
}
inline void DirectionInfo::clear_yawuncertainty() {
  yawuncertainty_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float DirectionInfo::_internal_yawuncertainty() const {
  return yawuncertainty_;
}
inline float DirectionInfo::yawuncertainty() const {
  // @@protoc_insertion_point(field_get:od.DirectionInfo.yawUncertainty)
  return _internal_yawuncertainty();
}
inline void DirectionInfo::_internal_set_yawuncertainty(float value) {
  _has_bits_[0] |= 0x00000010u;
  yawuncertainty_ = value;
}
inline void DirectionInfo::set_yawuncertainty(float value) {
  _internal_set_yawuncertainty(value);
  // @@protoc_insertion_point(field_set:od.DirectionInfo.yawUncertainty)
}

// optional float yawRate = 6;
inline bool DirectionInfo::_internal_has_yawrate() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DirectionInfo::has_yawrate() const {
  return _internal_has_yawrate();
}
inline void DirectionInfo::clear_yawrate() {
  yawrate_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float DirectionInfo::_internal_yawrate() const {
  return yawrate_;
}
inline float DirectionInfo::yawrate() const {
  // @@protoc_insertion_point(field_get:od.DirectionInfo.yawRate)
  return _internal_yawrate();
}
inline void DirectionInfo::_internal_set_yawrate(float value) {
  _has_bits_[0] |= 0x00000020u;
  yawrate_ = value;
}
inline void DirectionInfo::set_yawrate(float value) {
  _internal_set_yawrate(value);
  // @@protoc_insertion_point(field_set:od.DirectionInfo.yawRate)
}

// optional float yawRateUncertainty = 7;
inline bool DirectionInfo::_internal_has_yawrateuncertainty() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DirectionInfo::has_yawrateuncertainty() const {
  return _internal_has_yawrateuncertainty();
}
inline void DirectionInfo::clear_yawrateuncertainty() {
  yawrateuncertainty_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float DirectionInfo::_internal_yawrateuncertainty() const {
  return yawrateuncertainty_;
}
inline float DirectionInfo::yawrateuncertainty() const {
  // @@protoc_insertion_point(field_get:od.DirectionInfo.yawRateUncertainty)
  return _internal_yawrateuncertainty();
}
inline void DirectionInfo::_internal_set_yawrateuncertainty(float value) {
  _has_bits_[0] |= 0x00000040u;
  yawrateuncertainty_ = value;
}
inline void DirectionInfo::set_yawrateuncertainty(float value) {
  _internal_set_yawrateuncertainty(value);
  // @@protoc_insertion_point(field_set:od.DirectionInfo.yawRateUncertainty)
}

// optional int32 surface = 8;
inline bool DirectionInfo::_internal_has_surface() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DirectionInfo::has_surface() const {
  return _internal_has_surface();
}
inline void DirectionInfo::clear_surface() {
  surface_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t DirectionInfo::_internal_surface() const {
  return surface_;
}
inline int32_t DirectionInfo::surface() const {
  // @@protoc_insertion_point(field_get:od.DirectionInfo.surface)
  return _internal_surface();
}
inline void DirectionInfo::_internal_set_surface(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  surface_ = value;
}
inline void DirectionInfo::set_surface(int32_t value) {
  _internal_set_surface(value);
  // @@protoc_insertion_point(field_set:od.DirectionInfo.surface)
}

// optional float surfaceScore = 9;
inline bool DirectionInfo::_internal_has_surfacescore() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DirectionInfo::has_surfacescore() const {
  return _internal_has_surfacescore();
}
inline void DirectionInfo::clear_surfacescore() {
  surfacescore_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float DirectionInfo::_internal_surfacescore() const {
  return surfacescore_;
}
inline float DirectionInfo::surfacescore() const {
  // @@protoc_insertion_point(field_get:od.DirectionInfo.surfaceScore)
  return _internal_surfacescore();
}
inline void DirectionInfo::_internal_set_surfacescore(float value) {
  _has_bits_[0] |= 0x00000100u;
  surfacescore_ = value;
}
inline void DirectionInfo::set_surfacescore(float value) {
  _internal_set_surfacescore(value);
  // @@protoc_insertion_point(field_set:od.DirectionInfo.surfaceScore)
}

// -------------------------------------------------------------------

// UssRange

// optional string distanceId = 1;
inline bool UssRange::_internal_has_distanceid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UssRange::has_distanceid() const {
  return _internal_has_distanceid();
}
inline void UssRange::clear_distanceid() {
  distanceid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UssRange::distanceid() const {
  // @@protoc_insertion_point(field_get:od.UssRange.distanceId)
  return _internal_distanceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UssRange::set_distanceid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 distanceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:od.UssRange.distanceId)
}
inline std::string* UssRange::mutable_distanceid() {
  std::string* _s = _internal_mutable_distanceid();
  // @@protoc_insertion_point(field_mutable:od.UssRange.distanceId)
  return _s;
}
inline const std::string& UssRange::_internal_distanceid() const {
  return distanceid_.Get();
}
inline void UssRange::_internal_set_distanceid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  distanceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UssRange::_internal_mutable_distanceid() {
  _has_bits_[0] |= 0x00000001u;
  return distanceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UssRange::release_distanceid() {
  // @@protoc_insertion_point(field_release:od.UssRange.distanceId)
  if (!_internal_has_distanceid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = distanceid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (distanceid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    distanceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UssRange::set_allocated_distanceid(std::string* distanceid) {
  if (distanceid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  distanceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), distanceid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (distanceid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    distanceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:od.UssRange.distanceId)
}

// optional uint64 recvTimeNs = 2;
inline bool UssRange::_internal_has_recvtimens() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UssRange::has_recvtimens() const {
  return _internal_has_recvtimens();
}
inline void UssRange::clear_recvtimens() {
  recvtimens_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t UssRange::_internal_recvtimens() const {
  return recvtimens_;
}
inline uint64_t UssRange::recvtimens() const {
  // @@protoc_insertion_point(field_get:od.UssRange.recvTimeNs)
  return _internal_recvtimens();
}
inline void UssRange::_internal_set_recvtimens(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  recvtimens_ = value;
}
inline void UssRange::set_recvtimens(uint64_t value) {
  _internal_set_recvtimens(value);
  // @@protoc_insertion_point(field_set:od.UssRange.recvTimeNs)
}

// optional uint32 distance = 3;
inline bool UssRange::_internal_has_distance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UssRange::has_distance() const {
  return _internal_has_distance();
}
inline void UssRange::clear_distance() {
  distance_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t UssRange::_internal_distance() const {
  return distance_;
}
inline uint32_t UssRange::distance() const {
  // @@protoc_insertion_point(field_get:od.UssRange.distance)
  return _internal_distance();
}
inline void UssRange::_internal_set_distance(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  distance_ = value;
}
inline void UssRange::set_distance(uint32_t value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:od.UssRange.distance)
}

// optional bool isValid = 4;
inline bool UssRange::_internal_has_isvalid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UssRange::has_isvalid() const {
  return _internal_has_isvalid();
}
inline void UssRange::clear_isvalid() {
  isvalid_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool UssRange::_internal_isvalid() const {
  return isvalid_;
}
inline bool UssRange::isvalid() const {
  // @@protoc_insertion_point(field_get:od.UssRange.isValid)
  return _internal_isvalid();
}
inline void UssRange::_internal_set_isvalid(bool value) {
  _has_bits_[0] |= 0x00000010u;
  isvalid_ = value;
}
inline void UssRange::set_isvalid(bool value) {
  _internal_set_isvalid(value);
  // @@protoc_insertion_point(field_set:od.UssRange.isValid)
}

// optional .od.Vector3f position = 5;
inline bool UssRange::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool UssRange::has_position() const {
  return _internal_has_position();
}
inline void UssRange::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::od::Vector3f& UssRange::_internal_position() const {
  const ::od::Vector3f* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3f&>(
      ::od::_Vector3f_default_instance_);
}
inline const ::od::Vector3f& UssRange::position() const {
  // @@protoc_insertion_point(field_get:od.UssRange.position)
  return _internal_position();
}
inline void UssRange::unsafe_arena_set_allocated_position(
    ::od::Vector3f* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.UssRange.position)
}
inline ::od::Vector3f* UssRange::release_position() {
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3f* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3f* UssRange::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:od.UssRange.position)
  _has_bits_[0] &= ~0x00000002u;
  ::od::Vector3f* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::od::Vector3f* UssRange::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000002u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3f>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::od::Vector3f* UssRange::mutable_position() {
  ::od::Vector3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:od.UssRange.position)
  return _msg;
}
inline void UssRange::set_allocated_position(::od::Vector3f* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3f>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:od.UssRange.position)
}

// -------------------------------------------------------------------

// PositionInfo

// optional bool isValid = 1;
inline bool PositionInfo::_internal_has_isvalid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PositionInfo::has_isvalid() const {
  return _internal_has_isvalid();
}
inline void PositionInfo::clear_isvalid() {
  isvalid_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool PositionInfo::_internal_isvalid() const {
  return isvalid_;
}
inline bool PositionInfo::isvalid() const {
  // @@protoc_insertion_point(field_get:od.PositionInfo.isValid)
  return _internal_isvalid();
}
inline void PositionInfo::_internal_set_isvalid(bool value) {
  _has_bits_[0] |= 0x00000002u;
  isvalid_ = value;
}
inline void PositionInfo::set_isvalid(bool value) {
  _internal_set_isvalid(value);
  // @@protoc_insertion_point(field_set:od.PositionInfo.isValid)
}

// optional .od.Vector3f position = 2;
inline bool PositionInfo::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool PositionInfo::has_position() const {
  return _internal_has_position();
}
inline void PositionInfo::clear_position() {
  if (position_ != nullptr) position_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::od::Vector3f& PositionInfo::_internal_position() const {
  const ::od::Vector3f* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Vector3f&>(
      ::od::_Vector3f_default_instance_);
}
inline const ::od::Vector3f& PositionInfo::position() const {
  // @@protoc_insertion_point(field_get:od.PositionInfo.position)
  return _internal_position();
}
inline void PositionInfo::unsafe_arena_set_allocated_position(
    ::od::Vector3f* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.PositionInfo.position)
}
inline ::od::Vector3f* PositionInfo::release_position() {
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3f* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Vector3f* PositionInfo::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:od.PositionInfo.position)
  _has_bits_[0] &= ~0x00000001u;
  ::od::Vector3f* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::od::Vector3f* PositionInfo::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Vector3f>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::od::Vector3f* PositionInfo::mutable_position() {
  ::od::Vector3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:od.PositionInfo.position)
  return _msg;
}
inline void PositionInfo::set_allocated_position(::od::Vector3f* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Vector3f>::GetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:od.PositionInfo.position)
}

// -------------------------------------------------------------------

// FSLine

// repeated .od.FSLinesimple fsLine = 1;
inline int FSLine::_internal_fsline_size() const {
  return fsline_.size();
}
inline int FSLine::fsline_size() const {
  return _internal_fsline_size();
}
inline void FSLine::clear_fsline() {
  fsline_.Clear();
}
inline ::od::FSLinesimple* FSLine::mutable_fsline(int index) {
  // @@protoc_insertion_point(field_mutable:od.FSLine.fsLine)
  return fsline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinesimple >*
FSLine::mutable_fsline() {
  // @@protoc_insertion_point(field_mutable_list:od.FSLine.fsLine)
  return &fsline_;
}
inline const ::od::FSLinesimple& FSLine::_internal_fsline(int index) const {
  return fsline_.Get(index);
}
inline const ::od::FSLinesimple& FSLine::fsline(int index) const {
  // @@protoc_insertion_point(field_get:od.FSLine.fsLine)
  return _internal_fsline(index);
}
inline ::od::FSLinesimple* FSLine::_internal_add_fsline() {
  return fsline_.Add();
}
inline ::od::FSLinesimple* FSLine::add_fsline() {
  ::od::FSLinesimple* _add = _internal_add_fsline();
  // @@protoc_insertion_point(field_add:od.FSLine.fsLine)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinesimple >&
FSLine::fsline() const {
  // @@protoc_insertion_point(field_list:od.FSLine.fsLine)
  return fsline_;
}

// -------------------------------------------------------------------

// FSLinesimple

// optional .od.Header header = 1;
inline bool FSLinesimple::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool FSLinesimple::has_header() const {
  return _internal_has_header();
}
inline void FSLinesimple::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::od::Header& FSLinesimple::_internal_header() const {
  const ::od::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Header&>(
      ::od::_Header_default_instance_);
}
inline const ::od::Header& FSLinesimple::header() const {
  // @@protoc_insertion_point(field_get:od.FSLinesimple.header)
  return _internal_header();
}
inline void FSLinesimple::unsafe_arena_set_allocated_header(
    ::od::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.FSLinesimple.header)
}
inline ::od::Header* FSLinesimple::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::od::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Header* FSLinesimple::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:od.FSLinesimple.header)
  _has_bits_[0] &= ~0x00000001u;
  ::od::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::od::Header* FSLinesimple::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::od::Header* FSLinesimple::mutable_header() {
  ::od::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:od.FSLinesimple.header)
  return _msg;
}
inline void FSLinesimple::set_allocated_header(::od::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Header>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:od.FSLinesimple.header)
}

// optional uint64 frameTimestampNs = 2;
inline bool FSLinesimple::_internal_has_frametimestampns() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FSLinesimple::has_frametimestampns() const {
  return _internal_has_frametimestampns();
}
inline void FSLinesimple::clear_frametimestampns() {
  frametimestampns_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t FSLinesimple::_internal_frametimestampns() const {
  return frametimestampns_;
}
inline uint64_t FSLinesimple::frametimestampns() const {
  // @@protoc_insertion_point(field_get:od.FSLinesimple.frameTimestampNs)
  return _internal_frametimestampns();
}
inline void FSLinesimple::_internal_set_frametimestampns(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  frametimestampns_ = value;
}
inline void FSLinesimple::set_frametimestampns(uint64_t value) {
  _internal_set_frametimestampns(value);
  // @@protoc_insertion_point(field_set:od.FSLinesimple.frameTimestampNs)
}

// repeated .od.FSLinePoint fsLinepoints = 3;
inline int FSLinesimple::_internal_fslinepoints_size() const {
  return fslinepoints_.size();
}
inline int FSLinesimple::fslinepoints_size() const {
  return _internal_fslinepoints_size();
}
inline void FSLinesimple::clear_fslinepoints() {
  fslinepoints_.Clear();
}
inline ::od::FSLinePoint* FSLinesimple::mutable_fslinepoints(int index) {
  // @@protoc_insertion_point(field_mutable:od.FSLinesimple.fsLinepoints)
  return fslinepoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinePoint >*
FSLinesimple::mutable_fslinepoints() {
  // @@protoc_insertion_point(field_mutable_list:od.FSLinesimple.fsLinepoints)
  return &fslinepoints_;
}
inline const ::od::FSLinePoint& FSLinesimple::_internal_fslinepoints(int index) const {
  return fslinepoints_.Get(index);
}
inline const ::od::FSLinePoint& FSLinesimple::fslinepoints(int index) const {
  // @@protoc_insertion_point(field_get:od.FSLinesimple.fsLinepoints)
  return _internal_fslinepoints(index);
}
inline ::od::FSLinePoint* FSLinesimple::_internal_add_fslinepoints() {
  return fslinepoints_.Add();
}
inline ::od::FSLinePoint* FSLinesimple::add_fslinepoints() {
  ::od::FSLinePoint* _add = _internal_add_fslinepoints();
  // @@protoc_insertion_point(field_add:od.FSLinesimple.fsLinepoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::od::FSLinePoint >&
FSLinesimple::fslinepoints() const {
  // @@protoc_insertion_point(field_list:od.FSLinesimple.fsLinepoints)
  return fslinepoints_;
}

// -------------------------------------------------------------------

// FSLinePoint

// optional .od.Point2f coordinate = 1;
inline bool FSLinePoint::_internal_has_coordinate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || coordinate_ != nullptr);
  return value;
}
inline bool FSLinePoint::has_coordinate() const {
  return _internal_has_coordinate();
}
inline void FSLinePoint::clear_coordinate() {
  if (coordinate_ != nullptr) coordinate_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::od::Point2f& FSLinePoint::_internal_coordinate() const {
  const ::od::Point2f* p = coordinate_;
  return p != nullptr ? *p : reinterpret_cast<const ::od::Point2f&>(
      ::od::_Point2f_default_instance_);
}
inline const ::od::Point2f& FSLinePoint::coordinate() const {
  // @@protoc_insertion_point(field_get:od.FSLinePoint.coordinate)
  return _internal_coordinate();
}
inline void FSLinePoint::unsafe_arena_set_allocated_coordinate(
    ::od::Point2f* coordinate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coordinate_);
  }
  coordinate_ = coordinate;
  if (coordinate) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:od.FSLinePoint.coordinate)
}
inline ::od::Point2f* FSLinePoint::release_coordinate() {
  _has_bits_[0] &= ~0x00000001u;
  ::od::Point2f* temp = coordinate_;
  coordinate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::od::Point2f* FSLinePoint::unsafe_arena_release_coordinate() {
  // @@protoc_insertion_point(field_release:od.FSLinePoint.coordinate)
  _has_bits_[0] &= ~0x00000001u;
  ::od::Point2f* temp = coordinate_;
  coordinate_ = nullptr;
  return temp;
}
inline ::od::Point2f* FSLinePoint::_internal_mutable_coordinate() {
  _has_bits_[0] |= 0x00000001u;
  if (coordinate_ == nullptr) {
    auto* p = CreateMaybeMessage<::od::Point2f>(GetArenaForAllocation());
    coordinate_ = p;
  }
  return coordinate_;
}
inline ::od::Point2f* FSLinePoint::mutable_coordinate() {
  ::od::Point2f* _msg = _internal_mutable_coordinate();
  // @@protoc_insertion_point(field_mutable:od.FSLinePoint.coordinate)
  return _msg;
}
inline void FSLinePoint::set_allocated_coordinate(::od::Point2f* coordinate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete coordinate_;
  }
  if (coordinate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::od::Point2f>::GetOwningArena(coordinate);
    if (message_arena != submessage_arena) {
      coordinate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:od.FSLinePoint.coordinate)
}

// optional .od.SpaceLabel pointLabel = 2;
inline bool FSLinePoint::_internal_has_pointlabel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FSLinePoint::has_pointlabel() const {
  return _internal_has_pointlabel();
}
inline void FSLinePoint::clear_pointlabel() {
  pointlabel_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::od::SpaceLabel FSLinePoint::_internal_pointlabel() const {
  return static_cast< ::od::SpaceLabel >(pointlabel_);
}
inline ::od::SpaceLabel FSLinePoint::pointlabel() const {
  // @@protoc_insertion_point(field_get:od.FSLinePoint.pointLabel)
  return _internal_pointlabel();
}
inline void FSLinePoint::_internal_set_pointlabel(::od::SpaceLabel value) {
  _has_bits_[0] |= 0x00000002u;
  pointlabel_ = value;
}
inline void FSLinePoint::set_pointlabel(::od::SpaceLabel value) {
  _internal_set_pointlabel(value);
  // @@protoc_insertion_point(field_set:od.FSLinePoint.pointLabel)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace od

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::od::MotionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::od::MotionStatus>() {
  return ::od::MotionStatus_descriptor();
}
template <> struct is_proto_enum< ::od::SpaceLabel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::od::SpaceLabel>() {
  return ::od::SpaceLabel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_od_2eproto
